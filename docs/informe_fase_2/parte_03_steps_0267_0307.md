# Bit√°cora de Desarrollo - Fase 2 (v0.0.2)

**Objetivo**: Migraci√≥n del N√∫cleo a C++/Cython y Audio (APU).

**Estado**: En desarrollo.

---

## Objetivos Principales de la Fase 2

### 1. Migraci√≥n del N√∫cleo a C++/Cython
- [ ] Reescritura de CPU (LR35902) en C++ con wrapper Cython
- [x] Migraci√≥n de MMU a c√≥digo compilado
- [x] Migraci√≥n de PPU a c√≥digo compilado (Fase A: Timing y Estado)
- [ ] Optimizaci√≥n de sincronizaci√≥n ciclo a ciclo
- [ ] Mantener interfaz Python para frontend y tests

### 2. Implementaci√≥n de Audio (APU)
- [ ] Canal 1: Onda cuadrada con Sweep y Envelope
- [ ] Canal 2: Onda cuadrada con Envelope
- [ ] Canal 3: Onda arbitraria (Wave RAM)
- [ ] Canal 4: Ruido blanco (LFSR)
- [ ] Mezcla de canales y salida a 44100Hz/48000Hz
- [ ] Sincronizaci√≥n de audio con emulaci√≥n (Dynamic Rate Control o Ring Buffer)

### 3. Mejoras de Arquitectura
- [x] Arquitectura h√≠brida Python/C++ establecida
- [ ] Gesti√≥n de memoria optimizada
- [ ] Tests h√≠bridos (Python instancia Cython -> Cython llama C++)

---

## Entradas de Desarrollo


---

*Esta parte contiene Steps 267 a 307*

---

### 2025-12-25 - Step 0307: Optimizaci√≥n de Renderizado y Correcci√≥n de Desincronizaci√≥n
**Estado**: ‚úÖ IMPLEMENTACI√ìN COMPLETADA, ‚è≥ PENDIENTE DE VERIFICACI√ìN

Implementaci√≥n de optimizaciones cr√≠ticas basadas en los hallazgos del Step 0306: optimizaci√≥n del renderizado para reducir el bucle de 23,040 iteraciones, cacheo de pygame.transform.scale(), y correcci√≥n de la desincronizaci√≥n entre C++ y Python usando snapshots inmutables del framebuffer.

**Objetivo**:
- Mejorar el rendimiento (de ~21.8 FPS a ~60 FPS)
- Eliminar la corrupci√≥n gr√°fica (patr√≥n de tablero de ajedrez, sprites fragmentados)
- Implementar snapshot inmutable del framebuffer para evitar desincronizaci√≥n

**Optimizaciones Implementadas**:

1. **Snapshot Inmutable del Framebuffer**:
   - Conversi√≥n de memoryview a lista cuando no se proporciona framebuffer_data
   - Evita desincronizaci√≥n entre C++ (escritura) y Python (lectura)
   - Garantiza consistencia de datos, aunque tenga un costo de memoria (~23 KB por frame)

2. **Renderizado Vectorizado con NumPy**:
   - Reemplazo del bucle p√≠xel a p√≠xel (23,040 iteraciones) con operaciones vectorizadas
   - Uso de `numpy` y `pygame.surfarray` para renderizado r√°pido
   - Fallback a PixelArray optimizado si NumPy no est√° disponible

3. **Cache de Scaling**:
   - Cacheo de `pygame.transform.scale()` para evitar recalcular cuando el tama√±o no cambia
   - Invalidaci√≥n del cache basada en hash del contenido y tama√±o de pantalla
   - Reducci√≥n significativa de operaciones costosas de transformaci√≥n

**Conceptos de Hardware**:

- **Optimizaci√≥n de Renderizado**: Las operaciones vectorizadas (NumPy) son mucho m√°s r√°pidas que bucles en Python porque ejecutan operaciones en c√≥digo compilado, evitando el overhead del int√©rprete
- **Desincronizaci√≥n en Emulaci√≥n**: Si C++ escribe en el framebuffer mientras Python lo lee, puede haber corrupci√≥n. Los snapshots inmutables (copias) garantizan consistencia
- **Cache de Transformaciones**: Las transformaciones de imagen son operaciones costosas; cachear resultados cuando el contenido no cambia evita trabajo redundante

**Archivos modificados**:
- `src/gpu/renderer.py` - Implementaci√≥n de optimizaciones de renderizado, snapshot inmutable, y cache de scaling
- `docs/bitacora/entries/2025-12-25__0307__optimizacion-renderizado-correccion-desincronizacion.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0307
- `INFORME_FASE_2.md` - Esta entrada

**Verificaci√≥n**:
- ‚úÖ Script de an√°lisis automatizado creado: `tools/analizar_perf_step_0307.ps1`
- ‚úÖ Documentaci√≥n de verificaci√≥n actualizada: `RESUMEN_STEP_0307_OPTIMIZACIONES.md`
- ‚è≥ **Pendiente**: Ejecutar verificaciones visuales y de rendimiento (requiere ROM)

**Instrucciones de verificaci√≥n**:
1. **Verificaci√≥n visual** (2-3 minutos): `python main.py roms/pkmn.gb`
   - Observar FPS, corrupci√≥n gr√°fica, sprites, rayas verdes
2. **Medici√≥n de rendimiento** (30 segundos): `python main.py roms/pkmn.gb > perf_step_0307.log 2>&1`
   - Analizar logs con: `.\tools\analizar_perf_step_0307.ps1`
3. **Actualizar resultados**: Completar secci√≥n "Resultados de Verificaci√≥n" en `RESUMEN_STEP_0307_OPTIMIZACIONES.md`

**Pr√≥ximos pasos** (despu√©s de verificaci√≥n):
- Si FPS mejora significativamente: Verificar con pruebas m√°s largas (10+ minutos)
- Si la corrupci√≥n desaparece: Considerar el problema resuelto y documentar resultados finales
- Si persisten problemas: Investigar m√°s profundamente o considerar otras optimizaciones

---

### 2025-12-25 - Step 0306: Investigaci√≥n de Rendimiento y Corrupci√≥n Gr√°fica
**Estado**: üîÑ EN PROGRESO (DRAFT)

Investigaci√≥n exhaustiva de dos problemas cr√≠ticos identificados en Step 0305: rendimiento bajo (FPS 21.8 en lugar de ~60 FPS) y corrupci√≥n gr√°fica (patr√≥n de tablero de ajedrez, sprites fragmentados). Se implement√≥ un monitor de rendimiento ([PERFORMANCE-TRACE]) para medir el tiempo de frame y FPS, y se analizaron las posibles causas de ambos problemas.

**Objetivo**:
- Identificar las causas ra√≠z del rendimiento bajo y la corrupci√≥n gr√°fica
- Determinar si los problemas est√°n relacionados
- Implementar monitor de rendimiento para medir tiempo de frame y FPS

**An√°lisis de Corrupci√≥n Gr√°fica**:

1. **Patr√≥n de Tablero de Ajedrez**:
   - ‚úÖ C√°lculo de direcciones de tiles: Verificado - correcto
   - ‚úÖ Scroll (SCX/SCY): Verificado - aplicado correctamente
   - ‚úÖ Mapeo del tilemap: Verificado - correcto
   - ‚ö†Ô∏è **POSIBLE CAUSA**: Desincronizaci√≥n entre C++ (escritura) y Python (lectura) del framebuffer

2. **Sprites Fragmentados**:
   - ‚úÖ Renderizado de sprites: Verificado - l√≥gica correcta
   - ‚úÖ Orden de renderizado: Verificado - correcto
   - ‚úÖ OAM: Verificado - se lee correctamente
   - ‚ö†Ô∏è **POSIBLE CAUSA**: Renderizado sobre framebuffer parcial debido a desincronizaci√≥n

**An√°lisis de Rendimiento**:

**Operaciones Lentas Identificadas**:
1. **Bucle de renderizado p√≠xel a p√≠xel**: 23,040 iteraciones por frame (Alto impacto)
2. **pygame.transform.scale()**: Escalar 160x144 a 480x432 en cada frame (Medio-Alto impacto)
3. **Creaci√≥n de PixelArray**: Crear nuevo objeto en cada frame (Medio impacto)

**Causas Ra√≠z Identificadas**:

1. **Rendimiento Bajo**:
   - Causa principal: Bucle de renderizado p√≠xel a p√≠xel (23,040 iteraciones por frame)
   - Causa secundaria: `pygame.transform.scale()` sin cachear
   - Causa terciaria: Creaci√≥n de `PixelArray` en cada frame

2. **Corrupci√≥n Gr√°fica**:
   - Causa principal: Desincronizaci√≥n entre C++ (escritura) y Python (lectura) del framebuffer
   - Causa secundaria: Renderizado lento que permite leer framebuffer parcial

**Correlaci√≥n entre Problemas**:
- ‚úÖ **Confirmada**: S√≠, los problemas est√°n relacionados
- El rendimiento bajo puede causar corrupci√≥n gr√°fica porque:
  - Si el renderizado Python es lento, puede leer el framebuffer mientras C++ est√° escribiendo
  - Esto causar√≠a que algunos p√≠xeles muestren valores de frames anteriores o parciales
  - El patr√≥n de tablero de ajedrez podr√≠a ser el resultado de leer p√≠xeles de diferentes frames mezclados

**Monitor de Rendimiento Implementado**:
- **Monitor [PERFORMANCE-TRACE]**: Mide el tiempo de cada frame y calcula FPS
- Frecuencia: Cada 60 frames (1 segundo a 60 FPS)
- Formato: `[PERFORMANCE-TRACE] Frame N | Frame time: X.XXms | FPS: XX.X`

**Archivos modificados**:
- `src/gpu/renderer.py` - Implementaci√≥n de monitor de rendimiento ([PERFORMANCE-TRACE])
- `ANALISIS_STEP_0306_RENDIMIENTO_CORRUPCION.md` - Documento de an√°lisis completo
- `docs/bitacora/entries/2025-12-25__0306__investigacion-rendimiento-corrupcion.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0306
- `INFORME_FASE_2.md` - Esta entrada

**Pr√≥ximos pasos**:

**Prioridad Alta**:
- Optimizar renderizado (Step 0307): Cachear superficie escalada, optimizar bucle de renderizado, medir impacto con monitor de rendimiento
- Verificar sincronizaci√≥n (Step 0308): Confirmar que el snapshot se toma en el momento correcto, verificar que no hay condiciones de carrera

**Prioridad Media**:
- Probar correcciones: Ejecutar emulador y verificar FPS mejora, verificar que corrupci√≥n gr√°fica desaparece

---

### 2025-12-25 - Step 0305: Investigaci√≥n de Renderizado Python
**Estado**: üîÑ EN PROGRESO (DRAFT)

Investigaci√≥n exhaustiva del c√≥digo de renderizado en Python para identificar por qu√© aparecen rayas verdes cuando el framebuffer de PPU C++ solo contiene √≠ndices 0. Se implementaron 3 monitores adicionales para rastrear la paleta, el PixelArray y las modificaciones de paleta durante la ejecuci√≥n.

**Objetivo**:
- Identificar la causa ra√≠z de las rayas verdes que aparecen despu√©s de ~2 minutos de ejecuci√≥n
- Verificar que todas las paletas est√©n corregidas y no haya c√≥digo adicional que renderice
- Implementar monitores para rastrear el flujo de renderizado completo

**Hip√≥tesis evaluadas**:
1. **Hip√≥tesis A**: La paleta se modifica durante la ejecuci√≥n - ‚úÖ Monitor [PALETTE-MODIFIED] implementado
2. **Hip√≥tesis B**: Hay otro c√≥digo que renderiza usando una paleta incorrecta - ‚úÖ Rechazada (b√∫squeda exhaustiva)
3. **Hip√≥tesis C**: Problema con PixelArray o scaling que causa artefactos visuales - ‚úÖ Monitor [PIXEL-VERIFY] implementado
4. **Hip√≥tesis D**: Hay alguna paleta que no se corrigi√≥ - ‚úÖ Rechazada (todas las paletas verificadas)

**B√∫squedas realizadas**:
- ‚úÖ B√∫squeda de valores verdes: No se encontraron valores verdes en el c√≥digo
- ‚úÖ B√∫squeda de definiciones de paleta: 40 coincidencias encontradas, todas verificadas y corregidas
- ‚úÖ B√∫squeda de funciones de renderizado: 4 funciones encontradas (update_tile_cache, render_vram_debug, render_frame, render_sprites)
- ‚úÖ B√∫squeda de operaciones de renderizado: 17 operaciones encontradas (blit, fill, set_at)

**Monitores implementados**:

1. **Monitor [PALETTE-VERIFY]**:
   - Verifica la paleta usada en cada frame
   - Frecuencia: Cada 1000 frames o primeros 100 frames
   - Imprime los valores RGB de la paleta (Palette[0], Palette[1], Palette[2], Palette[3])

2. **Monitor [PIXEL-VERIFY]**:
   - Verifica el p√≠xel central antes del mapeo en PixelArray
   - Frecuencia: Primeros 10 frames
   - Verifica el p√≠xel central (l√≠nea 72, columna 80) antes y despu√©s del mapeo

3. **Monitor [PALETTE-MODIFIED]**:
   - Detecta si la paleta se modifica durante la ejecuci√≥n
   - Compara la paleta actual con la √∫ltima paleta verificada
   - Muestra stack trace si se detecta una modificaci√≥n

**Hallazgos**:
- ‚úÖ Todas las paletas est√°n corregidas: self.COLORS, debug_palette_map, palette0, palette1
- ‚úÖ No hay c√≥digo adicional que renderice: Solo hay un flujo de renderizado principal
- ‚úÖ Ejecuci√≥n completada: Emulador ejecutado y cerrado
- ‚úÖ An√°lisis visual realizado: Captura de pantalla analizada

**Nuevos Problemas Identificados**:
1. **Rendimiento Cr√≠tico** ‚ö†Ô∏è: FPS 21.8 (deber√≠a ser ~60 FPS) - problema nuevo identificado
2. **Corrupci√≥n Gr√°fica** ‚ö†Ô∏è: Patr√≥n de tablero de ajedrez, l√≠neas verticales, sprites fragmentados
3. **Problema de Rayas Verdes** ‚úÖ: **No se observaron rayas verdes** en la captura (posiblemente resuelto)

**Archivos modificados**:
- `src/gpu/renderer.py` - Implementaci√≥n de 3 monitores adicionales ([PALETTE-VERIFY], [PIXEL-VERIFY], [PALETTE-MODIFIED])
- `ANALISIS_STEP_0305_RENDERER.md` - Documento de an√°lisis con todos los hallazgos
- `debug_step_0305_renderer.log` - Logs de ejecuci√≥n (en progreso)
- `docs/bitacora/entries/2025-12-25__0305__investigacion-renderizado-python.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0305
- `INFORME_FASE_2.md` - Esta entrada

**Pr√≥ximos pasos**:

**Prioridad Alta**:
- Investigar Rendimiento (FPS 21.8): Profilar bucle de renderizado, verificar bloqueos, optimizar operaciones costosas
- Investigar Corrupci√≥n Gr√°fica: Verificar integridad del framebuffer, investigar patr√≥n de tablero de ajedrez, verificar sincronizaci√≥n

**Prioridad Media**:
- Verificar Problema de Rayas Verdes: Ejecutar sesi√≥n extendida (10-15 minutos) para confirmar que no aparecen
- Mejorar Monitores: Asegurar que los logs se generen correctamente, agregar monitores de rendimiento

---

### 2025-12-25 - Step 0304: Verificaci√≥n Extendida y Monitor de Framebuffer
**Estado**: üîÑ EN PROGRESO (DRAFT)

Implementaci√≥n de monitores de framebuffer con flags de activaci√≥n para rastrear qu√© √≠ndices tiene el framebuffer en cada frame y detectar cu√°ndo cambia de tener solo √≠ndices 0 a tener √≠ndices 1 o 2. Los monitores est√°n preparados pero desactivados por defecto, y solo se activar√°n si la verificaci√≥n visual extendida (10-15 minutos) confirma que las rayas verdes persisten despu√©s de las correcciones del Step 0303.

**Objetivo**:
- Verificar que las correcciones de paleta del Step 0303 eliminaron las rayas verdes durante una sesi√≥n extendida
- Si las rayas aparecen, identificar cu√°ndo y qu√© valores tiene el framebuffer
- Implementar monitores adicionales si es necesario para diagnosticar cambios en el framebuffer

**Monitores implementados**:

1. **Monitor en Python (`renderer.py`) - [FRAMEBUFFER-INDEX-TRACE]**:
   - Cuenta cu√°ntos p√≠xeles tienen cada √≠ndice (0, 1, 2, 3)
   - Detecta si hay valores no-cero (1, 2 o 3)
   - Registra informaci√≥n solo cuando hay cambios o cada 1000 frames
   - Limita a 100 registros para no saturar los logs
   - Flag de activaci√≥n: `self._framebuffer_trace_enabled = False` (cambiar a `True` si se necesitan logs)

2. **Monitor en C++ (`PPU.cpp`) - [FRAMEBUFFER-DETAILED]**:
   - Rastrea la l√≠nea central (LY=72) cada 1000 frames
   - Cuenta p√≠xeles no-cero en la l√≠nea central
   - Muestra una muestra de los primeros 32 p√≠xeles
   - Limita a 100 registros para no saturar los logs
   - Flag de activaci√≥n: `ENABLE_FRAMEBUFFER_DETAILED_TRACE = false` (cambiar a `true` si se necesitan logs)

**Archivos modificados**:
- `src/gpu/renderer.py` - Implementaci√≥n del monitor [FRAMEBUFFER-INDEX-TRACE] con flag de activaci√≥n
- `src/core/cpp/PPU.cpp` - Implementaci√≥n del monitor [FRAMEBUFFER-DETAILED] con flag de activaci√≥n
- `INSTRUCCIONES_VERIFICACION_STEP_0304.md` - Instrucciones para la verificaci√≥n visual extendida
- `docs/bitacora/entries/2025-12-25__0304__verificacion-extendida-monitor-framebuffer.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0304
- `INFORME_FASE_2.md` - Esta entrada

**Pr√≥ximos pasos**:
- Ejecutar verificaci√≥n visual extendida (10-15 minutos) con Pok√©mon Red
- Registrar observaciones: ¬øAparecen rayas verdes? ¬øCu√°ndo? ¬øC√≥mo se ven?
- Si NO aparecen rayas: Documentar √©xito y continuar con otras funcionalidades
- Si S√ç aparecen rayas: Activar monitores y ejecutar con logs capturados
- Analizar logs (si se capturaron) para identificar cu√°ndo y por qu√© cambia el framebuffer
- Generar resumen ejecutivo con hallazgos y conclusiones
- Step 0305 (si se necesita): Investigar c√≥digo de PPU C++ para identificar d√≥nde se escriben valores 1 o 2

---

### 2025-12-25 - Step 0303: Correcci√≥n de Paleta Debug √çndices 1 y 2
**Estado**: ‚úÖ COMPLETADO

Correcci√≥n de todas las paletas de debug en el renderer que usan colores verdes para los √≠ndices 1 y 2, cambi√°ndolos a grises verdaderos para eliminar las rayas verdes que aparecen cuando el framebuffer contiene valores 1 o 2.

**Problema identificado en Step 0302**:
- La paleta de debug usa colores **verdes** para los √≠ndices 1 y 2, no grises:
  - √çndice 1: `(136, 192, 112)` - VERDE, deber√≠a ser gris claro `(170, 170, 170)`
  - √çndice 2: `(52, 104, 86)` - VERDE, deber√≠a ser gris oscuro `(85, 85, 85)`
- Despu√©s de ~5 minutos, el framebuffer comienza a tener valores 1 o 2, que se muestran como verde

**Ubicaciones corregidas** (4 lugares):
1. **`self.COLORS` en `__init__()`** (l√≠neas 192-193)
2. **`render_frame()` con PPU C++** (l√≠neas 494-499)
3. **`render_frame()` m√©todo Python** (l√≠neas 579-584)
4. **`render_sprites()`** (l√≠neas 955-960)

**Valores corregidos**:
- √çndice 1: `(136, 192, 112)` ‚Üí `(170, 170, 170)` - Gris claro
- √çndice 2: `(52, 104, 86)` ‚Üí `(85, 85, 85)` - Gris oscuro

**Archivos modificados**:
- `src/gpu/renderer.py` - Corregidas 4 ubicaciones de paletas
- `docs/bitacora/entries/2025-12-25__0303__correccion-paleta-debug-indices-1-2.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0303
- `INFORME_FASE_2.md` - Esta entrada

**Resultado esperado**: Los p√≠xeles con √≠ndice 1 o 2 ahora deber√≠an mostrarse en gris (claro u oscuro), no verde, eliminando las rayas verdes visuales cuando el framebuffer tiene estos valores.

**Pr√≥ximos pasos**:
- Verificaci√≥n visual extendida (10+ minutos) para confirmar que las rayas verdes no aparecen
- Si las rayas desaparecen: Continuar con otras funcionalidades
- Si persisten problemas: Investigar por qu√© el framebuffer cambia de valores (Step 0304/0305)

---

### 2025-12-25 - Step 0302: Verificaci√≥n Extendida y An√°lisis de Monitores
**Estado**: ‚úÖ COMPLETADO

Ejecuci√≥n extendida del emulador durante 5 minutos con los monitores implementados en Step 0301 activos, captura de logs generados, y an√°lisis de resultados para verificar si las rayas verdes vuelven a aparecer y qu√© cambios ocurren cuando aparecen.

**Resultado cr√≠tico**:
- Las rayas verdes aparecieron a los 5 minutos de ejecuci√≥n
- Los monitores NO detectaron cambios en la paleta del √≠ndice 0, en `self.palette`, ni en el modo de renderizado
- Se identific√≥ que la paleta de debug usa colores **verdes** para los √≠ndices 1 y 2, no grises

**An√°lisis de monitores**:
1. **[PALETTE-USE-TRACE]**: 105 registros - Todos muestran paleta blanca `(255, 255, 255)` para √≠ndice 0 durante toda la ejecuci√≥n
2. **[PALETTE-SELF-CHANGE]**: 0 cambios - `self.palette` nunca cambi√≥
3. **[CPP-PPU-TOGGLE]**: 0 cambios - `use_cpp_ppu` nunca cambi√≥ (siempre True)

**Hallazgo cr√≠tico**:
- La paleta de debug en `renderer.py` (l√≠neas 496-497) usa colores verdes para √≠ndices 1 y 2:
  - √çndice 1: `(136, 192, 112)` - ES VERDE, NO GRIS
  - √çndice 2: `(52, 104, 86)` - ES VERDE, NO GRIS
- Si el framebuffer tiene valores 1 o 2, se mostrar√°n como verde
- Despu√©s de ~5 minutos, el framebuffer comienza a tener valores 1 o 2 en lugar de 0

**Causa ra√≠z pendiente**:
- No se identific√≥ por qu√© el framebuffer cambia de tener solo √≠ndices 0 a tener √≠ndices 1 o 2 despu√©s de 5 minutos
- Los monitores implementados solo rastrean la paleta del √≠ndice 0, no el contenido del framebuffer
- Se necesita implementar monitor de framebuffer para rastrear qu√© √≠ndices tiene el framebuffer

**Pr√≥ximos pasos**:
- Step 0303: Corregir paleta de debug cambiando colores verdes a grises verdaderos
- Step 0304: Implementar monitor de framebuffer para rastrear √≠ndices del framebuffer
- Step 0305: Analizar c√≥digo de PPU C++ para identificar d√≥nde se escriben valores 1 o 2

---

### 2025-12-25 - Step 0301: Investigaci√≥n de Rayas Verdes Recurrentes
**Estado**: ‚úÖ COMPLETADO

Investigaci√≥n de por qu√© las rayas verdes vuelven a aparecer despu√©s de unos minutos de ejecuci√≥n, a pesar de la correcci√≥n implementada en el Step 0300. Se implementaron 3 monitores de diagn√≥stico para rastrear el uso de paletas y cambios en el modo de renderizado, y se corrigi√≥ `self.COLORS` que a√∫n ten√≠a valores verdes para el √≠ndice 0.

**Problema identificado**:
- Las rayas verdes vuelven a aparecer despu√©s de unos minutos de ejecuci√≥n
- `self.COLORS` y `self.palette` a√∫n ten√≠an valores verdes `(224, 248, 208)` para el √≠ndice 0
- Posible uso de `self.palette` en lugar de la paleta debug local corregida

**Correcciones y monitores implementados**:
1. **Correcci√≥n de `self.COLORS`**: Cambiado el color del √≠ndice 0 de verde `(224, 248, 208)` a blanco `(255, 255, 255)` en `__init__()`
2. **Monitor [PALETTE-USE-TRACE]**: Rastrea qu√© paleta se usa en cada frame (primeros 100 frames + cada 1000 frames)
3. **Monitor [PALETTE-SELF-CHANGE]**: Detecta cambios en `self.palette` usando una propiedad con setter y stack trace
4. **Monitor [CPP-PPU-TOGGLE]**: Detecta cambios en `use_cpp_ppu` durante la ejecuci√≥n

**B√∫squeda de c√≥digo**:
- B√∫squeda exhaustiva confirm√≥ que no hay c√≥digo que use `self.palette` durante el renderizado
- Todas las referencias a `palette` son variables locales con la paleta debug corregida
- La correcci√≥n de `self.COLORS` es preventiva para asegurar valores correctos en el futuro

**Pr√≥ximos pasos**:
- Ejecutar el emulador durante varios minutos con los monitores activos
- Analizar logs generados para identificar patrones que coincidan con la aparici√≥n de rayas verdes

---

### 2025-12-25 - Step 0300: Correcci√≥n de Paleta Debug Renderer
**Estado**: ‚úÖ COMPLETADO

Correcci√≥n de la paleta de debug en el renderer de Python que estaba causando que los p√≠xeles con √≠ndice 0 (blanco) se mostraran como verde. El color del √≠ndice 0 se cambi√≥ de `(224, 248, 208)` (verde) a `(255, 255, 255)` (blanco verdadero) en los 3 lugares donde se define la paleta de debug.

**Problema identificado en Step 0299**:
- El framebuffer contiene solo √≠ndices 0x00 (todos los p√≠xeles tienen √≠ndice 0) - correcto
- La PPU funciona correctamente, mapea 0->0 con BGP=0xE4 - correcto
- El renderer Python mapeaba incorrectamente el √≠ndice 0 a verde `(224, 248, 208)` en lugar de blanco

**Correcci√≥n aplicada**:
- Cambiado el color del √≠ndice 0 de verde `(224, 248, 208)` a blanco `(255, 255, 255)` en 3 lugares:
  1. L√≠nea 470: Paleta de debug en `render_frame()` cuando usa PPU C++
  2. L√≠nea 538: Paleta de debug en `render_frame()` m√©todo Python
  3. L√≠nea 897: Paleta de debug en `render_sprites()`

**Archivos modificados**:
- `src/gpu/renderer.py` - Corregida paleta de debug en 3 funciones
- `docs/bitacora/entries/2025-12-25__0300__correccion-paleta-debug-renderer.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0300

**Resultado esperado**: Los p√≠xeles vac√≠os (√≠ndice 0) ahora deber√≠an mostrarse en blanco, no verde, eliminando el problema de las rayas verdes.

---

### 2025-12-25 - Step 0299: Investigaci√≥n de Rayas Verdes y Diagn√≥stico Visual
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de 4 monitores de diagn√≥stico visual para investigar por qu√© el emulador muestra rayas verticales verdes en lugar de gr√°ficos. Los monitores capturan el contenido real del framebuffer, los tile IDs del tilemap, los datos de tiles le√≠dos de VRAM, y la aplicaci√≥n de la paleta durante el renderizado de la l√≠nea central (LY=72).

**Monitores implementados**:
1. **[FRAMEBUFFER-DUMP]**: Captura los √≠ndices de color reales en el framebuffer (l√≠nea central, primeros 32 p√≠xeles)
2. **[TILEMAP-DUMP-VISUAL]**: Captura los tile IDs reales le√≠dos del tilemap (l√≠nea central, primeros 32 tiles)
3. **[TILEDATA-DUMP-VISUAL]**: Captura los datos reales de los tiles le√≠dos de VRAM (primeros 4 tiles)
4. **[PALETTE-DUMP-VISUAL]**: Captura la aplicaci√≥n de la paleta BGP (l√≠nea central, primeros 32 p√≠xeles)

**Hip√≥tesis sobre las rayas verdes**:
1. **Hip√≥tesis A**: Tilemap con valores repetidos (como 0x7F) que generan un patr√≥n
2. **Hip√≥tesis B**: Tiles vac√≠os (0x00) pero la paleta genera colores verdes
3. **Hip√≥tesis C**: C√°lculo incorrecto de direcciones de tiles, generando lecturas repetitivas
4. **Hip√≥tesis D**: El scroll (SCX/SCY) est√° generando un patr√≥n repetitivo

**Implementaci√≥n**:
- A√±adidos 4 monitores de diagn√≥stico visual en `src/core/cpp/PPU.cpp` dentro de `render_scanline()`
- Todos los monitores se activan durante el renderizado de la l√≠nea central (LY=72)
- L√≠mite de 3 frames para evitar saturaci√≥n de logs
- Captura de primeros 32 p√≠xeles/tiles para identificar patrones

**Archivos modificados**:
- `src/core/cpp/PPU.cpp` - A√±adidos 4 monitores de diagn√≥stico visual
- `ANALISIS_RAYAS_VERDES_STEP_0299.md` - Documento de an√°lisis (template para completar despu√©s de ejecuci√≥n)
- `docs/bitacora/entries/2025-12-25__0299__investigacion-rayas-verdes-diagnostico-visual.html` - Entrada HTML de bit√°cora
- `docs/bitacora/index.html` - Actualizado con entrada 0299

**Pr√≥ximos pasos**:
1. Ejecutar el emulador y capturar logs de los 4 monitores
2. Analizar los logs para identificar patrones en framebuffer, tilemap, tiles y paleta
3. Confirmar o rechazar las 4 hip√≥tesis sobre el origen de las rayas verdes
4. Identificar la causa ra√≠z del patr√≥n
5. Implementar correcci√≥n basada en los hallazgos (si aplica)

---

### 2025-12-25 - Step 0298: Ejecuci√≥n con Interacci√≥n y Decisi√≥n sobre Enfoque
**Estado**: ‚úÖ COMPLETADO

Ejecuci√≥n del emulador con Pok√©mon Red durante 60 segundos con simulaci√≥n de entrada del usuario (presionar botones autom√°ticamente) para verificar si la interacci√≥n activa la carga de tiles. El an√°lisis de los logs confirma que **NO se detectan accesos VRAM con datos reales** incluso despu√©s de 60 segundos con interacci√≥n simulada.

**Resultados del an√°lisis (60 segundos)**:
- **Total de l√≠neas en log**: 1,882,587
- **[SIM-INPUT]**: 0 (la simulaci√≥n no gener√≥ logs visibles)
- **[VRAM-ACCESS-GLOBAL.*DATA]**: 0 (ning√∫n acceso con datos != 0x00)
- **[ROM-TO-VRAM]**: 0 (ninguna copia desde ROM)
- **[LOAD-SEQUENCE]**: 1 (solo la rutina de limpieza en PC:0x36E3)
- **[TIMELINE-VRAM]**: 200 (todos accesos de limpieza)
- **[STATE-CHANGE]**: 79 (saltos grandes de PC detectados - el juego ejecuta c√≥digo normalmente)
- **[SCREEN-TRANSITION]**: 1 (una transici√≥n de pantalla detectada)

**Hallazgos clave**:
1. Todos los accesos VRAM son de limpieza (0x00) desde PC:0x36E3
2. No hay carga de datos reales en 60 segundos
3. El juego ejecuta c√≥digo normalmente (79 cambios de estado, 1 transici√≥n de pantalla)
4. La simulaci√≥n de entrada no gener√≥ logs visibles

**Decisi√≥n estrat√©gica**: Implementar **carga manual de tiles como hack temporal** para permitir avanzar con el desarrollo del emulador, mientras se investiga en paralelo el desensamblado del juego y posibles bugs sutiles en la emulaci√≥n.

**Implementaci√≥n**:
- Corregida firma de `load_cartridge()` en `src/viboy.py` para aceptar `load_test_tiles`
- Verificada funci√≥n `load_test_tiles()` en `src/core/cpp/MMU.cpp` (ya estaba implementada)
- Creado documento de decisi√≥n estrat√©gica: `DECISION_ESTRATEGICA_STEP_0298.md`

**Pr√≥ximos pasos**:
1. Verificar que `load_test_tiles()` funciona correctamente con `--load-test-tiles`
2. Continuar con otras funcionalidades del emulador mientras se investiga el problema en paralelo
3. Investigar desensamblado del juego para identificar rutinas de carga de tiles
4. Investigar posibles bugs sutiles en la emulaci√≥n

---

### 2025-12-25 - Step 0296: Verificaci√≥n y An√°lisis del Step 0295
**Estado**: ‚úÖ COMPLETADO

Ejecuci√≥n del plan de verificaci√≥n del Step 0295 para analizar los cinco monitores globales implementados. Se ejecut√≥ el emulador con Pok√©mon Red durante 12 segundos y se capturaron los logs de todos los monitores. El an√°lisis revela que **el c√≥digo de carga de tiles NO existe en esta fase del juego** (primeros 12 segundos de ejecuci√≥n).

**Resultados del an√°lisis**:
- **[VRAM-ACCESS-GLOBAL]**: 1001 accesos detectados, todos son CLEAR (0x00), todos desde PC 0x36E3
- **[PC-VRAM-CORRELATION]**: Solo 1 PC accede a VRAM (0x36E3 - rutina de limpieza)
- **[LOAD-SEQUENCE]**: 1 secuencia detectada, pero es de limpieza (0x00), no de carga real
- **[ROM-TO-VRAM]**: 0 copias desde ROM detectadas
- **[TIMING-VRAM]**: 1000 accesos, todos con LCD:ON pero BG:OFF, ninguno con BG:ON

**Conclusi√≥n definitiva**: ‚ùå **El c√≥digo de carga de tiles NO existe en esta fase del juego**. Todos los accesos a VRAM son de limpieza (0x00) desde la rutina 0x36E3, y ocurren durante la inicializaci√≥n cuando BG Display est√° OFF. No se detectaron accesos con datos reales, secuencias de carga de tiles, ni copias desde ROM.

**Evaluaci√≥n de hip√≥tesis**:
- **Hip√≥tesis A** (carga antes de BG): ‚ùå RECHAZADA - No hay accesos con datos reales
- **Hip√≥tesis B** (carga mucho despu√©s): ‚ö†Ô∏è PARCIALMENTE POSIBLE - El an√°lisis cubri√≥ solo 12 segundos
- **Hip√≥tesis C** (m√©todos no detectados): ‚ùå RECHAZADA - Todos los m√©todos est√°ndar fueron monitoreados
- **Hip√≥tesis D** (no existe en esta fase): ‚úÖ CONFIRMADA - No hay c√≥digo de carga en esta fase

**Recomendaciones**:
1. Ejecutar el emulador por m√°s tiempo (30-60 segundos) para verificar si el c√≥digo de carga se ejecuta m√°s tarde
2. Buscar en otras fases del juego (cambios de pantalla, men√∫s, batallas)
3. Investigar el desensamblado del juego para identificar rutinas de carga
4. Verificar si los tiles ya est√°n cargados en VRAM desde el inicio

**Documentos generados**:
- `ANALISIS_STEP_0295_VERIFICACION.md` - Documento de an√°lisis completo
- `debug_step_0295.log` - Logs de ejecuci√≥n (23.6 MB)

---

### 2025-12-25 - Step 0297: An√°lisis Extendido y T√©cnicas Alternativas
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de t√©cnicas alternativas de an√°lisis para identificar cu√°ndo se cargan los tiles en Pok√©mon Red. El an√°lisis del Step 0295 confirm√≥ que el c√≥digo de carga NO existe en los primeros 12 segundos (todos los accesos son limpieza desde PC:0x36E3). Se implementaron monitores adicionales para rastrear cambios de estado, transiciones de pantalla, timeline de accesos VRAM y dump inicial de VRAM.

**Monitores implementados**:
- **[STATE-CHANGE]**: Detecta cambios de estado que podr√≠an indicar transiciones a nuevas pantallas o fases donde se cargar√≠an tiles. Detecta saltos grandes (JP nn o CALL nn con distancia > 0x1000 bytes) y cambios significativos en el registro HL (> 0x1000 bytes de diferencia). Reporta hasta 50 saltos grandes y 30 cambios en HL.
- **[SCREEN-TRANSITION]**: Detecta patrones que indican transiciones de pantalla verificando cambios en SCX (0xFF43) y SCY (0xFF42) cada 1000 instrucciones. Reporta hasta 20 transiciones para evitar saturaci√≥n.
- **[TIMELINE-VRAM]**: Crea un timeline de accesos a VRAM con marcas de tiempo relativas. Se integra con [VRAM-ACCESS-GLOBAL] para a√±adir informaci√≥n temporal. Calcula tiempo aproximado en segundos desde el inicio basado en instruction_counter. Reporta hasta 200 muestras.
- **[VRAM-INIT-DUMP]**: Funci√≥n que crea un dump detallado del estado inicial de VRAM despu√©s de cargar la ROM. Muestra los primeros 128 bytes de Tile Data (8 tiles) y los primeros 64 bytes del Tile Map en formato hexadecimal. Se ejecuta autom√°ticamente al cargar la ROM.

**Cambios realizados**:
- **CPU.cpp**:
  - A√±adido monitor [STATE-CHANGE] en `CPU::step()` para detectar saltos grandes y cambios en HL.
  - A√±adido monitor [SCREEN-TRANSITION] en `CPU::step()` para detectar cambios en scroll.
  - A√±adido monitor [TIMELINE-VRAM] integrado con [VRAM-ACCESS-GLOBAL] para timeline de accesos.
- **MMU.cpp**:
  - A√±adida funci√≥n `dump_vram_initial_state()` que crea dump detallado de VRAM inicial.
  - Llamada autom√°tica desde `MMU::load_rom()` despu√©s de cargar la ROM.
- **MMU.hpp**:
  - A√±adida declaraci√≥n de `dump_vram_initial_state()`.

**Hip√≥tesis a investigar**:
1. **Hip√≥tesis A**: El juego carga tiles M√ÅS TARDE (despu√©s de 12 segundos) - Pendiente de verificaci√≥n con an√°lisis extendido.
2. **Hip√≥tesis B**: El juego carga tiles en OTRA FASE (cambio de pantalla, men√∫, etc.) - Los monitores [STATE-CHANGE] y [SCREEN-TRANSITION] ayudar√°n a verificar.
3. **Hip√≥tesis C**: El juego deber√≠a tener tiles pre-cargados desde el inicio (Boot ROM o inicializaci√≥n especial) - El dump inicial de VRAM ayudar√° a verificar.
4. **Hip√≥tesis D**: Hay un bug en la emulaci√≥n que impide que el juego llegue a la fase de carga - Pendiente de verificaci√≥n con an√°lisis extendido.

**Pr√≥ximos pasos**:
1. Ejecutar an√°lisis extendido (30-60 segundos) con Pok√©mon Red.
2. Analizar logs para identificar accesos con datos despu√©s de 12 segundos.
3. Verificar si se detectan cambios de estado que indiquen transiciones.
4. Verificar si hay datos pre-cargados en VRAM (dump inicial).
5. Analizar timeline de accesos VRAM para identificar patrones temporales.
6. Determinar si el juego carga tiles m√°s tarde o si necesita intervenci√≥n del emulador.

**Comando de ejecuci√≥n sugerido**:
```powershell
python main.py roms/pkmn.gb > debug_step_0297_extended.log 2>&1
```

**Comandos de an√°lisis sugeridos** (PowerShell):
```powershell
# Buscar accesos con datos despu√©s de 12 segundos
Select-String -Path "debug_step_0297_extended.log" -Pattern "\[TIMELINE-VRAM\].*T\+~1[2-9]|T\+~[2-9][0-9]|T\+~[0-9][0-9][0-9].*DATA" | Select-Object -First 50

# Buscar cambios de estado
Select-String -Path "debug_step_0297_extended.log" -Pattern "\[STATE-CHANGE\]" | Select-Object -First 50

# Buscar transiciones de pantalla
Select-String -Path "debug_step_0297_extended.log" -Pattern "\[SCREEN-TRANSITION\]" | Select-Object -First 20

# Ver dump inicial de VRAM
Select-String -Path "debug_step_0297_extended.log" -Pattern "\[VRAM-INIT-DUMP\]" | Select-Object -First 100
```

---

### 2025-12-25 - Step 0295: Monitor Global de Accesos VRAM y B√∫squeda de Rutinas de Carga
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de cinco monitores globales para rastrear TODOS los accesos a VRAM sin importar d√≥nde ocurran en el flujo de ejecuci√≥n. El an√°lisis del Step 0294 rechaz√≥ parcialmente la hip√≥tesis: las ISRs se ejecutan pero no acceden a VRAM, y el c√≥digo post-BG tampoco accede. Necesitamos determinar si el c√≥digo de carga existe y cu√°ndo deber√≠a ejecutarse, o si simplemente no existe en esta fase del juego.

**Monitores implementados**:
- **[VRAM-ACCESS-GLOBAL]**: Detecta TODOS los accesos de escritura a VRAM (0x8000-0x9FFF) independientemente de d√≥nde ocurran. Verifica si HL apunta a VRAM cuando se ejecutan opcodes de escritura (LD (HL+), A, LD (HL-), A, LD (HL), A, LD (HL), n, LD (HL), r). Reporta PC, opcode, direcci√≥n VRAM, valor escrito, si es Tile Data o Tile Map, Tile ID aproximado, si es dato real o limpieza, y banco ROM. L√≠mite: 1000 accesos.
- **[PC-VRAM-CORRELATION]**: Usa un `std::map<uint16_t, int>` para rastrear qu√© PCs acceden a VRAM y cu√°ntas veces. Imprime inmediatamente cuando detecta un PC nuevo o cuando es dato (no limpieza). Permite identificar rutinas espec√≠ficas que cargan tiles.
- **[LOAD-SEQUENCE]**: Detecta secuencias consecutivas de escrituras a VRAM que podr√≠an ser carga de tiles. Rastrea direcciones consecutivas (incremento o decremento) y reporta cuando se completa una secuencia de 16 bytes (un tile completo).
- **[ROM-TO-VRAM]**: Detecta cuando se ejecuta LDIR (0xED 0xB0) con DE apuntando a VRAM. Esto indica una copia bloque desde ROM (HL) a VRAM (DE) de longitud BC. Reporta PC, direcciones origen y destino, longitud y banco ROM.
- **[TIMING-VRAM]**: Rastrea el timing de accesos a VRAM usando un contador de instrucciones aproximado. Calcula el frame aproximado basado en instrucciones (asumiendo ~4 ciclos por instrucci√≥n promedio). Reporta PC, frame aproximado, LY, estado del LCD, estado de BG Display, direcci√≥n VRAM y valor escrito.

**Cambios realizados**:
- **CPU.cpp**:
  - A√±adido `#include <map>` para el monitor de correlaci√≥n PC-VRAM.
  - Implementados cinco monitores globales en `CPU::step()` despu√©s de capturar `original_pc`, antes de cualquier early return.
  - Los monitores usan variables `static` para mantener estado entre llamadas.

**Hip√≥tesis a investigar**:
1. **Hip√≥tesis A**: El c√≥digo de carga existe pero se ejecuta ANTES de habilitar BG Display.
2. **Hip√≥tesis B**: El c√≥digo de carga existe pero se ejecuta MUCHO DESPU√âS de habilitar BG Display (m√°s de 300 instrucciones).
3. **Hip√≥tesis C**: El c√≥digo de carga existe pero usa m√©todos no detectados (ej: DMA no est√°ndar, acceso indirecto).
4. **Hip√≥tesis D**: El c√≥digo de carga NO existe en esta fase del juego - el juego carga tiles m√°s tarde o en otra pantalla.

**Pr√≥ximos pasos**: Ejecutar el emulador con los nuevos monitores activos y analizar los logs generados para determinar si hay accesos a VRAM en alg√∫n momento del flujo, identificar rutinas espec√≠ficas que acceden a VRAM, detectar secuencias de carga, determinar el timing de accesos a VRAM, y concluir si el c√≥digo de carga existe o no en esta fase del juego.

**Resultados del an√°lisis de verificaci√≥n**:
- **Ejecuci√≥n**: 12 segundos de ejecuci√≥n con Pok√©mon Red, log generado (23.6 MB)
- **[VRAM-ACCESS-GLOBAL]**: 1001 accesos detectados, todos son CLEAR (0x00), todos desde PC 0x36E3
- **[PC-VRAM-CORRELATION]**: Solo 1 PC accede a VRAM (0x36E3 - rutina de limpieza)
- **[LOAD-SEQUENCE]**: 1 secuencia detectada, pero es de limpieza (0x00), no de carga real
- **[ROM-TO-VRAM]**: 0 copias desde ROM detectadas
- **[TIMING-VRAM]**: 1000 accesos, todos con LCD:ON pero BG:OFF, ninguno con BG:ON

**Conclusi√≥n definitiva**: ‚ùå **El c√≥digo de carga de tiles NO existe en esta fase del juego** (primeros 12 segundos de ejecuci√≥n). Todos los accesos a VRAM son de limpieza (0x00) desde la rutina 0x36E3, y ocurren durante la inicializaci√≥n cuando BG Display est√° OFF. No se detectaron accesos con datos reales, secuencias de carga de tiles, ni copias desde ROM.

**Evaluaci√≥n de hip√≥tesis**:
- **Hip√≥tesis A** (carga antes de BG): ‚ùå RECHAZADA - No hay accesos con datos reales
- **Hip√≥tesis B** (carga mucho despu√©s): ‚ö†Ô∏è PARCIALMENTE POSIBLE - El an√°lisis cubri√≥ solo 12 segundos
- **Hip√≥tesis C** (m√©todos no detectados): ‚ùå RECHAZADA - Todos los m√©todos est√°ndar fueron monitoreados
- **Hip√≥tesis D** (no existe en esta fase): ‚úÖ CONFIRMADA - No hay c√≥digo de carga en esta fase

**Recomendaciones**:
1. Ejecutar el emulador por m√°s tiempo (30-60 segundos) para verificar si el c√≥digo de carga se ejecuta m√°s tarde
2. Buscar en otras fases del juego (cambios de pantalla, men√∫s, batallas)
3. Investigar el desensamblado del juego para identificar rutinas de carga
4. Verificar si los tiles ya est√°n cargados en VRAM desde el inicio

**Documento de an√°lisis**: `ANALISIS_STEP_0295_VERIFICACION.md`

---

### 2025-12-25 - Step 0294: Rastreo de Activaci√≥n de BG Display e Interrupciones
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de monitores adicionales para rastrear cu√°ndo y c√≥mo se habilita el BG Display (LCDC bit 0) y las interrupciones (IE e IME). El an√°lisis del Step 0293 identific√≥ que el c√≥digo de carga de tiles podr√≠a estar en una ISR que no se ejecuta debido a interrupciones deshabilitadas (IE=0, IME=0) y que BG Display est√° deshabilitado (LCDC bit 0 = 0). Necesitamos entender el flujo completo de inicializaci√≥n para identificar cu√°ndo deber√≠an habilitarse estas funciones.

**Monitores implementados**:
- **[LCDC-TRACE]**: Reemplaza [LCDC-CHANGE] con informaci√≥n m√°s detallada. Rastrea cambios en LCDC con desglose de bits (LCD ON/OFF, BG Display ON/OFF, Window Display ON/OFF). Alerta especial cuando BG Display se habilita.
- **[EI-TRACE]**: Mejora [CPU-EI] con informaci√≥n m√°s detallada. Rastrea ejecuci√≥n de EI con desglose de interrupciones habilitadas y advertencia si IE=0x00.
- **[IME-ACTIVATE]**: Rastrea cu√°ndo IME se activa realmente despu√©s del delay de 1 instrucci√≥n de EI. Captura PC, IE e IF en el momento de activaci√≥n.
- **[IE-WRITE-TRACE]**: Mejora [IE-WRITE] con desglose detallado de bits. Rastrea cambios en IE con informaci√≥n sobre qu√© interrupciones se habilitan (V-Blank, LCD-STAT, Timer, Serial, Joypad). Alerta especial si V-Blank se habilita.
- **[ISR-VRAM-CHECK]**: Verifica si las ISRs acceden a VRAM cuando se ejecutan. Detecta entrada a ISR (vectores 0x0040, 0x0048, 0x0050, 0x0058, 0x0060), accesos a VRAM durante ISR y salida de ISR (RETI).
- **[BG-ENABLE-SEQUENCE]**: Rastrea la secuencia completa de ejecuci√≥n despu√©s de habilitar BG Display (300 instrucciones). Captura PC, opcode, HL y A, y detecta si HL apunta a VRAM.

**Cambios realizados**:
- **MMU.cpp**:
  - Reemplazado [LCDC-CHANGE] con [LCDC-TRACE] en `MMU::write()` cuando `addr == 0xFF40`.
  - Mejorado [IE-WRITE] a [IE-WRITE-TRACE] en `MMU::write()` cuando `addr == 0xFFFF`.
- **CPU.cpp**:
  - Mejorado [CPU-EI] a [EI-TRACE] en `CPU::step()`, case `0xFB`.
  - A√±adido [IME-ACTIVATE] en `CPU::step()` despu√©s de activar IME programado.
  - A√±adido [ISR-VRAM-CHECK] en `CPU::step()` para detectar entrada a ISR y accesos VRAM.
  - A√±adido [BG-ENABLE-SEQUENCE] en `CPU::step()` para rastrear secuencia despu√©s de habilitar BG Display.

**Hip√≥tesis refinada**:
El juego carga tiles en una ISR (probablemente V-Blank) que solo se ejecuta cuando:
1. BG Display est√° habilitado (LCDC bit 0 = 1)
2. Las interrupciones est√°n habilitadas (IE != 0, IME = 1)
3. La interrupci√≥n correspondiente es solicitada (IF bit activo)

Si alguna de estas condiciones no se cumple, el c√≥digo de carga nunca se ejecuta y la pantalla queda vac√≠a.

**Pr√≥ximos pasos**: Ejecutar el emulador con los nuevos monitores activos y analizar los logs generados para identificar cu√°ndo se habilita BG Display e interrupciones, verificar si el c√≥digo de carga est√° en una ISR, y confirmar la secuencia completa de inicializaci√≥n.

---

### 2025-12-25 - Step 0293: Investigaci√≥n de Flujo de Ejecuci√≥n Post-Limpieza
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de cinco monitores de diagn√≥stico para investigar por qu√© el juego nunca carga datos de tiles en VRAM despu√©s de limpiarla. El an√°lisis del Step 0291 confirm√≥ que solo se detectan escrituras de limpieza (0x00) desde PC:0x36E3 y ninguna carga de datos reales. Los nuevos monitores rastrean el flujo de ejecuci√≥n despu√©s de la limpieza para identificar qu√© c√≥digo se ejecuta (o deber√≠a ejecutarse pero no se ejecuta) y si hay condiciones que impiden la carga de tiles.

**Monitores implementados**:
- **[PC-TRACE]**: Rastrea las siguientes 500 instrucciones despu√©s de la limpieza, capturando PC, opcodes, registros y banco ROM. Detecta posibles cargas de tiles (LD (HL+), A o LD (HL-), A con HL en rango VRAM).
- **[REG-TRACE]**: Rastrea cambios significativos en registros (AF, BC, DE, HL, SP) y flags despu√©s de la limpieza. Solo reporta cambios mayores a 0x100 para evitar saturaci√≥n.
- **[JUMP-TRACE]**: Rastrea saltos, llamadas y retornos despu√©s de la limpieza para ver si el juego salta a c√≥digo que deber√≠a cargar tiles pero no lo hace. Detecta JP, JR, CALL, RET y JP HL.
- **[BANK-CHANGE]**: Detecta cambios de banco ROM despu√©s de la limpieza para verificar si el c√≥digo que carga tiles est√° en otro banco que no se activa.
- **[HARDWARE-STATE]**: Rastrea el estado de registros de hardware cr√≠ticos (LCDC, BGP, IE, IF, IME, LY) despu√©s de la limpieza. Muestrea cada 10 instrucciones aproximadamente.

**Cambios realizados**:
- **CPU.hpp/CPU.cpp**:
  - A√±adidos nuevos miembros de clase para mantener el estado de los monitores (siguiendo el patr√≥n del Step 0287).
  - Implementados monitores [PC-TRACE], [REG-TRACE], [JUMP-TRACE] y [HARDWARE-STATE] en `CPU::step()`.
  - Los monitores se activan cuando se detecta la rutina de limpieza (PC:0x36E0-0x36F0) y rastrean el flujo despu√©s.
- **MMU.cpp**:
  - Mejorado el monitor [BANK-CHANGE] en `MMU::update_bank_mapping()` para activarse solo despu√©s de la limpieza (PC > 0x36F0).

**Hip√≥tesis a investigar**:
1. **Hip√≥tesis A**: El c√≥digo que carga tiles existe pero no se ejecuta debido a condiciones no cumplidas (timing, interrupciones, registros de hardware).
2. **Hip√≥tesis B**: El c√≥digo que carga tiles existe pero est√° en un banco ROM diferente que no se activa.
3. **Hip√≥tesis C**: El juego espera un estado de hardware espec√≠fico antes de cargar tiles (ej: cierto n√∫mero de frames, V-Blanks, etc.).
4. **Hip√≥tesis D**: Hay un bug en la emulaci√≥n que impide que el c√≥digo de carga se ejecute (ej: saltos incorrectos, condiciones falsas, etc.).

**Pr√≥ximos pasos**: Ejecutar el emulador con los nuevos monitores activos y analizar los logs generados para determinar cu√°l de las hip√≥tesis es correcta y aplicar las correcciones correspondientes.

---

### 2025-12-25 - Step 0292: Verificaci√≥n Step 0291 - An√°lisis de Monitores
**Estado**: ‚úÖ COMPLETADO

Ejecuci√≥n del plan de verificaci√≥n del Step 0291 para analizar los monitores de diagn√≥stico implementados. Se ejecut√≥ el emulador con Pok√©mon Red durante 15 segundos y se capturaron los logs de los cinco monitores: [VRAM-INIT], [TILE-LOAD-EXTENDED], [CLEANUP-TRACE], [BLOCK-WRITE], y el contador de frames en PPU. El an√°lisis revela que **el juego nunca carga datos de tiles reales en VRAM**, solo se detectan escrituras de limpieza (0x00) desde la rutina en PC:0x36E3. Ninguna de las hip√≥tesis iniciales es correcta, lo que indica que el problema es m√°s fundamental.

**Resultados del an√°lisis**:
- **[VRAM-INIT]**: VRAM est√° completamente vac√≠a al inicio (0 bytes no-cero, checksum 0x0000) - ‚úÖ Correcto
- **[TILE-LOAD-EXTENDED]**: 1000 escrituras capturadas, pero **0 escrituras de datos** (100% CLEAR) - ‚ùå Cr√≠tico
- **[CLEANUP-TRACE]**: Rutina de limpieza en PC:0x36E3 funciona correctamente (loop que escribe 0x00) - ‚úÖ Correcto
- **[BLOCK-WRITE]**: Solo 1 detecci√≥n (parte de la limpieza) - ‚ùå No hay cargas en bloque de datos

**Evaluaci√≥n de hip√≥tesis**:
- ‚ùå Hip√≥tesis 1 (Timing): Rechazada - No hay escrituras de datos durante Init:YES ni despu√©s
- ‚ùå Hip√≥tesis 2 (Borrado): Rechazada - Los tiles nunca se cargan, por lo tanto no pueden borrarse
- ‚ùå Hip√≥tesis 3 (M√©todos Alternativos): Rechazada - No hay cargas en bloque de datos reales
- ‚ùå Hip√≥tesis 4 (Estado Inicial): Rechazada - VRAM est√° correctamente vac√≠a, el problema es que no se cargan tiles despu√©s

**Nueva hip√≥tesis**: El problema es m√°s fundamental. Posibles causas:
1. El juego no llega a la rutina de carga de tiles (posible bug en emulaci√≥n)
2. El juego usa un m√©todo de carga que no estamos detectando (DMA, carga desde ROM, etc.)
3. Problema de sincronizaci√≥n o timing (el juego espera condiciones espec√≠ficas)
4. El juego espera que los tiles est√©n en la ROM y se rendericen directamente

**Archivos creados**:
- `test_step_0291_verification.py`: Script de verificaci√≥n que ejecuta el emulador con timeout
- `debug_step_0291.log`: Log completo de ejecuci√≥n (~100MB)
- `ANALISIS_STEP_0291_VERIFICACION.md`: Documento de an√°lisis completo

**Recomendaciones**:
1. Implementar monitor [PC-TRACE] para rastrear ejecuci√≥n despu√©s de limpieza
2. Verificar otros puntos de entrada a VRAM
3. Analizar desensamblado del juego para entender c√≥mo carga tiles
4. Implementar monitor [REG-TRACE] para rastrear cambios en registros cr√≠ticos
5. Verificar comportamiento con emulador de referencia (solo para verificaci√≥n)

---

### 2025-12-25 - Step 0291: Investigaci√≥n de Carga de Tiles y Correcci√≥n
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de un conjunto completo de monitores de diagn√≥stico para investigar por qu√© los tiles no se est√°n cargando en VRAM. El an√°lisis del Step 0290 confirm√≥ que [TILE-LOAD] detecta 0 cargas de tiles, lo que significa que el juego no est√° escribiendo datos de tiles en VRAM. Se implementaron cinco monitores nuevos: [VRAM-INIT] para verificar el estado inicial de VRAM, [TILE-LOAD-EXTENDED] para capturar TODAS las escrituras con contexto de timing, [CLEANUP-TRACE] para rastrear la rutina de limpieza VRAM (PC:0x36E3), [BLOCK-WRITE] para detectar cargas de tiles consecutivas, y un contador de frames en PPU para rastrear el timing de las operaciones.

**Cambios realizados**:
- **PPU.hpp/PPU.cpp**:
  - A√±adido contador de frames global (`frame_counter_`) que se incrementa cada vez que LY vuelve a 0 (nuevo frame).
  - Implementado m√©todo p√∫blico `get_frame_counter()` para obtener el frame actual.
  - El contador es necesario para rastrear el timing de carga de tiles y determinar si los tiles se cargan antes del frame 0 o durante la inicializaci√≥n.
- **MMU.hpp/MMU.cpp**:
  - Implementada funci√≥n `inspect_vram_initial_state()` que se llama desde `MMU::load_rom()` despu√©s de cargar la ROM.
  - La funci√≥n verifica el estado inicial de VRAM (0x8000-0x97FF) y reporta cu√°ntos bytes no-cero hay, la primera direcci√≥n con datos no-cero, y el checksum del tilemap inicial (0x9800).
  - Extendido el monitor [TILE-LOAD] a [TILE-LOAD-EXTENDED] que captura TODAS las escrituras en Tile Data (0x8000-0x97FF), incluyendo limpieza (0x00) pero marc√°ndolas diferente.
  - El monitor ahora rastrea el frame actual usando el contador de frames de PPU y marca si la escritura ocurre durante la inicializaci√≥n (primeras 100 escrituras) o despu√©s.
  - Implementado monitor [CLEANUP-TRACE] que rastrea la ejecuci√≥n alrededor de PC:0x36E3 para entender qu√© hace esta rutina y si hay c√≥digo despu√©s que carga tiles.
  - Implementado monitor [BLOCK-WRITE] que detecta escrituras consecutivas en VRAM que podr√≠an ser carga de tiles en bloque (como un loop de copia).

**Hip√≥tesis a investigar**:
1. **Hip√≥tesis 1: Timing** - ¬øLos tiles se cargan antes del frame 0 (durante inicializaci√≥n antes de que los monitores se activen)?
2. **Hip√≥tesis 2: Borrado** - ¬øLos tiles se cargan pero luego se borran inmediatamente despu√©s?
3. **Hip√≥tesis 3: M√©todos alternativos** - ¬øEl juego usa DMA o compresi√≥n para cargar tiles que no detectamos?
4. **Hip√≥tesis 4: Estado inicial** - ¬øDeber√≠a VRAM tener datos desde el inicio (desde el constructor)?

**Pr√≥ximos pasos**: Ejecutar el emulador con los nuevos monitores activos y analizar los logs generados para determinar cu√°l de las hip√≥tesis es correcta (o si es una combinaci√≥n de ellas), y luego aplicar las correcciones correspondientes.

---

### 2025-12-25 - Step 0290: Verificaci√≥n de LCDC, Paleta y Carga de Tiles
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de tres monitores adicionales para verificar la configuraci√≥n de LCDC, la aplicaci√≥n de la paleta BGP durante el renderizado, y cr√≠ticamente, detectar cu√°ndo y d√≥nde el juego carga datos de tiles en VRAM. Los hallazgos del Step 0289 confirmaron que el problema est√° en que los tiles referenciados por el tilemap est√°n vac√≠os (solo ceros), por lo que necesitamos rastrear si el juego est√° cargando tiles en VRAM y cu√°ndo lo hace. Se implementaron los monitores [LCDC-CHANGE], [PALETTE-APPLY] y [TILE-LOAD].

**Cambios realizados**:
- **MMU.cpp**:
  - Implementado el monitor [LCDC-CHANGE] en `MMU::write()` que captura todos los cambios en el registro LCDC (0xFF40).
  - El monitor reporta el valor anterior, el valor nuevo, el PC que origin√≥ el cambio, el banco ROM actual, y el estado de bits cr√≠ticos (LCD Enable, BG Display Enable, Window Display Enable).
  - Implementado el monitor [TILE-LOAD] en `MMU::write()` que detecta escrituras en el √°rea de Tile Data (0x8000-0x97FF) que probablemente sean carga de datos de tiles (distintos de 0x00, que es limpieza).
  - El monitor reporta la direcci√≥n escrita, el valor escrito, el Tile ID aproximado (calculado dividiendo el offset por 16), el byte dentro del tile (0-15), el PC que origin√≥ la escritura, y el banco ROM actual.
  - Tiene un l√≠mite de 500 escrituras para capturar actividad completa.
- **PPU.cpp**:
  - Implementado el monitor [PALETTE-APPLY] en `PPU::render_scanline()` que captura c√≥mo se aplica la paleta BGP durante el renderizado.
  - El monitor se ejecuta solo en el centro de la pantalla (LY=72, X=80) y en los primeros 3 frames para no saturar los logs.
  - Reporta el √≠ndice de color crudo del tile, el √≠ndice final despu√©s de aplicar BGP, y el valor de BGP usado.

**Objetivos**:
- Verificar la configuraci√≥n del LCD y detectar cambios sospechosos en LCDC.
- Verificar que la paleta BGP se est√° aplicando correctamente durante el renderizado.
- Detectar cu√°ndo y d√≥nde el juego carga datos de tiles en VRAM. Este es el monitor m√°s importante porque necesitamos saber si el juego est√° cargando tiles y cu√°ndo lo hace.

**Concepto de Hardware**:
- LCDC (LCD Control Register - 0xFF40) controla el estado del LCD y las caracter√≠sticas de renderizado. Si el LCD est√° apagado (bit 7 = 0), no se renderiza nada. Si el BG Display est√° apagado (bit 0 = 0), no se renderiza el fondo. El bit 4 afecta c√≥mo se calculan las direcciones de tiles.
- BGP (Background Palette - 0xFF47) mapea √≠ndices de color (0-3) a otros √≠ndices (0-3). Si BGP = 0x00, todos los colores se mapean a √≠ndice 0 (blanco/verde), causando una pantalla monocrom√°tica.
- Los tiles se cargan en el √°rea Tile Data (0x8000-0x97FF). Si los tiles no se cargan, el tilemap referenciar√° tiles vac√≠os (solo ceros), resultando en una pantalla en blanco o con un solo color.

**Fuentes Consultadas**:
- Pan Docs: "LCD Control Register (LCDC)", "Background Palette (BGP)", "Tile Data", "Video RAM (VRAM)"

---

### 2025-12-25 - Step 0289: Diagn√≥stico de VRAM y Tilemap
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de tres monitores de diagn√≥stico adicionales para verificar qu√© lee la PPU de VRAM y qu√© contiene el tilemap. El Step 0288 identific√≥ que VRAM est√° vac√≠a (solo ceros), por lo que estos monitores permitir√°n confirmar si el problema est√° en la lectura de la PPU o en la carga de datos. Se implementaron los monitores [VRAM-READ], [TILEMAP-INSPECT] y [TILEDATA-INSPECT].

**Cambios realizados**:
- **MMU.cpp**:
  - Implementado el monitor [VRAM-READ] en `MMU::read()` que captura todas las lecturas de VRAM (0x8000-0x9FFF).
  - El monitor reporta la direcci√≥n le√≠da, el valor obtenido, el PC que origin√≥ la lectura y el banco ROM actual.
  - Tiene un l√≠mite de 100 lecturas para evitar saturaci√≥n de logs.
- **PPU.cpp**:
  - Mejorado el inspector de Tile Map ([TILEMAP-INSPECT]) para ejecutarse al inicio de cada frame (LY=0) en lugar de solo una vez.
  - El inspector imprime los primeros 32 bytes del tilemap (primera fila completa), calcula un checksum del tilemap completo (1024 bytes) y reporta la configuraci√≥n de LCDC.
  - Solo se ejecuta en los primeros 5 frames para no saturar los logs.
  - Implementado el inspector [TILEDATA-INSPECT] en el bucle de renderizado que verifica si los tiles contienen datos v√°lidos cuando se leen.
  - El inspector se ejecuta solo en el centro de la pantalla (LY=72, X=80) y en los primeros 3 frames, emitiendo un warning si detecta tiles vac√≠os.

**Objetivos**:
- Verificar qu√© direcciones lee la PPU de VRAM y qu√© valores obtiene.
- Verificar qu√© Tile IDs contiene el tilemap.
- Verificar si los tiles referenciados por el tilemap contienen datos v√°lidos.

**Concepto de Hardware**:
- Durante el renderizado de cada scanline, la PPU lee datos de VRAM para construir la imagen: primero lee el Tile Map para obtener el Tile ID, luego lee el Tile Data usando el Tile ID para obtener los bytes de p√≠xeles.
- El Tile Map es una tabla de 32x32 tiles que especifica qu√© tile debe renderizarse en cada posici√≥n. Si todos los Tile IDs son 0x00, el tilemap est√° vac√≠o.
- Cada tile ocupa 16 bytes (2 bytes por l√≠nea, 8 l√≠neas). Si ambos bytes de una l√≠nea son 0x00, todos los p√≠xeles de esa l√≠nea son color 0 (blanco/verde).

**Fuentes Consultadas**:
- Pan Docs: "Video RAM (VRAM)", "Tile Data", "Tile Map", "LCD Control Register (LCDC)"

---

### 2025-12-25 - Step 0288: An√°lisis Selectivo de Logs
**Estado**: ‚úÖ COMPLETADO

An√°lisis selectivo de los logs de diagn√≥stico del emulador para identificar la causa ra√≠z del problema de pantalla verde/blanca en Pok√©mon Red. Se analizaron los monitores activos ([VRAM-VIBE], [VRAM-TOTAL], [DMA-TRIGGER], [BGP-CHANGE], [HANDLER-EXEC], [VBLANK-TRACE]) y se identificaron dos problemas cr√≠ticos: VRAM est√° siendo escrita solo con ceros (0x00) y BGP se pone temporalmente a 0x00 durante la ejecuci√≥n.

**Hallazgos principales**:
- **VRAM-VIBE**: 0 matches (cr√≠tico: no hay escrituras de datos de gr√°ficos reales)
- **VRAM-TOTAL**: 500 escrituras detectadas, todas con valor 0x00 (VRAM est√° siendo limpiada pero no cargada con gr√°ficos)
- **DMA-TRIGGER**: 49 activaciones detectadas, funcionando correctamente
- **BGP-CHANGE**: 3 cambios detectados, uno problem√°tico (0xE4 -> 0x00 en PC:0x1F6A)
- **HANDLER-EXEC**: 49 ejecuciones detectadas, funcionando correctamente
- **VBLANK-TRACE**: 49 rastreos detectados, funcionando correctamente
- **LCDC**: Valor constante 0xE3, configuraci√≥n correcta

**Problema ra√≠z identificado**:
- VRAM est√° vac√≠a (solo ceros), lo que explica por qu√© la pantalla muestra verde/blanco
- BGP se pone temporalmente a 0x00, lo que agrava el problema

**Archivos creados**:
- `ANALISIS_LOGS_STEP_0288.md`: An√°lisis ejecutivo con hallazgos detallados

**Objetivos**:
- Identificar la causa ra√≠z del problema de pantalla verde/blanca
- Analizar los monitores de diagn√≥stico activos para encontrar patrones sospechosos
- Preparar el terreno para los siguientes pasos (Step 0289-0291) que implementar√°n monitores adicionales y correcciones

**Concepto de Hardware**:
- VRAM (0x8000-0x9FFF, 8KB) contiene Tile Data (0x8000-0x97FF) y Tile Maps (0x9800-0x9FFF). Si VRAM est√° vac√≠a, el PPU leer√° tiles vac√≠os y renderizar√° una pantalla en blanco o con un solo color.
- BGP (0xFF47) mapea √≠ndices de color (0-3) a otros √≠ndices. Si BGP = 0x00, todos los colores se mapean a √≠ndice 0 (blanco/verde), causando una pantalla monocrom√°tica.

**Pr√≥ximos pasos**:
- Step 0289: Implementar monitores adicionales ([VRAM-READ], [TILEMAP-INSPECT], [TILEDATA-INSPECT])
- Step 0290: Implementar monitores de LCDC y paleta ([LCDC-CHANGE], [PALETTE-APPLY])
- Step 0291: Aplicar correcciones basadas en los hallazgos

---

### 2025-12-25 - Step 0287: Estabilizaci√≥n del Motor y Auditor√≠a de HRAM
**Estado**: ‚úÖ COMPLETADO

Refactorizaci√≥n cr√≠tica del n√∫cleo de emulaci√≥n para eliminar variables est√°ticas que causaban interferencias entre tests de pytest, correcci√≥n del bug de timing en run_scanline() que truncaba el valor -1 (HALT), optimizaci√≥n del log del handler de V-Blank para filtrar bucles de retardo en HRAM, e implementaci√≥n de monitor de escrituras en HRAM para entender las rutinas shadow que los juegos copian ah√≠.

**Cambios realizados**:
- **CPU.hpp**:
  - A√±adidos miembros privados para estado de diagn√≥stico (in_vblank_handler_, vblank_handler_steps_, post_delay_trace_active_, post_delay_count_) que reemplazan variables static.
  - Esto asegura que cada instancia de CPU tenga su propio estado aislado, eliminando interferencias entre tests.
- **CPU.cpp**:
  - Refactorizaci√≥n de variables static a miembros de clase en step() y run_scanline().
  - Correcci√≥n del tipo de m_cycles de uint8_t a int en run_scanline() para manejar correctamente el valor -1 (HALT).
  - Optimizaci√≥n del log del handler de V-Blank para filtrar el bucle de retardo DEC A / JR NZ en HRAM (0xFF86-0xFF87).
  - Inicializaci√≥n de los nuevos miembros en el constructor.
- **MMU.cpp**:
  - Implementado el monitor [HRAM-WRITE] que detecta todas las escrituras en HRAM (0xFF80-0xFFFE).
  - El monitor ayuda a entender cu√°ndo y qu√© c√≥digo copian los juegos a HRAM para ejecutar rutinas shadow.

**Objetivos**:
- Eliminar interferencias entre tests causadas por variables static.
- Corregir el bug de timing que truncaba el valor -1 (HALT) en run_scanline().
- Reducir el ruido en los logs del handler de V-Blank filtrando bucles de retardo.
- Entender las rutinas shadow que los juegos copian a HRAM para ejecuci√≥n de alta velocidad.

**Concepto de Hardware**:
- HRAM (High RAM) es un √°rea de 127 bytes (0xFF80-0xFFFE) accesible en todos los ciclos de memoria, a diferencia de ROM o RAM normal que pueden estar bloqueadas durante DMA o acceso a VRAM.
- Los juegos copian rutinas cr√≠ticas (como handlers de interrupciones o bucles de retardo) a HRAM para ejecutarlas m√°s r√°pido. Estas rutinas "shadow" son copias de c√≥digo que se ejecutan desde HRAM.
- Cuando la CPU entra en estado HALT, step() devuelve -1 para indicar "avance r√°pido", pero uint8_t no puede representar -1, causando truncamiento a 255 que romp√≠a el c√°lculo de ciclos.
- Las variables static en C++ persisten entre llamadas, lo que significa que el estado de un test puede "contaminar" el siguiente. Al moverlas a miembros de clase, cada instancia tiene su propio estado aislado.

**Fuentes Consultadas**:
- Pan Docs: "HRAM (High RAM)", "CPU Instruction Set - HALT"

---

### 2025-12-25 - Step 0286: Auditor√≠a Extendida de Interrupciones y DMA
**Estado**: ‚úÖ COMPLETADO

Extensi√≥n de la instrumentaci√≥n de diagn√≥stico del emulador para capturar el flujo completo de ejecuci√≥n de handlers de interrupciones y monitorear operaciones cr√≠ticas de DMA y VRAM. Aumento del l√≠mite del Sniper del Handler a 500 instrucciones, detecci√≥n de RET (0xC9) adem√°s de RETI (0xD9), implementaci√≥n de monitor espec√≠fico para disparo de OAM DMA ([DMA-TRIGGER]) y monitor temporal sin filtros para VRAM ([VRAM-TOTAL]).

**Cambios realizados**:
- **CPU.cpp**:
  - Aumentado el l√≠mite del Sniper del Handler ([HANDLER-EXEC]) de 100 a 500 instrucciones para capturar el flujo completo hasta el retorno.
  - Implementada detecci√≥n de RET (0xC9) adem√°s de RETI (0xD9) para identificar handlers que terminan sin habilitar IME.
  - Esto permite detectar bugs potenciales donde los handlers no rehabilitan correctamente las interrupciones.
- **MMU.cpp**:
  - Implementado el monitor [DMA-TRIGGER] que detecta cuando se activa el DMA para transferir datos a OAM (0xFE00-0xFE9F).
  - El monitor reporta la direcci√≥n fuente, el rango de direcciones que se copiar√°n y el PC donde se activ√≥ el DMA.
  - Implementado el monitor [VRAM-TOTAL] que captura TODAS las escrituras en VRAM sin filtros para detectar cualquier actividad sospechosa.
  - El monitor tiene un l√≠mite de 500 reportes para evitar saturaci√≥n de logs.

**Objetivos**:
- Capturar el flujo completo de ejecuci√≥n de handlers de interrupciones hasta el retorno.
- Detectar handlers que terminan incorrectamente con RET en lugar de RETI.
- Monitorear operaciones de DMA para entender cu√°ndo y c√≥mo se cargan los sprites.
- Detectar cualquier actividad sospechosa en VRAM que pueda estar causando problemas de renderizado.

**Concepto de Hardware**:
- Los handlers de interrupciones deben terminar con RETI (0xD9) para restaurar el estado y rehabilitar interrupciones. RET (0xC9) no es suficiente porque no habilita IME.
- El registro DMA (0xFF46) permite transferir 160 bytes desde cualquier direcci√≥n de memoria a OAM en un solo ciclo. Es cr√≠tico para cargar sprites en el juego.
- La VRAM (0x8000-0x9FFF) contiene los datos de tiles y mapas de tiles que la PPU lee para renderizar. Monitorear todas las escrituras permite detectar problemas de carga de gr√°ficos.

**Fuentes Consultadas**:
- Pan Docs: Interrupts - Vectores de interrupci√≥n y comportamiento de RETI
- Pan Docs: DMA Transfer - Operaci√≥n del registro DMA (0xFF46)
- Pan Docs: VRAM (Video RAM) - Regi√≥n de memoria 0x8000-0x9FFF

---

### 2025-12-25 - Step 0285: Fix de Instrumentaci√≥n y Desbloqueo Visual
**Estado**: ‚úÖ COMPLETADO

Correcci√≥n cr√≠tica de la instrumentaci√≥n del emulador para asegurar que los monitores de diagn√≥stico se ejecuten correctamente, incluso cuando hay interrupciones que causan early returns. Movimiento del bloque de Sniper del Handler ([HANDLER-EXEC]) al inicio de CPU::step() y implementaci√≥n de un monitor liberal de escrituras en VRAM ([VRAM-VIBE]) para detectar cargas de gr√°ficos reales.

**Cambios realizados**:
- **CPU.cpp**:
  - Movido el bloque [HANDLER-EXEC] del final de step() (despu√©s del switch) al inicio del m√©todo, justo despu√©s de capturar original_pc y antes de handle_interrupts().
  - Eliminado el bloque duplicado del final del m√©todo.
  - Esto asegura que el monitor se ejecute incluso cuando hay interrupciones que causan early returns antes de llegar al switch.
- **MMU.cpp**:
  - Implementado el monitor [VRAM-VIBE] en MMU::write() que detecta escrituras en VRAM (0x8000-0x9FFF) filtrando valores comunes de inicializaci√≥n (0x00 y 0x7F).
  - El monitor reporta hasta 200 escrituras que probablemente contengan datos de gr√°ficos reales.
  - A√±adida verificaci√≥n expl√≠cita de que las escrituras en VRAM se realizan correctamente en la memoria para que el PPU pueda leerlas.

**Objetivos**:
- Asegurar que los monitores de diagn√≥stico capturen eventos cr√≠ticos incluso cuando hay interrupciones.
- Detectar cargas de gr√°ficos reales en VRAM filtrando valores comunes de inicializaci√≥n.
- Verificar que las escrituras en VRAM se reflejen correctamente en la memoria accesible por la PPU.

**Concepto de Hardware**:
- La VRAM (0x8000-0x9FFF) contiene Tile Data (0x8000-0x97FF) y Tile Maps (0x9800-0x9FFF).
- En el hardware real, la VRAM solo es accesible por la CPU durante ciertos modos de la PPU, pero muchos emuladores permiten escrituras en cualquier momento.
- Los valores 0x00 (blanco) y 0x7F son comunes en inicializaci√≥n y borrado de memoria, pero no representan datos de gr√°ficos reales.

**Fuentes Consultadas**:
- Pan Docs: VRAM (Video RAM) - Rango 0x8000-0x9FFF contiene Tile Data y Tile Maps
- Pan Docs: Interrupt Vectors - Vector 0x0040 es el handler de V-Blank

---

### 2025-12-25 - Step 0284: Implementaci√≥n de Ventana y Fix de Instrumentaci√≥n
**Estado**: ‚úÖ COMPLETADO

Movimiento de los monitores de diagn√≥stico al inicio de CPU::step() y implementaci√≥n completa de la l√≥gica de renderizado de la Ventana (Window) en PPU.

**Cambios realizados**:
- **CPU.cpp**:
  - Movidos los monitores VBLANK-ENTRY, RESET-WATCH y POLLING-WATCH al inicio de step(), antes de handle_interrupts(), para evitar que el early return de interrupciones los oculte.
  - El PC original ahora se captura una vez al inicio y se reutiliza en todo el m√©todo para garantizar consistencia.
- **PPU.cpp**:
  - Implementaci√≥n completa de render_window() con l√≥gica de renderizado p√≠xel por p√≠xel.
  - Verificaci√≥n de LCDC bit 5 (Window Enable) y bit 7 (LCD Enable).
  - Validaci√≥n de condiciones WY <= LY y WX <= 166.
  - Selecci√≥n de tilemap seg√∫n LCDC bit 6 (independiente del Background).
  - Uso del mismo sistema de direccionamiento de tiles que Background (LCDC bit 4).
  - Aplicaci√≥n de paleta BGP a los p√≠xeles de la Window.
  - Integraci√≥n de render_window() en render_scanline() despu√©s del Background pero antes de los Sprites.

**Objetivos**:
- Asegurar que los monitores de diagn√≥stico capturen eventos cr√≠ticos incluso cuando hay interrupciones.
- Implementar renderizado correcto de la Window respetando todas las condiciones hardware.
- Mantener consistencia en el direccionamiento de tiles entre Background y Window.

**Concepto de Hardware**:
- La Window es una capa opaca sin scroll que siempre comienza desde (0,0) del tilemap.
- WX tiene un offset de 7 p√≠xeles: WX=7 significa posici√≥n X=0 en pantalla.
- La Window se renderiza encima del Background pero debajo de los Sprites.
- Tanto Background como Window comparten el sistema de direccionamiento de tiles (LCDC bit 4) pero pueden usar tilemaps diferentes.

**Fuente**: Pan Docs - "Window", "LCDC Register", "Tile Data Addressing"

---

### 2025-12-25 - Step 0283: Optimizaci√≥n de Rendimiento y Hack de Paleta
**Estado**: ‚úÖ COMPLETADO

Optimizaci√≥n cr√≠tica de rendimiento comentando los logs de alta frecuencia que imped√≠an alcanzar los 60 FPS, y verificaci√≥n/mejora del hack de inicializaci√≥n de la paleta BGP.

**Cambios realizados**:
- **MMU.cpp**:
  - Comentados los logs `[BANK-READ]` y `[VRAM-SNIPER]` que generaban miles de l√≠neas por segundo y afectaban el rendimiento.
  - Verificado que el registro BGP (0xFF47) est√° inicializado con 0xFC en el constructor (ya estaba correcto).
  - Implementaci√≥n de monitor `[BGP-CHANGE]` para capturar todos los cambios en el registro de paleta de fondo durante la ejecuci√≥n.
- **Bit√°cora**: Creada entrada 0283 documentando las optimizaciones y el hack de paleta.

**Objetivos**:
- Eliminar el cuello de botella de I/O en el bucle cr√≠tico para alcanzar 60 FPS.
- Asegurar visibilidad inicial de los gr√°ficos mediante inicializaci√≥n correcta de BGP.
- Capturar cambios en la paleta para diagnosticar problemas de visualizaci√≥n.

**Bit√°cora**: `docs/bitacora/entries/2025-12-25__0283__optimizacion-rendimiento-hack-paleta.html`

---

### 2025-12-25 - Step 0282: Auditor√≠a de Bancos MBC1 y Carga de VRAM
**Estado**: ‚úÖ COMPLETADO

Implementaci√≥n de diagn√≥sticos avanzados para investigar la falta de carga de gr√°ficos en Pok√©mon Red.

**Cambios realizados**:
- **MMU.cpp**:
  - Implementaci√≥n de `[BANK-READ]` en el rango `0x4000-0x7FFF` para verificar el mapeo de ROM.
  - Implementaci√≥n de `[VRAM-SNIPER]` para capturar escrituras en VRAM con valores distintos de `0x00`.
  - Instrumentaci√≥n de `update_bank_mapping()` con `[BANK-AUDIT]` para rastrear cambios en el direccionamiento de bancos.
- **Bit√°cora**: Creada entrada 0282 detallando el funcionamiento del MBC1 y la carga de VRAM.

**Hallazgos esperados**:
- Confirmar si el MBC1 est√° mapeando los bancos correctos.
- Detectar si el juego intenta cargar azulejos reales tras la limpieza de VRAM.

**Bit√°cora**: `docs/bitacora/entries/2025-12-25__0282__auditoria-bancos-mbc1-carga-vram.html`

---

### 2025-12-25 - Step 0281: Operaci√≥n "Deep Handler Audit" - Auditor√≠a del Handler de V-Blank
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la **Operaci√≥n "Deep Handler Audit"** para investigar el flujo de ejecuci√≥n desde el vector de interrupci√≥n de V-Blank (0x0040). El an√°lisis anterior confirm√≥ que las interrupciones est√°n habilitadas pero el juego sigue atrapado en el bucle de polling.

**Objetivo:**
- Rastrear el destino del salto (`JP nn`) en el vector 0x0040.
- Capturar las instrucciones ejecutadas dentro del handler de V-Blank.
- Identificar si el handler intenta modificar el flag de progreso en `0xD732`.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Implementado un rastreador que identifica la direcci√≥n de destino del salto (JP) en el vector 0x0040.
   - A√±adido un Sniper de ejecuci√≥n para capturar las instrucciones dentro de la rutina de V-Blank hasta encontrar un `RETI` (0xD9).
   - El sniper captura: PC original, opcode, registros A y HL, y estado de IME.

**Resultados esperados:**
- Identificaci√≥n de la rutina real de V-Blank y su comportamiento.
- Confirmaci√≥n de si el juego intenta comunicarse con el bucle principal a trav√©s de `0xD732`.

**Bit√°cora**: `docs/bitacora/entries/2025-12-25__0281__auditoria-handler-vblank.html`

---

### 2025-12-25 - Step 0280: Operaci√≥n "Interrupt Awakening" - Depuraci√≥n de Activaci√≥n de Interrupciones
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la **Operaci√≥n "Interrupt Awakening"** para investigar por qu√© Pok√©mon Red est√° atrapado en un bucle infinito esperando que el flag `0xD732` cambie. El an√°lisis del Step 0279 confirm√≥ que el problema **NO es un Reset Loop**, sino un **"coma inducido"**: el juego est√° atascado en el bucle de polling (PC: 0x614D-0x6153) esperando que una ISR de V-Blank modifique el flag, pero las interrupciones est√°n deshabilitadas (`IE=0x00`). Aunque se detect√≥ un `EI` en `PC:0x60A6`, las interrupciones no parecen estar activas durante el polling.

**Objetivo:**
- Implementar rastreo ultra-preciso de `EI` e `IME` para capturar el estado exacto de `IE` e `IME` cuando se intenta habilitar las interrupciones.
- Implementar sniper de polling con estado de `IE` para monitorear el bucle de espera y detectar si alguien est√° escribiendo en `IE` durante la espera.
- Verificar que la l√≥gica de `handle_interrupts()` no modifica `IE` incorrectamente.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Modificado `case 0xFB` (EI) para agregar rastreo detallado de `IE` e `IME` cuando se ejecuta `EI`.
   - Captura: PC original, valor de IE actual, estado de IME previo, y estado de IME programado.
   - Agregado sniper de polling al final del m√©todo `step()` que monitorea el bucle de espera (PC: 0x614D-0x6153).
   - Captura: PC, IE, IF, IME, y valor del flag 0xD732 durante la espera.
   - L√≠mite de 20 logs para evitar saturar el log, pero suficiente para ver el patr√≥n del bucle.

2. **Verificaci√≥n de `handle_interrupts()`**:
   - Confirmado que `handle_interrupts()` no modifica `IE` (solo lo lee).
   - La funci√≥n solo lee `IE` para calcular interrupciones pendientes (`pending = IE & IF`), pero nunca escribe en `IE`.

**Concepto de Hardware:**
**El Retraso de un Ciclo de la Instrucci√≥n EI**: La instrucci√≥n `EI` (Enable Interrupts, opcode `0xFB`) tiene un comportamiento especial en el hardware real del Game Boy: el Interrupt Master Enable (IME) se activa **DESPU√âS de ejecutar la siguiente instrucci√≥n**, no inmediatamente. Este retraso de un ciclo es cr√≠tico porque permite que la instrucci√≥n siguiente a `EI` se ejecute sin interrupciones, lo cual es necesario para configuraciones at√≥micas o para evitar condiciones de carrera.

1. **Flujo de activaci√≥n de interrupciones**:
   - Ejecuci√≥n de `EI`: El opcode `0xFB` se ejecuta, pero `IME` no se activa inmediatamente. En su lugar, se marca una bandera interna (`ime_scheduled_`) que indica que `IME` debe activarse despu√©s de la siguiente instrucci√≥n.
   - Ejecuci√≥n de la siguiente instrucci√≥n: La instrucci√≥n que sigue a `EI` se ejecuta con `IME=false`, garantizando que no se interrumpa.
   - Activaci√≥n de `IME`: Al inicio del siguiente ciclo de instrucci√≥n, antes del fetch, se verifica si `ime_scheduled_` es `true`. Si lo es, se activa `IME` y se limpia la bandera.
   - Procesamiento de interrupciones: Una vez que `IME` est√° activo, el sistema puede procesar interrupciones pendientes si `IE & IF != 0`.

2. **Registros de Interrupciones**:
   - **IE (0xFFFF) - Interrupt Enable**: Registro de habilitaci√≥n de fuentes de interrupciones. Cada bit habilita una fuente espec√≠fica (V-Blank, LCD STAT, Timer, Serial, Joypad).
   - **IF (0xFF0F) - Interrupt Flag**: Registro de flags de interrupciones pendientes. Cada bit indica si una interrupci√≥n est√° pendiente.
   - **IME (Interrupt Master Enable)**: Flag interno de la CPU que controla si las interrupciones pueden ser procesadas. Solo se puede activar mediante `EI` (con retraso) o desactivar mediante `DI` (inmediato).

**Condici√≥n para procesar una interrupci√≥n**: `IME == true && (IE & IF) != 0`

**Fuente**: Pan Docs - "EI Instruction": "Interrupts are enabled after the instruction following EI."

**Pr√≥ximos Pasos:**
- Ejecutar el emulador con la nueva instrumentaci√≥n y analizar los logs `[CPU-EI]` y `[POLLING-WATCH]`.
- Verificar si `IE` est√° en `0x00` cuando se ejecuta `EI` en `PC:0x60A6`.
- Verificar si `IE` cambia durante el bucle de polling.
- Si `IE` est√° en `0x00`, buscar en el c√≥digo del juego d√≥nde deber√≠a habilitarse.
- Si `IE` cambia a `0x00` durante el polling, identificar qu√© c√≥digo est√° escribiendo en `IE`.
- Implementar correcci√≥n basada en los hallazgos.

---

### 2025-12-25 - Step 0279: Investigaci√≥n de Bucle de Reinicio y MBC1
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa instrumentaci√≥n avanzada para detectar si Pok√©mon Red est√° atrapado en un **Bucle de Reinicio (Reset Loop)**. El an√°lisis del Step 0278 revel√≥ que se detectaron m√°s de 300,000 salidas del bucle de retardo en solo 12 segundos, lo que sugiere fuertemente que el juego est√° reinici√°ndose continuamente. Es probable que, tras salir del retardo, el juego encuentre una condici√≥n de error (como una pila corrupta o un banco de ROM mal mapeado) y salte de nuevo a 0x0000 o ejecute un RST 00.

**Objetivo:**
- Implementar detector de paso por los vectores de reinicio (0x0000 y 0x0100) para confirmar la teor√≠a del Reset Loop.
- Implementar seguimiento del handler de V-Blank (0x0040) para verificar si las interrupciones se procesan correctamente.
- Implementar monitor de cambio de modo MBC1 para detectar si el mapeo de memoria se corrompe y desplaza el Banco 0 fuera de 0x0000-0x3FFF, rompiendo los vectores de interrupci√≥n.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregado monitor de reinicio al final del m√©todo `step()` que detecta cuando el PC pasa por los vectores de reinicio (0x0000 o 0x0100).
   - Captura: PC original, contador de reinicios, Stack Pointer, banco ROM actual, estado de IME, y registros IE/IF.
   - Agregado seguimiento del handler de V-Blank (0x0040) que detecta cuando el c√≥digo entra al handler.
   - Captura: Stack Pointer, registro HL, registro A, y banco ROM actual.

2. **Modificado `src/core/cpp/MMU.cpp`**:
   - Agregado monitor de cambio de modo MBC1 en el rango 0x6000-0x7FFF que detecta cuando el MBC1 cambia de modo (0 = ROM Banking, 1 = RAM Banking).
   - Captura: modo anterior y nuevo modo, PC donde ocurre el cambio, y bancos 0 y N actuales.
   - Permite detectar si el MBC1 se cambia accidentalmente al Modo 1, lo que podr√≠a desplazar el Banco 0 fuera de 0x0000-0x3FFF y romper los vectores de interrupci√≥n.

**Concepto de Hardware:**
**Bucles de Reinicio**: Los bucles de reinicio ocurren cuando el c√≥digo del juego intenta ejecutar una instrucci√≥n o acceder a memoria que no est√° disponible o est√° corrupta, causando que el juego salte al vector de reinicio (0x0000 o 0x0100) y reinicie la ejecuci√≥n desde el principio.

1. **Vectores de Reinicio**: El Game Boy tiene dos vectores principales: 0x0000 (Boot ROM) y 0x0100 (Cartridge Entry). Cuando el PC alcanza estos vectores, el juego est√° reiniciando.

2. **MBC1 y Mapeo de Memoria**: El MBC1 tiene dos modos: Modo 0 (ROM Banking, est√°ndar) y Modo 1 (RAM Banking, raro). Si el MBC1 se cambia accidentalmente al Modo 1, el Banco 0 de ROM podr√≠a desaparecer de 0x0000-0x3FFF, rompiendo los vectores de interrupci√≥n (0x0000, 0x0040, 0x0048, 0x0050, 0x0058, 0x0060).

3. **Vectores de Interrupci√≥n**: Todos los vectores de interrupci√≥n est√°n en el Banco 0 de ROM. Si el Banco 0 no est√° mapeado correctamente, estos vectores apuntar√°n a datos incorrectos, causando que las interrupciones ejecuten c√≥digo corrupto o basura, lo que puede llevar a un reinicio del sistema.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Modificado m√©todo `step()` al final para agregar monitores de reinicio (0x0000/0x0100) y seguimiento de V-Blank (0x0040).
- `src/core/cpp/MMU.cpp` - Modificado m√©todo `write()` en el rango 0x6000-0x7FFF para agregar monitor de cambio de modo MBC1.

**Tests y Verificaci√≥n:**
- Validaci√≥n de c√≥digo: ‚úÖ Compilaci√≥n exitosa sin errores de linter.
- Verificaci√≥n de instrumentaci√≥n: ‚úÖ Los monitores se activan autom√°ticamente durante la ejecuci√≥n del emulador.
- Validaci√≥n de m√≥dulo compilado C++: ‚úÖ Requiere recompilaci√≥n con `python setup.py build_ext --inplace`.

**Pr√≥ximos Pasos:**
- Ejecutar Pok√©mon Red con los monitores activos y analizar los logs `[RESET-WATCH]` para confirmar si hay un bucle de reinicio.
- Verificar si hay mensajes `[MBC1-MODE]` que indiquen cambios de modo incorrectos.
- Analizar los logs `[VBLANK-ENTRY]` para verificar si el handler de V-Blank se ejecuta correctamente.
- Si se confirma un bucle de reinicio, identificar la causa ra√≠z (MBC1, pila, opcode) y corregirla.

---

### 2025-12-25 - Step 0278: Operaci√≥n Ghost in the Machine: Rastreo de Flujo Post-Retardo y Depuraci√≥n de Patrones de PPU
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la "Operaci√≥n Ghost in the Machine" para rastrear el flujo de ejecuci√≥n despu√©s de que el bucle de retardo identificado en el Step 0277 termina. El an√°lisis previo confirm√≥ que el bucle de retardo funciona correctamente (DE decrementa hasta 0), pero el juego no activa la intro (el combate Nidorino vs Gengar) despu√©s del retardo. Adem√°s, la pantalla muestra un patr√≥n de franjas verticales err√≥neo, sugiriendo un problema en el renderizado de la PPU.

**Objetivo:**
- Implementar trail de ejecuci√≥n post-retardo que capture las siguientes 200 instrucciones despu√©s de que el PC sale de 0x6155 (donde termina el bucle de retardo).
- Implementar inspecci√≥n de la PPU en el centro de la pantalla (LY=72, X=80) para ver qu√© Tile ID est√° leyendo realmente cuando renderiza el fondo.
- Identificar si el juego intenta habilitar las interrupciones despu√©s del retardo (buscando opcode 0xFB - EI o escrituras en 0xFFFF).
- Entender por qu√© la PPU est√° renderizando un patr√≥n err√≥neo de franjas verticales.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregado trail de ejecuci√≥n post-retardo al final del m√©todo `step()` que captura las siguientes 200 instrucciones despu√©s de que el PC sale de 0x6155.
   - Usa `original_pc` (capturado al inicio de `step()` antes del fetch) para detectar cuando se ejecuta la instrucci√≥n en 0x6155.
   - Captura: PC original, opcode, registros A y HL, registro IE (0xFFFF), y estado de IME.
   - L√≠mite de 200 instrucciones para evitar saturar el log.

2. **Modificado `src/core/cpp/PPU.cpp`**:
   - Agregada inspecci√≥n de PPU en el m√©todo `render_scanline()` que se ejecuta una sola vez cuando se renderiza el centro de la pantalla (LY=72, X=80).
   - Captura: Tile Map Address, Tile ID le√≠do, y Tile Data Base configurado.
   - Permite verificar si la PPU est√° leyendo Tile IDs correctos del tilemap o si est√° leyendo basura.

**Concepto de Hardware:**
**Rutinas de Inicializaci√≥n de Juegos**: En los juegos originales de Game Boy desarrollados por compa√±√≠as como Game Freak (Pok√©mon), las rutinas de inicializaci√≥n siguen un patr√≥n espec√≠fico para gestionar el hardware antes de ceder el control al motor de juego principal.

1. **Secuencia de inicializaci√≥n**: Una rutina t√≠pica incluye: reset de hardware, configuraci√≥n de registros, desactivaci√≥n de interrupciones (DI), bucles de retardo, activaci√≥n de interrupciones (EI), e inicio del motor de juego.

2. **El "silencio post-retardo"**: Si un juego ejecuta un bucle de retardo pero nunca habilita interrupciones despu√©s, el juego se queda "mudo": la CPU puede ejecutar instrucciones, pero las interrupciones de hardware (V-Blank, Timer) nunca se procesan. Esto causa que la intro no arranque, la PPU no se sincronice, y el Timer no funcione.

3. **Patrones de renderizado err√≥neos**: Si la PPU est√° renderizando franjas verticales err√≥neas, esto puede indicar problemas de direccionamiento, tilemap no inicializado, Tile Data Base incorrecto, o scroll incorrecto. Si la VRAM fue borrada a 0x00 y el Tilemap tiene 0x7F, la PPU est√° intentando renderizar el Tile 0x7F. Si el Tile 0x7F est√° vac√≠o, la pantalla deber√≠a ser de un color s√≥lido, no mostrar franjas.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Modificado m√©todo `step()` al final para agregar trail de ejecuci√≥n post-retardo (0x6155).
- `src/core/cpp/PPU.cpp` - Modificado m√©todo `render_scanline()` para agregar inspecci√≥n de Tile ID en el centro de la pantalla (LY=72, X=80).

**Tests y Verificaci√≥n:**
- Validaci√≥n de c√≥digo: ‚úÖ Compilaci√≥n exitosa sin errores de linter.
- Verificaci√≥n de instrumentaci√≥n: ‚úÖ El trail post-retardo se activa cuando el PC sale de 0x6155 y captura las siguientes 200 instrucciones.
- Verificaci√≥n de PPU: ‚úÖ La inspecci√≥n de PPU se ejecuta una sola vez cuando se renderiza el centro de la pantalla.

**Pr√≥ximos Pasos:**
- Ejecutar Pok√©mon Red y analizar los logs [POST-DELAY] para ver qu√© instrucciones se ejecutan despu√©s del retardo.
- Buscar si aparece `EI` (0xFB) o escrituras en 0xFFFF en los logs [POST-DELAY].
- Analizar el log [PPU-DEBUG] para ver qu√© Tile ID est√° leyendo la PPU en el centro de la pantalla.
- Si el juego no habilita interrupciones, investigar por qu√© (¬øhay un bug en el c√≥digo del juego?, ¬øestamos saltando c√≥digo accidentalmente?).
- Si hay franjas verticales, investigar el error de direccionamiento en la PPU o el tilemap.
- Si el juego habilita interrupciones pero la intro no arranca, investigar por qu√© las interrupciones V-Blank no se procesan correctamente.

**Fuentes Consultadas:**
- Pan Docs: Game Boy Programming Manual - Interrupts, PPU, LCD Control
- Pan Docs: CPU Instruction Set - EI (0xFB), DI (0xF3)

---

### 2025-12-25 - Step 0277: Operaci√≥n Warp Drive: Monitor de Decremento y Validaci√≥n de Bucle de Retardo
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la "Operaci√≥n Warp Drive" para validar el bucle de retardo identificado en el Step 0276. El an√°lisis previo revel√≥ que el juego NO est√° poleando hardware, sino ejecutando un bucle de retardo por software basado en el registro DE. El bucle decrementa DE hasta que llega a 0, y luego contin√∫a con la ejecuci√≥n.

**Objetivo:**
- Implementar captura de la carga inicial de DE en PC:0x614A para ver qu√© valor se carga.
- Implementar monitoreo del decremento de DE cada 1000 iteraciones en PC:0x6150 para verificar que DE est√° disminuyendo correctamente.
- Implementar detecci√≥n de salida del bucle cuando el PC sale del rango 0x614A-0x6155.
- Validar que la instrucci√≥n DEC DE (opcode 0x1B) est√° correctamente implementada.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregada variable est√°tica `saved_pc_for_instrumentation` al inicio de `step()` para rastrear el PC original antes del fetch.
   - Agregado monitor en caso `0x11` (LD DE, nn) para capturar cuando se carga DE en PC:0x614A, imprimiendo el valor cargado.
   - Agregado monitor en caso `0x1B` (DEC DE) para monitorear el decremento cada 1000 iteraciones cuando el PC original es 0x6150, imprimiendo el estado de DE, LY y DIV.
   - Agregado trigger de salida del bucle al inicio de `step()` para detectar cuando el PC sale del rango 0x614A-0x6155, indicando que el bucle termin√≥.

**Concepto de Hardware:**
**Bucles de Retardo por Software**: En la Game Boy, los bucles de retardo por software son una t√©cnica com√∫n para crear pausas temporales sin usar hardware de timer o interrupciones. Estos bucles funcionan decrementando un registro de 16 bits hasta que llega a 0, consumiendo ciclos de CPU de forma predecible.

1. **Estructura del bucle**: Un bucle de retardo t√≠pico carga un valor inicial en un par de registros (ej: DE), luego decrementa el par, verifica si lleg√≥ a 0 (usando OR o ADD para combinar los bytes y verificar flags), y repite si no es 0.

2. **C√°lculo de tiempo real**: El tiempo que tarda un bucle de retardo depende del valor inicial (si DE se carga con 0xFFFF, el bucle ejecutar√° 65,536 iteraciones), los ciclos por iteraci√≥n, y la frecuencia de CPU (~4.19 MHz). Si DE se carga con 0xFFFF, el bucle puede tardar varios milisegundos en completarse.

3. **La "ilusi√≥n del atascamiento"**: Si un bucle de retardo se carga con un valor muy grande (ej: 0xFFFF), puede parecer que el juego est√° congelado cuando en realidad solo est√° esperando a que el bucle termine. Esto es especialmente problem√°tico en emuladores si la ALU de 16 bits tiene un bug y DE no est√° decrementando correctamente.

4. **DEC DE (opcode 0x1B)**: La instrucci√≥n DEC DE decrementa el par de registros DE en 1. Consume 2 M-Cycles (8 T-Cycles) y **NO afecta flags** (a diferencia de DEC r que s√≠ afecta Z, N, H). Si DE = 0x0000, despu√©s de DEC DE, DE = 0xFFFF (wrap-around en 16 bits). Es cr√≠tico que esta instrucci√≥n funcione correctamente porque muchos bucles de retardo dependen de ella.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Modificado m√©todo `step()` para agregar monitores espec√≠ficos: carga DE (0x614A), decremento (0x6150), y salida del bucle (0x614A-0x6155).
- `src/core/cpp/CPU.cpp` - Modificado caso `0x11` (LD DE, nn) para capturar carga inicial.
- `src/core/cpp/CPU.cpp` - Modificado caso `0x1B` (DEC DE) para monitorear decremento.

**Tests y Verificaci√≥n:**
- Validaci√≥n de c√≥digo: ‚úÖ Compilaci√≥n exitosa sin errores de linter.
- Verificaci√≥n de DEC DE: ‚úÖ La instrucci√≥n `DEC DE` (opcode 0x1B) est√° correctamente implementada usando `dec_16bit(1)`.
- Verificaci√≥n de dec_16bit(): ‚úÖ La funci√≥n `dec_16bit(1)` decrementa DE correctamente usando wrap-around en 16 bits.

**Pr√≥ximos Pasos:**
- Ejecutar Pok√©mon Red y analizar los logs [SNIPER-LOAD] para ver qu√© valor se carga en DE.
- Verificar que DE est√° disminuyendo correctamente usando los logs [SNIPER-DELAY].
- Confirmar que el bucle termina cuando DE llega a 0 (buscar [SNIPER-EXIT]).
- Si DE no est√° disminuyendo, investigar y corregir el bug en dec_16bit().
- Calcular el tiempo real que tarda el bucle bas√°ndose en el valor inicial de DE y los ciclos por iteraci√≥n.

**Fuentes Consultadas:**
- Pan Docs: CPU Instruction Set - DEC rr (0x0B, 0x1B, 0x2B, 0x3B)
- Pan Docs: CPU Instruction Set - LD rr, nn (0x01, 0x11, 0x21, 0x31)

---

### 2025-12-25 - Step 0276: Operaci√≥n Time-Lapse: Disecci√≥n del Bucle de Polling y Monitor de Registros de Tiempo
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la "Operaci√≥n Time-Lapse" para diseccionar el bucle de polling activo en el que Pok√©mon Red est√° atrapado (PC: 614D - 6151). El an√°lisis del Step 0275 revel√≥ que el juego no est√° en HALT, sino que est√° poleando (revisando constantemente) una condici√≥n. La hip√≥tesis es que el juego est√° esperando que un registro de hardware (como LY, DIV o el flag 0xD732) cambie, pero si nuestro Timer o PPU no est√°n avanzando correctamente, el juego se queda atrapado en el tiempo.

**Objetivo:**
- Implementar Sniper Trace del bucle atrapado (614D-6155) para capturar exactamente qu√© opcodes ejecuta y qu√© valores lee de la memoria (LY, DIV, STAT, D732).
- Implementar Monitor de Registros de Tiempo (DIV/TIMA) en MMU.cpp para confirmar que el Timer est√° incrementando el registro DIV cuando el juego lo lee.
- Verificar que la sincronizaci√≥n en `run_scanline()` est√° funcionando correctamente (PPU y Timer se actualizan despu√©s de cada instrucci√≥n).
- Identificar si el tiempo est√° "congelado" para la CPU, causando que el bucle de espera se vuelva infinito.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregado Sniper Trace del bucle de polling (614D-6155) al **inicio** del m√©todo `step()`, **antes** de procesar interrupciones, para capturar el estado del bucle incluso cuando hay interrupciones que interrumpen la ejecuci√≥n.
   - Captura: PC actual y opcode, registros de CPU (A, BC, HL), registros de hardware (LY, DIV, STAT), y el flag 0xD732.
   - L√≠mite de 40 trazas (unas 10 vueltas al bucle) para no saturar el log.
   - El trace se ejecuta antes de procesar interrupciones, garantizando que capturamos el estado del bucle incluso cuando las interrupciones interrumpen la ejecuci√≥n.

2. **Modificado `src/core/cpp/MMU.cpp`**:
   - Agregado Monitor de Registros de Tiempo (DIV) en el m√©todo `read()` cuando se lee el registro DIV (0xFF04).
   - Registra las primeras 10 lecturas de DIV para confirmar que el Timer est√° siendo le√≠do correctamente.
   - El monitor est√° comentado por defecto (solo se activa si se descomenta el printf) para no saturar el log.

**Concepto de Hardware:**
**Polling vs Interrupciones y el "Timer Fantasma"**: En la Game Boy, existen dos formas principales de sincronizaci√≥n entre el software y el hardware: interrupciones y polling. Mientras que las interrupciones son el m√©todo preferido (el hardware notifica al software cuando ocurre un evento), el polling es una alternativa que algunos juegos usan para verificar el estado del hardware de forma activa.

1. **Polling**: El software verifica activamente el estado del hardware leyendo registros repetidamente hasta que el valor cambia. Esto consume ciclos de CPU pero puede ser necesario cuando las interrupciones est√°n deshabilitadas o cuando el juego necesita sincronizaci√≥n precisa.

2. **Registros que se pueden pollar**: Los juegos pueden leer varios registros de hardware para sincronizaci√≥n:
   - **LY (0xFF44)**: L√≠nea de escaneo actual (0-153). Se incrementa autom√°ticamente por la PPU cada 456 T-Cycles.
   - **DIV (0xFF04)**: Registro de divisi√≥n del Timer. Se incrementa autom√°ticamente cada 256 T-Cycles (frecuencia base del Timer).
   - **STAT (0xFF41)**: Estado de la PPU (modo actual, flags de coincidencia).
   - **Flags personalizados (ej: 0xD732)**: Algunos juegos usan flags en WRAM/HRAM para comunicaci√≥n entre rutinas.

3. **El Peligro del "Timer Fantasma"**: Si un juego est√° poleando un registro de hardware (como DIV o LY) esperando que cambie, pero el emulador no est√° actualizando ese registro correctamente, el juego se queda atrapado en un bucle infinito. Esto es especialmente peligroso cuando el Timer o la PPU no est√°n siendo actualizados con los T-Cycles consumidos por la CPU.

4. **Sincronizaci√≥n en run_scanline()**: La funci√≥n `run_scanline()` es cr√≠tica para evitar el "Timer Fantasma". Esta funci√≥n ejecuta instrucciones de la CPU hasta acumular 456 T-Cycles (una scanline completa), pero **despu√©s de cada instrucci√≥n** actualiza la PPU y el Timer con los ciclos consumidos. Esto garantiza que incluso si la CPU est√° en un bucle apretado de polling, el hardware sigue avanzando.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - A√±adido Sniper Trace del bucle de polling (614D-6155) con captura de registros de hardware (LY, DIV, STAT, D732).
- `src/core/cpp/MMU.cpp` - A√±adido monitor de registros de tiempo (DIV) para confirmar que el Timer est√° siendo le√≠do correctamente.

**Tests y Verificaci√≥n:**
- Comando ejecutado: `python main.py roms/pkmn.gb`
- Resultado: ‚úÖ Se capturaron 40 trazas `[SNIPER-LOOP]` exitosamente
- An√°lisis de logs: Las trazas revelaron informaci√≥n cr√≠tica sobre el bucle

**Resultados del An√°lisis:**
1. **Opcodes del bucle (desensamblado):**
   - `614A: 11` - LD DE, nn (carga un valor en DE)
   - `614D: 00` - NOP
   - `614E: 00` - NOP
   - `614F: 00` - NOP
   - `6150: 1B` - DEC DE (decrementa DE)
   - `6151: 7A` - LD A, D (carga D en A)
   - `6152: B3` - OR E (A = A | E)
   - `6153: 20` - JR NZ, e (salto relativo si Z=0)

2. **Estado de los registros de hardware:**
   - **LY:** 20 (constante, no cambia) - ‚ö†Ô∏è Posible problema de sincronizaci√≥n de PPU
   - **DIV:** 15 ‚Üí 16 (s√≠ cambia) - ‚úÖ Timer funciona correctamente
   - **STAT:** 03 ‚Üí 00 (cambia) - ‚úÖ PPU est√° actualizando STAT
   - **D732:** 00 (constante) - No se modifica durante el bucle

3. **Interpretaci√≥n del Bucle:**
   - El bucle en `614D-6153` **NO est√° poleando hardware**. Es un bucle de retardo basado en el registro DE.
   - El bucle espera a que DE llegue a 0. No est√° esperando que ning√∫n registro de hardware cambie.
   - El Timer funciona correctamente (DIV avanza), pero LY est√° est√°tico en 20, lo que sugiere un posible problema de sincronizaci√≥n de la PPU.

**Conclusi√≥n:**
- ‚úÖ El Timer funciona correctamente (DIV avanza de 15 a 16)
- ‚úÖ El bucle NO est√° poleando hardware (es un retardo basado en DE)
- ‚ö†Ô∏è LY est√° est√°tico en 20 (posible problema de sincronizaci√≥n de PPU)
- ‚úÖ Validaci√≥n de m√≥dulo compilado C++: Compilaci√≥n exitosa. Los logs `[SNIPER-LOOP]` aparecen correctamente.

**Fuentes Consultadas:**
- Pan Docs: Timer and Divider Registers
- Pan Docs: LCD Status Register (STAT)
- Pan Docs: Interrupts - Secci√≥n sobre polling vs interrupciones

---

### 2025-12-25 - Step 0275: Operaci√≥n Rebirth: Disecci√≥n de la Rutina de Inicializaci√≥n y Watchdog de HALT
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la "Operaci√≥n Rebirth" para diseccionar la rutina de inicializaci√≥n de Pok√©mon Red donde se desactivan las interrupciones. El an√°lisis del Step 0274 revel√≥ que el juego ejecuta `DI` (0xF3) en `PC:1F54` y escribe `0x00` en `0xFFFF` (IE) en `PC:1F58`, causando un "suicidio t√©cnico" que bloquea el juego en un estado de coma permanente.

**Objetivo:**
- Implementar Sniper Trace de la zona de muerte (1F54-1F60) para capturar la secuencia exacta de opcodes que acompa√±an al apagado de interrupciones.
- Implementar Monitor de Salto de Banco (Bank Watcher) para detectar cambios de banco ROM que puedan desorientar el rastreo.
- Implementar Watchdog de "HALT of Death" para detectar cuando la CPU entra en HALT con IE=0 e IME=0, un estado de huelga permanente.
- Entender por qu√© el juego no reactiva las interrupciones despu√©s de desactivarlas.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregado Sniper Trace de la zona de muerte (1F54-1F60) al final del m√©todo `step()` que captura el estado de la CPU cuando el PC est√° en el rango `0x1F50-0x1F65`.
   - Captura: PC actual y los siguientes 3 opcodes, estado de todos los registros (AF, BC, DE, HL), estado del IME, valor de IE e IF.
   - L√≠mite de 100 trazas para evitar saturar los logs.
   - Agregado Watchdog de "HALT of Death" en el `case 0x76` (HALT) que detecta cuando la CPU intenta entrar en HALT con `IE=0` e `IME=0`.
   - Imprime advertencia cr√≠tica con el PC donde ocurri√≥ el HALT.

2. **Modificado `src/core/cpp/MMU.cpp`**:
   - Agregado Monitor de Salto de Banco (Bank Watcher) en el m√©todo `write()` que detecta cualquier escritura en el rango `0x2000-0x3FFF` (√°rea de control del MBC).
   - Imprime: valor escrito (nuevo banco solicitado), PC desde el cual se ejecut√≥ la escritura, banco ROM actual antes del cambio.
   - Sin l√≠mite de impresiones para asegurar que no se pierda ning√∫n cambio cr√≠tico.

**Concepto de Hardware:**
**La Instrucci√≥n HALT (0x76) y Estados de Bloqueo**: La instrucci√≥n `HALT` pone la CPU en un estado de bajo consumo donde deja de ejecutar instrucciones hasta que ocurre una interrupci√≥n. Sin embargo, hay comportamientos especiales:

1. **Si IME=1**: La CPU entra en HALT y espera una interrupci√≥n. Cuando ocurre, la CPU sale de HALT y procesa la interrupci√≥n normalmente.

2. **Si IME=0 pero hay interrupci√≥n pendiente (IE & IF != 0)**: La CPU NO entra en HALT. Simplemente contin√∫a ejecutando la siguiente instrucci√≥n. Este es el "HALT bug" documentado en Pan Docs.

3. **Si IME=0 e IE=0**: La CPU entra en HALT y **nunca sale**. Este es un estado de "huelga permanente" que bloquea el juego completamente.

**El Peligro de los Estados de Espera Infinitos**: Cuando un juego desactiva todas las interrupciones (IE=0x00) y luego ejecuta `HALT`, la CPU entra en un estado de coma permanente. Ning√∫n evento externo puede despertarla porque IME=0, IE=0 y HALT est√° activo. Este es un estado de "muerte t√©cnica" del juego.

**Cambios de Banco ROM (MBC)**: Los juegos con m√∫ltiples bancos ROM pueden cambiar de banco escribiendo en el rango `0x2000-0x3FFF`. Cuando esto ocurre, el mismo PC apunta a c√≥digo diferente. Si el juego cambia de banco justo despu√©s de desactivar interrupciones, el rastreo puede perderse porque el c√≥digo que se espera ver en un banco puede estar en otro.

**Tests y Verificaci√≥n:**
- Comando: `python main.py roms/pkmn.gb`
- Buscar l√≠neas `[SNIPER-INIT]` para ver la secuencia exacta de opcodes en la zona de muerte (1F54-1F60), incluyendo el `DI` (0xF3) y la escritura a IE (0xFFFF).
- Buscar l√≠neas `[MBC-WRITE]` para ver cualquier cambio de banco ROM que ocurra durante o despu√©s de la desactivaci√≥n de interrupciones.
- Buscar l√≠neas `[CRITICAL WARNING]` para confirmar si el juego entra en HALT con IE=0 e IME=0, confirmando el "suicidio t√©cnico".
- Validaci√≥n de m√≥dulo compilado C++: La compilaci√≥n debe completarse sin errores y los logs deben aparecer durante la ejecuci√≥n del emulador.

**Pr√≥ximos Pasos:**
- Ejecutar el emulador con Pok√©mon Red y analizar los logs generados.
- Desensamblar la secuencia de opcodes capturada por [SNIPER-INIT] para entender el flujo exacto.
- Verificar si hay cambios de banco ROM durante la rutina de inicializaci√≥n ([MBC-WRITE]).
- Confirmar si el juego entra en HALT con IE=0 e IME=0 ([CRITICAL WARNING]).
- Si se identifica el problema, implementar correcci√≥n o ajuste en el emulador.

---

### 2025-12-25 - Step 0274: Operaci√≥n IE Hunter: Rastreo del Registro IE e Interrupciones
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa la "Operaci√≥n IE Hunter" para rastrear qui√©n y cu√°ndo modifica el registro de habilitaci√≥n de interrupciones (IE, direcci√≥n `0xFFFF`). El an√°lisis del Step 0273 revel√≥ que `IE = 0x00` (todas las interrupciones deshabilitadas) mientras que `IF = 0x01` (V-Blank pendiente), lo que impide que el juego procese interrupciones y causa un deadlock en bucles de espera.

**Objetivo:**
- Implementar instrumentaci√≥n que capture cada escritura en el registro IE (`0xFFFF`) para identificar qu√© c√≥digo lo modifica y cu√°ndo ocurre.
- Rastrear el flujo de ejecuci√≥n despu√©s de que termine el bucle de limpieza de VRAM (PC:36E3) para ver qu√© c√≥digo se ejecuta a continuaci√≥n.
- Monitorear las instrucciones `EI` (Enable Interrupts) y `DI` (Disable Interrupts) para rastrear el estado del IME (Interrupt Master Enable).
- Identificar el momento exacto en que el registro IE se deshabilita y qu√© c√≥digo lo causa.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/MMU.cpp`**:
   - Agregado bloque de instrumentaci√≥n `[IE-WRITE]` en el m√©todo `write()` que detecta cada escritura en `0xFFFF`.
   - Imprime: nuevo valor escrito, PC desde el cual se ejecut√≥ la escritura, banco ROM actual.
   - No tiene l√≠mite de impresiones (cr√≠tico ver todas las escrituras en IE).

2. **Modificado `src/core/cpp/CPU.cpp`**:
   - Agregado sistema de "trail" (rastro) post-limpieza VRAM que se activa cuando el PC llega a `0x36E9` (asumiendo que el bucle de limpieza tiene 6 bytes).
   - Imprime `[VRAM-CLEAR-EXIT]` cuando se detecta la salida del bucle.
   - Imprime `[TRAIL]` con el estado completo de la CPU (PC, opcode, registros, IE, IF) para las siguientes 100 instrucciones.
   - Agregado logging `[CPU] DI/EI` en los casos de las instrucciones `DI` (0xF3) y `EI` (0xFB) para rastrear cu√°ndo se intenta activar o desactivar el IME.

**Concepto de Hardware:**
**Sistema de Interrupciones de Dos Niveles**: El sistema de interrupciones de la Game Boy tiene dos niveles de control independientes que deben estar activos simult√°neamente:

1. **IME (Interrupt Master Enable)**: Flag interno de la CPU controlado por las instrucciones `EI` y `DI`. La instrucci√≥n `EI` activa el IME despu√©s de ejecutar la siguiente instrucci√≥n, permitiendo secuencias at√≥micas.

2. **IE (Interrupt Enable Register)**: Registro mapeado en `0xFFFF` que controla qu√© tipos de interrupciones est√°n habilitadas. Cada bit corresponde a un tipo de interrupci√≥n (V-Blank, STAT, Timer, Serial, Joypad).

**Condici√≥n para Procesar una Interrupci√≥n**: Para que una interrupci√≥n se procese, se deben cumplir tres condiciones simult√°neas:
- IME = 1 (flag interno activo)
- IE[bit] = 1 (bit correspondiente en IE activo)
- IF[bit] = 1 (bit correspondiente en IF activo - solicitud pendiente)

Si cualquiera de estas condiciones falla, la interrupci√≥n no se procesa. En el caso de Pok√©mon Red, `IE = 0x00` (todos los bits deshabilitados) mientras que `IF = 0x01` (V-Blank pendiente), lo que significa que el juego est√° esperando una interrupci√≥n que nunca se puede procesar porque IE est√° apagado.

**Tests y Verificaci√≥n:**
- Comando: `python main.py roms/pkmn.gb`
- Buscar l√≠neas `[IE-WRITE]` para ver cada escritura en `0xFFFF`, especialmente si se escribe `0x00`.
- Buscar l√≠nea `[VRAM-CLEAR-EXIT]` para confirmar que el bucle de limpieza termin√≥.
- Buscar l√≠neas `[TRAIL]` para ver el flujo de ejecuci√≥n despu√©s de la limpieza.
- Buscar l√≠neas `[CPU] DI/EI` para ver cu√°ndo se intenta activar o desactivar el IME.
- Validaci√≥n de m√≥dulo compilado C++: La compilaci√≥n debe completarse sin errores y los logs deben aparecer durante la ejecuci√≥n.

**Pr√≥ximos Pasos:**
- Ejecutar el emulador con Pok√©mon Red y analizar los logs generados.
- Identificar el momento exacto en que IE se deshabilita (buscar `[IE-WRITE]` con valor `0x00`).
- Analizar el `[TRAIL]` para ver qu√© c√≥digo se ejecuta despu√©s de la limpieza de VRAM.
- Verificar si hay una instrucci√≥n `DI` que desactiva el IME sin reactivarlo.
- Si se identifica el c√≥digo culpable, implementar correcci√≥n o ajuste en el emulador.

---

### 2025-12-25 - Step 0273: Operaci√≥n Sniper: Disecci√≥n de Bucles Cr√≠ticos
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa un sistema de "Sniper Traces" (trazas de francotirador) para capturar instant√°neas precisas del estado de la CPU en puntos cr√≠ticos del c√≥digo de Pok√©mon Red.

**Objetivo:**
- Implementar instrumentaci√≥n quir√∫rgica que capture el estado completo de la CPU (registros, opcodes, banco ROM, flags de interrupci√≥n) solo cuando el PC coincide con direcciones cr√≠ticas: `0x36E3` (limpieza de VRAM), `0x6150` y `0x6152` (espera del flag `0xD732`).
- A√±adir un "trigger" que detecte cualquier intento de escritura en `0xD732`, permitiendo identificar qu√© c√≥digo intenta modificar este flag de sincronizaci√≥n.
- Implementar m√©todo `get_current_rom_bank()` en MMU para reportar el banco ROM actual en las trazas.
- Limitar la salida a 50 trazas por direcci√≥n para evitar saturaci√≥n de logs.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregado bloque de Sniper Traces al final del m√©todo `step()` (antes del cierre de la funci√≥n).
   - Detecta cuando el PC coincide con `0x36E3`, `0x6150` o `0x6152`.
   - Imprime traza completa: PC, banco ROM, 3 bytes siguientes (opcode + 2 bytes), SP, AF, BC, DE, HL, IE, IF.
   - Usa variable est√°tica `sniper_limit` para limitar a 50 trazas por direcci√≥n.

2. **Modificado `src/core/cpp/MMU.cpp`**:
   - Agregado trigger D732 en m√©todo `write()` que detecta escrituras en `0xD732`.
   - Imprime: valor escrito, PC desde el cual se realiza la escritura, banco ROM actual.
   - No tiene l√≠mite de impresiones (cr√≠tico ver todos los intentos de escritura).

3. **Modificado `src/core/cpp/MMU.hpp` y `MMU.cpp`**:
   - Agregado m√©todo p√∫blico `get_current_rom_bank()` que retorna `bankN_rom_` (banco mapeado en `0x4000-0x7FFF`).
   - Permite que la CPU acceda al banco ROM actual para reportarlo en las trazas.

**Concepto de Hardware:**
**Busy Loops y Flags de Sincronizaci√≥n**: Los juegos de Game Boy utilizan patrones de sincronizaci√≥n basados en "busy loops" (bucles ocupados) y flags en WRAM para coordinar el c√≥digo principal con las ISR (Interrupt Service Routines). Cuando el c√≥digo principal necesita esperar a que una interrupci√≥n complete una tarea, establece un flag en WRAM y entra en un bucle que lee ese flag repetidamente hasta que la ISR lo modifica.

En el caso de Pok√©mon Red, el juego espera en `PC ‚âà 0x6150` a que la direcci√≥n `0xD732` cambie de valor. Si este flag permanece en `0x00`, el bucle nunca termina y el juego se congela. Las causas posibles son: ISR no se ejecuta, banco ROM incorrecto, o condici√≥n de hardware no detectada.

**Tests y Verificaci√≥n:**
- Comando: `python main.py roms/pkmn.gb`
- Buscar l√≠neas `[SNIPER]` para ver el estado de la CPU en direcciones cr√≠ticas.
- Buscar l√≠neas `[TRIGGER-D732]` para ver todos los intentos de escritura en `0xD732`.
- Verificar el banco ROM reportado: si el banco en `0x36E3` no es el esperado, podr√≠a indicar un problema de MBC.
- Analizar los opcodes impresos para desensamblar mentalmente la instrucci√≥n.

**Resultados del An√°lisis:**
- **Total de trazas capturadas**: 52
  - **Trazas [SNIPER]**: 50 (todas en PC:36E3)
  - **Trazas [TRIGGER-D732]**: 1 (desde PC:1F80)

**Hallazgos Cr√≠ticos:**
1. **PC:36E3 - Rutina de Limpieza de VRAM**:
   - Opcodes: `22 0B 78` ‚Üí `LD (HL+), A | DEC BC | LD A, B`
   - Limpia VRAM escribiendo `0x00` desde `0x8000` usando `BC` como contador (2000 iteraciones = 8KB)
   - Banco ROM: 1 (correcto)

2. **Interrupciones Deshabilitadas (IE=00)**:
   - `IE = 0x00`: TODAS las interrupciones est√°n deshabilitadas
   - `IF = 0x01`: V-Blank pendiente pero no se procesa porque IE=0
   - **Causa ra√≠z identificada**: Las ISR no se pueden ejecutar, por lo que el flag `0xD732` nunca cambia

3. **Flag 0xD732**:
   - Solo se escribe UNA vez desde `PC:1F80` con valor `00`
   - Nunca se modifica despu√©s porque ninguna ISR se ejecuta (IE=0)

4. **PC:6150/6152**:
   - 0 trazas capturadas: el juego no llega a estas direcciones
   - Se queda atascado antes del bucle de espera

**Conclusi√≥n:**
El juego deshabilita todas las interrupciones (`IE=0x00`) y espera que una ISR (probablemente V-Blank) modifique `0xD732` a un valor distinto de `0x00`. Como IE=0, la ISR nunca se ejecuta, y el flag nunca cambia, causando un bucle de espera infinito.

**Pr√≥ximos Pasos:**
- Buscar d√≥nde se deshabilita IE: Analizar el c√≥digo antes de `PC:36E3` para encontrar d√≥nde se escribe `0x00` en `0xFFFF`.
- Verificar el bucle de espera: Desensamblar el c√≥digo en `0x6150`/`0x6152` para confirmar que lee `0xD732`.
- Implementar correcci√≥n: Si el juego deber√≠a tener IE habilitado, corregir el c√≥digo que lo deshabilita incorrectamente.

---

### 2025-12-24 - Step 0271: Misc Instructions Implementation (DAA, CPL, SCF, CCF)
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa las instrucciones miscel√°neas del bloque bajo y los loads b√°sicos que segu√≠an faltando.

**Objetivo:**
- Implementar las instrucciones miscel√°neas faltantes: `DAA` (0x27), `CPL` (0x2F), `SCF` (0x37) y `CCF` (0x3F).
- Implementar loads cr√≠ticos: `LD (BC), A`, `LD (DE), A`, `LD A, (BC)`, `LD A, (DE)`, `LDI/LD A, (HL¬±)`, `LDH (C), A`, `LDH A, (C)`, `LD (nn), A`, `LD A, (nn)`.
- Corregir el bucle infinito de `RST 38` (`PC:0038`) causado por la desincronizaci√≥n del PC debido a instrucciones faltantes (BCD y E/S 0xFF00).
- Asegurar que `DAA` ajuste correctamente el registro A para BCD tras suma/resta y que los accesos a registros de hardware funcionen.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregado `DAA` (0x27): 1 M-Cycle. Ajusta el registro A para que sea un n√∫mero BCD v√°lido tras una suma/resta. La l√≥gica depende del flag N (si fue suma o resta) y de los flags H y C.
   - Agregado `CPL` (0x2F): 1 M-Cycle. Invierte todos los bits del registro A (A = ~A). Flags: Z (preservado), N=1, H=1, C (preservado).
   - Agregado `SCF` (0x37): 1 M-Cycle. Activa el flag Carry (C = 1). Flags: Z (preservado), N=0, H=0, C=1.
   - Agregado `CCF` (0x3F): 1 M-Cycle. Invierte el flag Carry (C = !C). Flags: Z (preservado), N=0, H=0, C=!C.
   - Agregados loads b√°sicos: `LD (BC), A`, `LD (DE), A`, `LD A, (BC)`, `LD A, (DE)`, `LDI/LD A, (HL¬±)` (auto-incremento/decremento), `LDH (C), A`, `LDH A, (C)` para 0xFF00 + C, y `LD (nn), A` / `LD A, (nn)` para direcciones absolutas (2 o 4 M-Cycles seg√∫n el caso).
   - Interrupciones: `RETI` (0xD9) para reactivar IME al salir de la rutina.
   - HALT bug: si IME=0 y hay interrupci√≥n pendiente (IE & IF != 0), HALT no detiene la CPU (equivale a NOP) para evitar bucles con IME desactivado.

**Concepto de Hardware:**
**Bucle RST 38**: Si el juego "descarrila" y salta a una zona vac√≠a, lee `0xFF`, ejecuta `RST 38`, empuja el PC a la pila, salta a `0038`, lee `0xFF` otra vez (si `0038` no tiene c√≥digo v√°lido), vuelve a empujar... Esto causa un Stack Overflow (el SP baja hasta dar la vuelta).

**DAA y BCD**: Pok√©mon usa aritm√©tica BCD (Binary Coded Decimal) intensivamente para la salud, el dinero y los puntos. Si `DAA` no est√° implementada, los c√°lculos salen mal, el juego hace `JP HL` a una direcci√≥n equivocada, aterriza en una zona vac√≠a de memoria (llena de `0xFF`), y entra en un bucle infinito de `RST 38`.

**Desincronizaci√≥n del PC**: Cuando faltan instrucciones (BCD o loads de E/S), la CPU puede "descarrilarse" (desincronizarse del flujo de instrucciones correcto). Si un load a 0xFF00 falla, los registros de hardware quedan sin inicializar y el juego termina saltando a direcciones inv√°lidas.

**Fuente:** Pan Docs - "CPU Instruction Set", "DAA Instruction", "CPL Instruction", "SCF Instruction", "CCF Instruction", "BCD Arithmetic", "LDH (C), A / LDH A, (C)"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregadas 14 instrucciones (miscel√°neas y loads 8-bit) en el m√©todo `step()` (Step 0271).

**Pr√≥ximos Pasos:**
- Recompilar el m√≥dulo C++ con `.\rebuild_cpp.ps1`.
- Ejecutar el emulador con Pok√©mon Red y verificar que el bucle de `RST 38` desaparece.
- Verificar que el juego avanza m√°s all√° del bucle de espera y muestra la intro (estrellas, Game Freak, Gengar).
- Si el problema persiste, investigar otras causas posibles (otras instrucciones faltantes, problemas en gesti√≥n de memoria, etc.).

---

### 2025-12-23 - Step 0270: Stack Operations Completion (DE, HL, AF)
**Estado**: ‚úÖ IMPLEMENTADO

Este Step completa las operaciones de pila (PUSH/POP) para todos los pares de registros de la CPU.

**Objetivo:**
- Implementar las instrucciones PUSH/POP faltantes para los pares DE, HL y AF.
- Corregir el bucle infinito de `RST 38` (`PC:0038`) causado por la falta de estas instrucciones.
- Asegurar que POP AF limpie correctamente los 4 bits bajos del registro F.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregado `PUSH DE` (0xD5): 4 M-Cycles. Empuja el par DE en la pila.
   - Agregado `POP DE` (0xD1): 3 M-Cycles. Saca una palabra de la pila y la guarda en DE.
   - Agregado `PUSH HL` (0xE5): 4 M-Cycles. Empuja el par HL en la pila.
   - Agregado `POP HL` (0xE1): 3 M-Cycles. Saca una palabra de la pila y la guarda en HL.
   - Agregado `PUSH AF` (0xF5): 4 M-Cycles. Empuja el par AF en la pila.
   - Agregado `POP AF` (0xF1): 3 M-Cycles. Saca una palabra de la pila y la guarda en AF, limpiando expl√≠citamente los 4 bits bajos de F con `& 0xFFF0`.

**Concepto de Hardware:**
**Bucle RST 38**: Si el juego "descarrila" y salta a una zona vac√≠a, lee `0xFF`, ejecuta `RST 38`, empuja el PC a la pila, salta a `0038`, lee `0xFF` otra vez (si `0038` no tiene c√≥digo v√°lido), vuelve a empujar... Esto causa un Stack Overflow (el SP baja hasta dar la vuelta).

**PUSH/POP AF**: Pok√©mon usa `PUSH AF` y `POP AF` constantemente para guardar y recuperar el estado de los flags. Si estas instrucciones no est√°n implementadas, la pila se desalinea o los registros quedan con valores basura, causando saltos a direcciones inv√°lidas (que se leen como `0xFF`, ejecutando `RST 38`).

**Registro F**: Los 4 bits bajos del registro F siempre deben ser cero. Al hacer `POP AF`, debemos limpiar esos bits expl√≠citamente con `& 0xFFF0`.

**Fuente:** Pan Docs - "CPU Instruction Set", "Stack Operations", "Register F (Flags)"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregadas 6 nuevas instrucciones de pila en el m√©todo `step()` (Step 0270).

**Pr√≥ximos Pasos:**
- Recompilar el m√≥dulo C++ con `.\rebuild_cpp.ps1`.
- Ejecutar el emulador con Pok√©mon Red y verificar que el bucle de `RST 38` desaparece.
- Verificar que el Stack Pointer se mantiene estable (no cae en picada).
- Verificar que el juego avanza m√°s all√° del bucle de espera y muestra la intro (estrellas, Game Freak, Gengar).

---

### 2025-12-23 - Step 0269: Control Flow Completion (Calls, Rets, RSTs)
**Estado**: ‚úÖ IMPLEMENTADO

Este Step completa el conjunto de instrucciones de control de flujo de la CPU implementando todas las instrucciones condicionales y RST que faltaban.

**Objetivo:**
- Implementar todas las instrucciones de control de flujo restantes que faltaban en la CPU.
- Corregir el "Desastre de Flujo de Control" que causaba la corrupci√≥n del Stack Pointer.
- Asegurar que las instrucciones condicionales lean siempre los operandos para mantener el PC alineado.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregadas 4 retornos condicionales: `RET NZ` (0xC0), `RET Z` (0xC8), `RET NC` (0xD0), `RET C` (0xD8).
   - Agregadas 4 llamadas condicionales: `CALL NZ, nn` (0xC4), `CALL Z, nn` (0xCC), `CALL NC, nn` (0xD4), `CALL C, nn` (0xDC).
   - Agregados 4 saltos absolutos condicionales: `JP NZ, nn` (0xC2), `JP Z, nn` (0xCA), `JP NC, nn` (0xD2), `JP C, nn` (0xDA).
   - Agregadas 8 instrucciones RST: `RST 00` (0xC7), `RST 08` (0xCF), `RST 10` (0xD7), `RST 18` (0xDF), `RST 20` (0xE7), `RST 28` (0xEF), `RST 30` (0xF7), `RST 38` (0xFF).
   - Agregado salto indirecto: `JP (HL)` (0xE9).

**Concepto de Hardware:**
**Desastre de Flujo de Control**: Si una instrucci√≥n condicional (como `CALL Z`) no est√° implementada, act√∫a como NOP, desbalanceando la pila. Cuando luego se ejecuta un `RET`, saca datos err√≥neos y corrompe el SP.

**Restarts (RST)**: Las instrucciones RST son llamadas r√°pidas de 1 byte que hacen `PUSH PC` y saltan a una direcci√≥n fija. Son cr√≠ticas para Pok√©mon, que las usa intensivamente para funciones del sistema (cambio de bancos de memoria, manejo de gr√°ficos, etc.).

**Lectura de Operandos**: En instrucciones condicionales, siempre debemos leer los operandos (nn) incluso si la condici√≥n no se cumple, para mantener el PC alineado correctamente.

**Fuente:** Pan Docs - "CPU Instruction Set", "Control Flow Instructions", "RST Instructions"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregadas 17 nuevas instrucciones de control de flujo en el m√©todo `step()` (Step 0269).

**Pr√≥ximos Pasos:**
- Recompilar el m√≥dulo C++ con `.\rebuild_cpp.ps1`.
- Ejecutar el emulador con Pok√©mon Red y verificar que el SP ya no se corrompe.
- Verificar que el juego avanza m√°s all√° del bucle de espera y muestra gr√°ficos.
- Si el SP sigue corrompido, investigar otras causas posibles (instrucciones CB faltantes, problemas en gesti√≥n de memoria, etc.).

---

### 2025-12-23 - Step 0268: Stack Math Implementation (0xE8, 0xF8, 0xF9)
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa las tres instrucciones cr√≠ticas de aritm√©tica de pila ("Stack Math") que faltaban en la CPU: **ADD SP, e (0xE8)**, **LD HL, SP+e (0xF8)** y **LD SP, HL (0xF9)**.

**Objetivo:**
- Implementar las instrucciones de aritm√©tica de pila que los compiladores C usan constantemente.
- Corregir la corrupci√≥n del Stack Pointer detectada en el Step 0267.
- Asegurar que los flags H y C se calculen correctamente (basados en el byte bajo de SP).

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregado caso `0xE8` (ADD SP, e): Suma un offset con signo de 8 bits al SP. Flags H y C se calculan bas√°ndose en el byte bajo de SP.
   - Agregado caso `0xF8` (LD HL, SP+e): Calcula SP + offset y almacena en HL (SP no se modifica). Flags id√©nticos a ADD SP, e.
   - Agregado caso `0xF9` (LD SP, HL): Copia HL a SP. No afecta flags.

**C√≥digo de las Instrucciones:**

```cpp
// Case 0xE8: ADD SP, e
case 0xE8: {
    uint8_t offset_raw = fetch_byte();
    int8_t offset = static_cast<int8_t>(offset_raw);
    uint16_t sp_old = regs_->sp;
    uint8_t sp_low = sp_old & 0xFF;
    uint16_t sp_new = (sp_old + offset) & 0xFFFF;
    regs_->sp = sp_new;
    
    // Flags: Z=0, N=0, H y C basados en byte bajo
    regs_->set_flag_z(false);
    regs_->set_flag_n(false);
    uint8_t offset_unsigned = static_cast<uint8_t>(offset_raw);
    uint8_t sp_low_nibble = sp_low & 0x0F;
    uint8_t offset_low_nibble = offset_unsigned & 0x0F;
    bool half_carry = (sp_low_nibble + offset_low_nibble) > 0x0F;
    regs_->set_flag_h(half_carry);
    bool carry = ((static_cast<uint16_t>(sp_low) + static_cast<uint16_t>(offset_unsigned)) & 0x100) != 0;
    regs_->set_flag_c(carry);
    cycles_ += 4;
    return 4;
}

// Case 0xF8: LD HL, SP+e
case 0xF8: {
    uint8_t offset_raw = fetch_byte();
    int8_t offset = static_cast<int8_t>(offset_raw);
    uint16_t sp = regs_->sp;
    uint8_t sp_low = sp & 0xFF;
    uint16_t hl_new = (sp + offset) & 0xFFFF;
    regs_->set_hl(hl_new);
    
    // Flags id√©nticos a ADD SP, e
    regs_->set_flag_z(false);
    regs_->set_flag_n(false);
    uint8_t offset_unsigned = static_cast<uint8_t>(offset_raw);
    uint8_t sp_low_nibble = sp_low & 0x0F;
    uint8_t offset_low_nibble = offset_unsigned & 0x0F;
    bool half_carry = (sp_low_nibble + offset_low_nibble) > 0x0F;
    regs_->set_flag_h(half_carry);
    bool carry = ((static_cast<uint16_t>(sp_low) + static_cast<uint16_t>(offset_unsigned)) & 0x100) != 0;
    regs_->set_flag_c(carry);
    cycles_ += 3;
    return 3;
}

// Case 0xF9: LD SP, HL
case 0xF9: {
    uint16_t hl = regs_->get_hl();
    regs_->sp = hl;
    cycles_ += 2;
    return 2;
}
```

**Concepto de Hardware:**
**Stack Math (Matem√°ticas de Pila)**: La Game Boy tiene instrucciones especiales para operar con el Stack Pointer como si fuera un registro de datos normal. Estas instrucciones son vitales para el lenguaje C y juegos como Pok√©mon:

- **ADD SP, e (0xE8)**: Suma un valor con signo al SP. Se usa para reservar o liberar espacio para variables locales. **La trampa**: Los flags H y C se calculan bas√°ndose en el byte bajo (como si fuera una suma de 8 bits), ¬°no en el resultado de 16 bits!

- **LD HL, SP+e (0xF8)**: Calcula la direcci√≥n de una variable en la pila y la pone en HL. Usa la misma l√≥gica de flags extra√±a.

- **LD SP, HL (0xF9)**: Mueve HL a SP. Esencial para restaurar la pila.

**Flags Especiales**: En ADD SP, e y LD HL, SP+e, los flags H y C se calculan bas√°ndose en el byte bajo de SP, no en el resultado completo de 16 bits. Esto es diferente a ADD HL, rr, donde los flags se calculan en los 12 bits bajos (H) y 16 bits (C).

**Fuente:** Pan Docs - "CPU Instruction Set", "ADD SP, r8", "LD HL, SP+r8", "LD SP, HL"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregados casos 0xE8, 0xF8 y 0xF9 en el m√©todo `step()` (Step 0268).

**Pr√≥ximos Pasos:**
- Recompilar el m√≥dulo C++ con `.\rebuild_cpp.ps1`.
- Ejecutar el emulador con Pok√©mon Red y verificar que el SP ya no se corrompe.
- Verificar que el juego avanza m√°s all√° del bucle de espera y muestra gr√°ficos.
- Si el watchdog del Step 0267 sigue detectando corrupci√≥n, analizar qu√© otras instrucciones pueden estar causando el problema.

---

### 2025-12-23 - Step 0267: SP Corruption Watchdog (Stack Pointer Watchdog)
**Estado**: ‚úÖ IMPLEMENTADO

Este Step implementa un watchdog (perro guardi√°n) para detectar la corrupci√≥n del Stack Pointer (SP) en tiempo real. El an√°lisis del Step 0266 revel√≥ que el GPS muestra `SP:210A`, lo cual es un estado fatal: el Stack Pointer apunta a la ROM (solo lectura) cuando deber√≠a estar en RAM escribible.

**Objetivo:**
- Implementar un watchdog que detecte el momento exacto en que el SP se corrompe.
- Identificar la instrucci√≥n que causa la corrupci√≥n del Stack Pointer.
- Verificar que las instrucciones relacionadas con SP est√©n implementadas correctamente.

**Implementaci√≥n:**
1. **Modificado `src/core/cpp/CPU.cpp`**: 
   - Agregado watchdog de SP al final del m√©todo `step()` que se ejecuta despu√©s de cada instrucci√≥n.
   - El watchdog verifica que el SP est√© en un rango v√°lido (WRAM `0xC000-0xDFFF` o HRAM `0xFF80-0xFFFE`).
   - Si detecta corrupci√≥n, imprime un mensaje cr√≠tico con el valor de SP y el PC actual: `[CRITICAL] SP CORRUPTION DETECTED! SP:%04X at PC:%04X`.

**C√≥digo del Watchdog:**
```cpp
// --- Step 0267: SP CORRUPTION WATCHDOG ---
// El Stack Pointer debe estar siempre en RAM (C000-DFFF o FF80-FFFE)
// Si baja de C000 (y no es 0000 moment√°neo), algo ha ido terriblemente mal.
if (regs_->sp < 0xC000 && regs_->sp != 0x0000) {
    printf("[CRITICAL] SP CORRUPTION DETECTED! SP:%04X at PC:%04X\n", regs_->sp, regs_->pc);
}
```

**Verificaci√≥n de Instrucciones Relacionadas con SP:**
- **0x31 (LD SP, d16)**: ‚úÖ Implementada correctamente. Lee un valor de 16 bits en formato Little-Endian usando `fetch_word()` y lo asigna a SP.
- **0xF9 (LD SP, HL)**: ‚úÖ Implementada en Step 0268. Esta instrucci√≥n copia el valor de HL a SP.
- **0xE8 (ADD SP, r8)**: ‚úÖ Implementada en Step 0268. Esta instrucci√≥n suma un valor con signo de 8 bits a SP.
- **0xF8 (LD HL, SP+r8)**: ‚úÖ Implementada en Step 0268. Esta instrucci√≥n carga HL con SP + r8 (con signo).

**Concepto de Hardware:**
**El Stack Pointer (SP) en Game Boy**: El Stack Pointer es un registro de 16 bits que apunta a la ubicaci√≥n en memoria donde se almacena la pila (stack). La pila es una estructura de datos LIFO (Last In First Out) que se usa para:
- **Llamadas a subrutinas (CALL/RET)**: Guarda la direcci√≥n de retorno antes de saltar a una subrutina.
- **Interrupciones**: Guarda el estado de la CPU (PC) antes de saltar al vector de interrupci√≥n.
- **PUSH/POP**: Guarda y restaura valores de registros temporalmente.

**Rangos de Memoria V√°lidos para el Stack**: Seg√∫n el mapa de memoria de Game Boy, el Stack debe estar en:
- **WRAM (Work RAM)**: `0xC000-0xDFFF` - RAM interna de 8KB, escribible.
- **HRAM (High RAM)**: `0xFF80-0xFFFE` - RAM de alta velocidad de 127 bytes, escribible.

**¬øPor qu√© es fatal si SP apunta a la ROM?** Si el Stack Pointer apunta a la ROM (`0x0000-0x7FFF` o `0xA000-0xBFFF`), cualquier operaci√≥n de escritura (PUSH, CALL) intentar√° escribir en memoria de solo lectura. Como implementamos la protecci√≥n de ROM (Step 0252), esas escrituras se ignoran silenciosamente. Cuando la CPU ejecuta POP o RET, lee datos de la ROM (que son instrucciones, no direcciones de retorno v√°lidas). El resultado es que la CPU salta a una direcci√≥n basura y el programa se estrella.

**¬øC√≥mo se corrompe el SP?** El SP puede corromperse por varias razones:
- **Instrucci√≥n `LD SP, nn` con datos err√≥neos**: Si `nn` contiene basura o un valor incorrecto.
- **Instrucci√≥n `LD SP, HL` con HL corrupto**: Si HL contiene basura (`0x210A`), copiarlo a SP corrompe el stack.
- **Desbordamiento masivo de la pila**: Miles de PUSH sin POP correspondientes (poco probable en c√≥digo normal).
- **Error en aritm√©tica de SP**: Instrucciones como `ADD SP, r8` con resultados incorrectos.

**El Watchdog**: Un watchdog es un mecanismo de monitoreo que verifica continuamente una condici√≥n cr√≠tica. En este caso, verificamos despu√©s de cada instrucci√≥n que el SP est√© en un rango v√°lido. Si detectamos corrupci√≥n, imprimimos un mensaje cr√≠tico con el valor de SP y el PC donde ocurri√≥, permitiendo identificar la instrucci√≥n exacta que caus√≥ el problema.

**Fuente:** Pan Docs - "Memory Map", "Stack Pointer", "CALL/RET Instructions", "CPU Instruction Set"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregado watchdog de SP al final del m√©todo `step()` (Step 0267).

**Pr√≥ximos Pasos:**
- Ejecutar el emulador con Pok√©mon Red y buscar el mensaje cr√≠tico de corrupci√≥n de SP en los logs.
- Una vez detectada la corrupci√≥n, usar `tools/dump_rom_zone.py` alrededor del PC reportado para identificar la instrucci√≥n exacta que causa el problema.
- Implementar las instrucciones faltantes relacionadas con SP (0xF9, 0xE8, 0xF8) si el an√°lisis revela que el juego las est√° usando.
- Mejorar la verificaci√≥n del watchdog para validar expl√≠citamente los rangos WRAM y HRAM.

---

