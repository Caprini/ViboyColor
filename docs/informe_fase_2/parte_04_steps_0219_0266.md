# Bitácora de Desarrollo - Fase 2 (v0.0.2)

**Objetivo**: Migración del Núcleo a C++/Cython y Audio (APU).

**Estado**: En desarrollo.

---

## Objetivos Principales de la Fase 2

### 1. Migración del Núcleo a C++/Cython
- [ ] Reescritura de CPU (LR35902) en C++ con wrapper Cython
- [x] Migración de MMU a código compilado
- [x] Migración de PPU a código compilado (Fase A: Timing y Estado)
- [ ] Optimización de sincronización ciclo a ciclo
- [ ] Mantener interfaz Python para frontend y tests

### 2. Implementación de Audio (APU)
- [ ] Canal 1: Onda cuadrada con Sweep y Envelope
- [ ] Canal 2: Onda cuadrada con Envelope
- [ ] Canal 3: Onda arbitraria (Wave RAM)
- [ ] Canal 4: Ruido blanco (LFSR)
- [ ] Mezcla de canales y salida a 44100Hz/48000Hz
- [ ] Sincronización de audio con emulación (Dynamic Rate Control o Ring Buffer)

### 3. Mejoras de Arquitectura
- [x] Arquitectura híbrida Python/C++ establecida
- [ ] Gestión de memoria optimizada
- [ ] Tests híbridos (Python instancia Cython -> Cython llama C++)

---

## Entradas de Desarrollo


---

*Esta parte contiene Steps 219 a 266*

---

### 2025-12-23 - Step 0266: Análisis del Bucle de Pokémon (0x0564)
**Estado**: ✅ IMPLEMENTADO

Este Step analiza el bucle de espera en Pokémon Red usando la herramienta de desensamblado `tools/dump_rom_zone.py`. El Step 0265 implementó las interrupciones STAT por LYC, pero la pantalla sigue verde y el TileMap muestra `0x7F` (blanco). El GPS muestra que el PC está atrapado en un bucle entre `0x0564` y `0x056D`.

**Objetivo:**
- Mejorar la herramienta `tools/dump_rom_zone.py` para desensamblar correctamente todas las instrucciones en una región de la ROM.
- Analizar el código del bucle de espera en `0x0564-0x056D` para entender qué está esperando el juego.
- Determinar por qué el juego no avanza y qué condición está esperando.

**Implementación:**
1. **Modificado `tools/dump_rom_zone.py`**: 
   - Cambiados los valores por defecto para analizar la región `0x0560-0x0580` de Pokémon Red.
   - Añadido desensamblado instrucción por instrucción que muestra todas las instrucciones correctamente con sus operandos.
   - Mejorado el formato de salida para mostrar dirección, bytes y mnemónico completo con operandos decodificados.

**Resultados del Análisis:**
El desensamblado reveló el siguiente código en la región `0x0564-0x056D`:

```
0564 | 21 60 CD     | LD HL, 0xCD60
0567 | CB D6        | SET 2, (HL)    ; Establece bit 2 de (0xCD60)
0569 | 21 4B CC     | LD HL, 0xCC4B
056C | 35           | DEC (HL)       ; Decrementa byte en (0xCC4B)
056D | 20 F5        | JR NZ, 0x0564  ; Si no es cero, vuelve a 0564
```

**Interpretación del Bucle:**
1. `0x0564`: Carga `HL` con `0xCD60` (dirección en RAM).
2. `0x0567`: `CB D6` = `SET 2, (HL)` - Establece el bit 2 de la dirección `0xCD60`.
3. `0x0569`: Carga `HL` con `0xCC4B` (dirección en RAM).
4. `0x056C`: Decrementa el byte en la dirección `0xCC4B`.
5. `0x056D`: Si el resultado no es cero, salta de vuelta a `0x0564`.

**Observaciones Críticas:**
- **NO hay HALT**: El bucle es activo (polling), no espera interrupciones.
- **NO hay lectura de LY**: No está esperando V-Blank manualmente leyendo `0xFF44`.
- **NO hay DI/EI**: No cambia IME en esta zona.
- **Hay un contador en 0xCC4B**: El bucle decrementa un contador hasta que llegue a 0.

**Hipótesis:**
El bucle está esperando que el contador en `0xCC4B` llegue a 0. Este contador probablemente se inicializa en algún lugar del código y se decrementa en una ISR (Interrupt Service Routine). Si `IME=0`, la ISR nunca se ejecuta, el contador nunca se decrementa, y el bucle se queda atrapado esperando que el contador llegue a 0.

**Direcciones importantes:**
- **0xCD60**: Se establece el bit 2. Podría ser un registro de hardware o una variable de estado.
- **0xCC4B**: Contador que se decrementa. Probablemente se inicializa en otro lugar y se decrementa en una ISR.

**Concepto de Hardware:**
**Bucles de Espera en Game Boy**: Los juegos de Game Boy usan diferentes técnicas para esperar eventos:
- **HALT**: La CPU entra en estado de bajo consumo y espera una interrupción. Eficiente pero requiere IME activo.
- **Polling Activo**: La CPU ejecuta un bucle que verifica constantemente una condición (ej: lectura de registro, contador en RAM). Menos eficiente pero funciona incluso con IME=0.
- **Espera de V-Blank Manual**: El juego lee el registro LY (0xFF44) y espera hasta que sea 144 (V-Blank). No requiere interrupciones.

**El caso de Pokémon Red**: El GPS muestra `IME:0`, `IE:0D`, `IF:01`, lo que indica que hay una interrupción V-Blank pendiente pero IME está desactivado. Si el juego está en un bucle de espera activo (polling), está verificando alguna condición que nunca se cumple porque las interrupciones no se están procesando.

**Fuente:** Pan Docs - "Interrupts", "HALT Instruction", "LCD Y-Coordinate (LY)"

**Archivos Afectados:**
- `tools/dump_rom_zone.py` - Mejorado desensamblado instrucción por instrucción y cambiados valores por defecto para analizar el bucle de Pokémon Red (Step 0266).

**Próximos Pasos:**
- Instrumentar la lectura/escritura de `0xCC4B` para ver qué valor tiene y si se está actualizando.
- Buscar dónde se inicializa el contador en `0xCC4B` (probablemente antes del bucle).
- Buscar dónde se decrementa el contador (probablemente en una ISR de V-Blank o Timer).
- Verificar qué hay en `0xCD60` y por qué se establece el bit 2.
- Investigar si el problema es que `IME` nunca se activa o si hay otro problema con las interrupciones.

---

### 2025-12-23 - Step 0265: LYC Coincidence & STAT IRQ Fix
**Estado**: ✅ IMPLEMENTADO

Este Step implementa y corrige la lógica de comparación LYC (LY Compare) y la generación de interrupciones STAT en la PPU. El Step 0264 confirmó que el HALT funciona correctamente, pero la intro de Pokémon Red sigue sin avanzar. La hipótesis es que el juego está esperando una interrupción LCD STAT (por coincidencia LY=LYC) para sincronizar efectos visuales o avanzar la lógica, y nuestra PPU no la está disparando correctamente.

**Objetivo:**
- Interceptar escrituras a LYC (0xFF45) en MMU para actualizar la PPU inmediatamente.
- Mejorar la detección de rising edge para interrupciones STAT por LYC.
- Asegurar que cuando LY coincide con LYC y el bit 6 de STAT está habilitado, se solicite la interrupción STAT en el flanco de subida (rising edge).

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp` (Método `write`)**: 
   - Añadida interceptación para escrituras a 0xFF45 (LYC) que actualiza la PPU inmediatamente llamando a `PPU::set_lyc()`.
   - Esto asegura que cuando el juego configura LYC, la PPU puede verificar inmediatamente si LY == LYC y actualizar el bit 2 de STAT.

2. **Modificado `src/core/cpp/PPU.cpp` (Método `step`)**: 
   - Mejorada la lógica de detección de rising edge para LYC. Cuando LY cambia, se guarda el estado anterior de LYC match, se actualiza LY, y se verifica inmediatamente si hay un rising edge (LYC match pasó de False a True).
   - Si el bit 6 de STAT está habilitado, se solicita la interrupción STAT inmediatamente.
   - Se preserva el estado de LYC en `stat_interrupt_line_` cuando LY cambia, permitiendo detectar correctamente el rising edge en la próxima verificación.

**Concepto de Hardware:**
**LYC Register (0xFF45)**: El registro LYC (LY Compare) permite al software configurar un valor de línea (0-255) con el que se compara LY (Línea actual). Cuando LY == LYC, el bit 2 del registro STAT se activa, indicando una coincidencia.

**STAT Register (0xFF41)**: El registro STAT tiene varios bits importantes:
- **Bit 2 (LYC=LY Coincidence Flag)**: Se activa cuando LY == LYC. Es de solo lectura y se actualiza dinámicamente por la PPU.
- **Bit 6 (LYC Interrupt Enable)**: Si está activo, solicita una interrupción STAT cuando LY == LYC.
- **Bits 3-5**: Habilitan interrupciones por modo PPU (H-Blank, V-Blank, OAM Search).

**Rising Edge Detection**: La interrupción STAT solo debe dispararse en el flanco de subida (rising edge), es decir, cuando la condición pasa de False a True. Si se dispara en cada ciclo donde la condición es True, se saturaría la CPU con interrupciones.

**El caso de Pokémon Red**: Muchos juegos avanzados como Pokémon usan la interrupción STAT por LYC para sincronizar efectos visuales (cambiar paletas en medio de la pantalla, efectos de raster, etc.). Si esta interrupción no se dispara correctamente, el juego puede quedarse esperando y no avanzar.

**Fuente:** Pan Docs - "LCD Status Register (STAT)", "LYC Register (0xFF45)", "LCD Interrupts"

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Interceptación de escrituras a LYC (0xFF45) para actualizar la PPU (Step 0265).
- `src/core/cpp/PPU.cpp` - Mejora de la detección de rising edge para LYC en `step()` (Step 0265).

**Decisiones de Diseño:**
- **Verificación inmediata después de cambiar LY**: Cuando LY cambia, se verifica inmediatamente si LY == LYC y si debe dispararse la interrupción. Esto asegura que el rising edge se detecte en el momento exacto en que ocurre, no más tarde.
- **Preservación del estado de LYC en stat_interrupt_line_**: Cuando LY cambia, se preserva el bit 0 de `stat_interrupt_line_` si LYC match sigue activo, y se limpia si está inactivo. Los bits de modo (1-3) se limpian porque el modo cambió. Esto permite detectar correctamente el rising edge en la próxima verificación.
- **Interceptación de LYC en MMU**: La MMU intercepta escrituras a 0xFF45 y actualiza la PPU inmediatamente. Esto asegura que cuando el juego configura LYC, la PPU puede verificar inmediatamente si LY == LYC y actualizar el bit 2 de STAT.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb`
- Observar el comportamiento:
  - **Si la intro avanza**: La corrección funciona correctamente. La interrupción STAT por LYC se está disparando correctamente.
  - **Si la pantalla sigue estática**: Puede haber otro problema (posiblemente en el Timer o en otras fuentes de interrupciones).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar si la intro avanza.
- Si la intro avanza, confirmar que la corrección funciona correctamente.
- Si la pantalla sigue estática, investigar otras fuentes de interrupciones (Timer, Serial) o el estado de IME.

---

### 2025-12-23 - Step 0264: HALT Wakeup Fix (IME=0)
**Estado**: ✅ IMPLEMENTADO

Este Step revisa y corrige la lógica de despertar de HALT en la CPU. El Step 0263 confirmó que el Tile Map contiene datos válidos (tile 0x7F), pero la pantalla sigue estática. El GPS muestra `IME:0`, `IE:0D`, `IF:01`, lo que indica que hay una interrupción V-Blank pendiente pero la CPU no la está atendiendo porque IME está desactivado.

**Objetivo:**
- Revisar y corregir la lógica de despertar de HALT cuando IME=0.
- Asegurar que la CPU se despierte de HALT cuando hay una interrupción pendiente habilitada, incluso si IME está desactivado.
- Permitir que el juego continúe su ejecución incluso cuando IME=0.

**Implementación:**
1. **Modificado `src/core/cpp/CPU.cpp` (Método `handle_interrupts`)**: 
   - Mejorados los comentarios para explicar claramente que la CPU debe despertar de HALT cuando hay una interrupción pendiente habilitada, incluso si IME=0.
   - La lógica ya estaba correcta, pero ahora está mejor documentada según Pan Docs.
   - Comentarios añadidos: "Según Pan Docs, cuando IME=0 y hay una interrupción pendiente habilitada en IE: 1. La CPU DEBE SALIR DE HALT (despertar). 2. Pero NO salta al vector de interrupción (porque IME=0). 3. Simplemente continúa la ejecución en la siguiente instrucción."

**Concepto de Hardware:**
**HALT Instruction**: La instrucción HALT pone la CPU en estado de bajo consumo. La CPU deja de ejecutar instrucciones hasta que ocurre una interrupción o se despierta manualmente.

**Comportamiento de HALT con IME=0**: Según Pan Docs, cuando IME=0 y hay una interrupción pendiente habilitada en IE:
1. La CPU DEBE SALIR DE HALT (despertar).
2. Pero NO salta al vector de interrupción (porque IME=0).
3. Simplemente continúa la ejecución en la siguiente instrucción.

**El problema del "HALT Bug"**: Si la CPU se queda en HALT eternamente porque IME=0, el juego se congela esperando que la interrupción ocurra. Esto es especialmente problemático en juegos que usan HALT para esperar V-Blank, ya que si IME nunca se activa, la CPU nunca despierta y el juego se queda congelado.

**El caso de Pokémon Red**: El GPS muestra `IME:0`, `IE:0D`, `IF:01`, lo que indica que hay una interrupción V-Blank pendiente (`IF:01`) y está habilitada en IE (`IE:0D` tiene el bit 0 activo). Si el juego está en HALT esperando V-Blank, la CPU debe despertar incluso si IME=0, permitiendo que el juego continúe su ejecución.

**Fuente:** Pan Docs - "HALT Instruction", "Interrupts", "IME (Interrupt Master Enable)"

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Mejorados comentarios en método `handle_interrupts()` para explicar el comportamiento de despertar de HALT cuando IME=0 (Step 0264).

**Decisiones de Diseño:**
- **Despertar de HALT independiente de IME**: La CPU debe despertar de HALT si hay CUALQUIER interrupción pendiente habilitada en IE, independientemente del estado de IME. Esto permite que el juego continúe su ejecución incluso si IME está desactivado.
- **No saltar al vector si IME=0**: Si IME es false, la CPU no consume ciclos extra ni salta al vector de interrupción. Simplemente continúa la ejecución normal (HALT termina).
- **Comentarios mejorados**: Se añadieron comentarios detallados explicando el comportamiento según Pan Docs, incluyendo referencias a la documentación oficial.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon Red es ideal porque usa HALT para esperar V-Blank).
- Observar el comportamiento:
  - **Si la animación avanza**: La corrección funciona correctamente. La CPU está despertando de HALT cuando hay interrupciones pendientes, incluso si IME=0.
  - **Si la pantalla sigue estática**: Puede haber otro problema (posiblemente en el renderizado de sprites o en la lógica de actualización de frames).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar si la animación avanza.
- Si la animación avanza, confirmar que la corrección funciona correctamente.
- Si la pantalla sigue estática, investigar otros problemas potenciales (renderizado de sprites, lógica de actualización de frames, etc.).

---

### 2025-12-23 - Step 0263: Tile Map Inspector
**Estado**: ✅ IMPLEMENTADO

Este Step instrumenta la PPU para inspeccionar el Tile Map que se está utilizando durante el renderizado. El Step 0262 confirmó que MBC1 funciona perfectamente y que la ROM se lee correctamente, pero la pantalla sigue vacía. La hipótesis es que hay un desajuste en la configuración de la PPU (Tile Map vs Tile Data) o que el Tile Map está vacío.

**Objetivo:**
- Instrumentar la PPU para inspeccionar el Tile Map que se está utilizando durante el renderizado.
- Verificar si el área de memoria que la PPU está usando como Tile Map contiene índices de tiles válidos o está completamente vacía.
- Distinguir entre desajuste en la configuración de la PPU vs Tile Map vacío.

**Implementación:**
1. **Modificado `src/core/cpp/PPU.cpp` (Método `render_scanline`)**: 
   - Añadido código de inspección que se ejecuta una sola vez cuando LY=100 (mitad de pantalla).
   - El inspector muestra el valor de LCDC, la dirección base del Tile Map, la dirección base de Tile Data, y los primeros 16 bytes del Tile Map.
   - Formato de log: `[PPU INSPECT] LCDC: XX`, `[PPU INSPECT] BG Map Base: XXXX`, `[PPU INSPECT] BG Data Base: XXXX`, `[PPU INSPECT] First 16 bytes of Map at XXXX: ...`

2. **Modificado `src/core/cpp/MMU.cpp`**:
   - Comentados los logs de diagnóstico `[VRAM]`, `[ROM-READ]` y `[MBC1]` (cambio de banco) para reducir el ruido en la salida.
   - El log crítico de `[MBC1 CRITICAL]` se mantiene activo para detectar errores graves.

**Concepto de Hardware:**
**Tile Map (Mapa de Tiles)**: El Tile Map es una tabla de 32x32 bytes (1024 bytes) que contiene los índices de los tiles que se deben dibujar en cada posición del fondo. La PPU lee el Tile Map para determinar qué tile dibujar en cada posición de la pantalla.

**Configuración de Tile Map**: El registro LCDC (0xFF40) controla qué área de VRAM se usa como Tile Map:
- **Bit 3**: Background Tile Map Area (`0=9800`, `1=9C00`).
- **Bit 4**: Background & Window Tile Data Area (`0=8800`, `1=8000`).

**El problema del desajuste**: Si el juego usa el mapa en `9C00` pero nosotros miramos en `9800` (o viceversa), veremos blanco. Si el juego usa tiles en `8000` pero nosotros usamos `8800` (signed), veremos basura o blanco. Si el Tile Map está completamente vacío (todos los bytes son `00`), la PPU renderizará solo el tile 0, que puede ser blanco o transparente.

**La inspección del Tile Map**: Para diagnosticar el problema, necesitamos verificar qué contiene realmente el Tile Map que la PPU está utilizando. Si todos los bytes son `00`, el mapa está vacío y no se ha copiado el mapa. Si hay bytes variados, el mapa tiene datos y deberíamos ver algo en pantalla.

**Fuente:** Pan Docs - "LCD Control (LCDC)", "Tile Map", "Tile Data"

**Archivos Afectados:**
- `src/core/cpp/PPU.cpp` - Modificado método `render_scanline()` para inspeccionar el Tile Map (Step 0263).
- `src/core/cpp/MMU.cpp` - Comentados logs de diagnóstico `[VRAM]`, `[ROM-READ]` y `[MBC1]` para reducir ruido (Step 0263).

**Decisiones de Diseño:**
- **Inspección única**: El inspector se ejecuta una sola vez cuando LY=100 usando un flag estático `map_inspected`. Esto evita saturar los logs con información repetida y permite ver el estado del Tile Map después de que el juego haya tenido tiempo de inicializarse.
- **Información completa**: El inspector muestra LCDC (para ver la configuración), las direcciones base del Tile Map y Tile Data (para verificar qué áreas se están usando), y los primeros 16 bytes del Tile Map (para ver si contiene datos o está vacío).
- **Limpieza de logs**: Se comentaron los logs de diagnóstico anteriores para reducir el ruido en la salida y permitir ver claramente el log del inspector. El log crítico de `[MBC1 CRITICAL]` se mantiene activo.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon Red es ideal porque tiene 1024KB de ROM y necesita múltiples bancos).
- Observar los logs:
  - Buscar `[PPU INSPECT]` - Muestra la configuración de la PPU y los primeros 16 bytes del Tile Map.
  - **Si los bytes del mapa son todos `00`**: El mapa está vacío -> No se ha copiado el mapa. El juego puede estar limpiando la VRAM antes de copiar los datos, o puede haber un problema en la lógica de copia de datos a VRAM.
  - **Si los bytes son variados**: El mapa tiene datos -> Deberíamos ver algo en pantalla. Si la pantalla sigue vacía, el problema está en otro lado (posiblemente en el renderizado de la PPU o en la configuración de Tile Data).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar el log del inspector.
- Si el Tile Map está vacío, verificar por qué el juego no está copiando el mapa a la VRAM o esperar más tiempo.
- Si el Tile Map contiene datos pero la pantalla sigue vacía, verificar la configuración de Tile Data o el renderizado de la PPU.

---

### 2025-12-23 - Step 0262: ROM Read Probe
**Estado**: ✅ IMPLEMENTADO

Este Step instrumenta el método `MMU::read()` para monitorear las lecturas en el área de ROM conmutada (`0x4000-0x7FFF`). El Step 0261 confirmó que MBC1 funciona (vemos cambios de banco), pero las escrituras en VRAM siguen siendo ceros. La hipótesis es que `MMU::read()` podría estar devolviendo ceros al leer del banco conmutado, a pesar de que el cambio de banco se registra correctamente.

**Objetivo:**
- Instrumentar las lecturas del área de ROM conmutada para verificar qué valores está devolviendo realmente la MMU.
- Distinguir entre dos casos: el juego está limpiando la VRAM intencionalmente, o la lectura del banco conmutado devuelve ceros.
- Correlacionar las lecturas ROM con las escrituras en VRAM para determinar si los datos correctos están llegando.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp` (Método `read`)**: 
   - Añadido contador estático `rom_read_counter` para limitar los logs a las primeras 50 lecturas (evitando saturar la salida).
   - El log se imprime después de calcular el offset pero antes de devolver el valor, mostrando exactamente qué está leyendo el juego y qué valor se está devolviendo.
   - Formato de log: `[ROM-READ] PC:XXXX -> Read ROM[YYYY] (Bank N, Offset ZZZZ) = VV`

**Concepto de Hardware:**
**Lectura de ROM conmutada**: Cuando un juego necesita acceder a datos almacenados en bancos ROM distintos del banco 0, primero selecciona el banco escribiendo en `0x2000-0x3FFF`, y luego lee desde `0x4000-0x7FFF`. El MBC1 mapea el banco seleccionado a este espacio de memoria, permitiendo que el juego acceda a hasta 16KB de datos del banco elegido.

**El problema de los ceros en VRAM**: Si el juego cambia de banco correctamente (vemos logs de cambio en el Step 0261), pero las escrituras en VRAM siguen siendo ceros, hay dos posibilidades:
1. El juego está limpiando la VRAM intencionalmente antes de copiar los gráficos reales.
2. La lectura del banco conmutado devuelve ceros, lo que indica un fallo en la carga de ROM o en el cálculo de offset.

**La sonda de lectura ROM**: Para distinguir entre estos casos, necesitamos verificar qué valor está devolviendo realmente `MMU::read()` cuando el juego lee desde el área conmutada. Si devuelve ceros (o `0xFF`), nuestra lógica de lectura de `rom_data_` está fallando. Si devuelve valores variados (`0x3E`, `0xCD`, etc.), entonces la lectura es correcta y el problema está en otro lado.

**Fuente:** Pan Docs - "MBC1", "Memory Bank Controllers", "Memory Map"

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Modificado método `read()` para loguear las primeras 50 lecturas del área de ROM conmutada (Step 0262).

**Decisiones de Diseño:**
- **Límite de 50 lecturas**: Para evitar saturar los logs con miles de lecturas, limitamos el registro a las primeras 50. Esto es suficiente para verificar si la lectura está funcionando correctamente durante la inicialización del juego.
- **Información completa en el log**: El log incluye el PC actual, la dirección leída, el banco actual, el offset calculado en `rom_data_`, y el valor devuelto. Esto nos permite verificar si el cálculo de offset es correcto y si el valor devuelto corresponde a los datos reales de la ROM.
- **Log después del cálculo de offset**: El log se imprime después de calcular el offset pero antes de devolver el valor, asegurando que vemos exactamente qué valor se está devolviendo al juego.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon Red es ideal porque tiene 1024KB de ROM y necesita múltiples bancos).
- Observar los logs:
  - Buscar `[ROM-READ] PC:XXXX -> Read ROM[YYYY] (Bank N, Offset ZZZZ) = VV` - Muestra qué está leyendo el juego y qué valor se está devolviendo.
  - **Si Val = 00**: La lectura está devolviendo ceros, lo que indica un fallo en la carga de ROM o en el cálculo de offset. El vector `rom_data_` podría estar vacío o el offset calculado podría estar fuera de rango.
  - **Si Val variados (3E, CD, etc.)**: La lectura es correcta y está devolviendo datos reales de la ROM. En este caso, si la VRAM sigue vacía, el problema está en otro lado (posiblemente en la lógica de copia de datos a VRAM o en el timing).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar los logs de lectura ROM.
- Si las lecturas devuelven ceros, verificar la carga de ROM y el cálculo de offset.
- Si las lecturas devuelven valores variados, verificar la lógica de copia de datos a VRAM o el timing.
- Correlacionar las lecturas ROM con las escrituras en VRAM para determinar si los datos correctos están llegando a la VRAM.

---

### 2025-12-23 - Step 0261: MBC Activity Monitor
**Estado**: ✅ IMPLEMENTADO

Este Step instrumenta el código MBC1 implementado en el Step 0260 para monitorear cambios de banco ROM y detectar intentos de lectura fuera de rango. El objetivo es confirmar si el juego está seleccionando bancos de ROM correctamente y si nuestra MMU está respondiendo adecuadamente.

**Objetivo:**
- Instrumentar cambios de banco ROM para diagnosticar si el juego está seleccionando bancos correctamente.
- Detectar intentos de lectura fuera de rango en el espacio ROM para identificar errores en el cálculo de offset.
- Correlacionar cambios de banco con las escrituras en VRAM para determinar si los datos correctos están llegando.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp` (Método `write`)**: 
   - Modificado para comparar el banco nuevo con el banco actual antes de loguear.
   - Solo se registra cuando hay un cambio real de banco (evita saturar logs con escrituras repetidas).
   - Formato de log: `[MBC1] PC:XXXX -> ROM Bank Switch: N -> M`

2. **Modificado `src/core/cpp/MMU.cpp` (Método `read`)**:
   - Añadido log crítico cuando se intenta leer desde un offset que excede el tamaño de la ROM cargada.
   - Formato de log: `[MBC1 CRITICAL] Intento de lectura fuera de ROM! Offset: X, Size: Y, Bank: Z, Addr: 0xWWWW`

**Concepto de Hardware:**
**MBC1 Banking Activity**: Cuando un juego necesita acceder a datos gráficos, código o recursos almacenados en bancos ROM distintos del banco 0, primero debe seleccionar el banco correcto escribiendo en `0x2000-0x3FFF`. Si el juego intenta cambiar de banco pero el MBC no responde, el juego leerá datos incorrectos (posiblemente ceros o basura) y copiará esos datos a la VRAM, resultando en una pantalla vacía.

**Diagnóstico de Integridad**: Si implementamos MBC1 pero los logs de VRAM siguen mostrando ceros, necesitamos saber:
1. ¿El juego está intentando cambiar de banco? (Si no vemos logs de cambio, el juego puede estar fallando antes de llegar ahí).
2. ¿La lectura desde el banco seleccionado está funcionando? (Si vemos cambios de banco pero lecturas fuera de rango, hay un error en el cálculo de offset).

**Fuente:** Pan Docs - "MBC1", "Memory Bank Controllers", "Cartridge Types"

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Modificado método `write()` para loguear cambios de banco ROM solo cuando cambian (Step 0261). Modificado método `read()` para loguear intentos de lectura fuera de rango (Step 0261).

**Decisiones de Diseño:**
- **Log condicional de cambios de banco**: Solo logueamos cuando el banco realmente cambia, evitando saturar los logs con escrituras repetidas al mismo banco.
- **Log crítico de lecturas fuera de rango**: Detecta errores en el cálculo de offset o validación de bancos que resultarían en datos inválidos.
- **Formato de log con PC**: Los logs incluyen el Program Counter actual para correlacionar los cambios de banco con las instrucciones del juego que los provocan.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon Red es ideal porque tiene 1024KB de ROM y necesita múltiples bancos).
- Observar los logs:
  - Buscar `[MBC1] PC:XXXX -> ROM Bank Switch: N -> M` - Confirma que el juego está cambiando bancos.
  - Si ves cambios de banco (ej: `1 -> 2`, `2 -> 6`), el juego está intentando acceder a datos de diferentes bancos.
  - Si **NO** ves cambios, el juego puede estar fallando antes de llegar a la selección de bancos, o puede estar usando un cartucho sin MBC.
  - Buscar `[MBC1 CRITICAL]` - Indica que hay un error en el cálculo de offset o que el banco seleccionado excede el tamaño de la ROM.

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar los logs de cambio de banco.
- Si vemos cambios de banco, verificar que los datos leídos desde esos bancos sean correctos (no ceros).
- Si no vemos cambios de banco, investigar por qué el juego no llega a la selección de bancos.
- Si vemos logs críticos de lecturas fuera de rango, corregir el cálculo de offset o la validación de bancos.

---

### 2025-12-23 - Step 0260: MBC1 ROM Banking
**Estado**: ✅ IMPLEMENTADO

Este Step implementa soporte básico de MBC1 (Memory Bank Controller 1) en la MMU de C++ para permitir que los juegos grandes (>32KB) accedan a sus bancos de ROM. El diagnóstico del Step 0259 confirmó que Pokémon Red estaba escribiendo ceros en VRAM porque intentaba leer gráficos de bancos ROM no mapeados. Con MBC1 implementado, los juegos pueden seleccionar bancos de ROM y leer los datos correctos.

**Objetivo:**
- Implementar soporte básico de MBC1 para cartuchos grandes (>32KB).
- Permitir que los juegos seleccionen bancos de ROM escribiendo en `0x2000-0x3FFF`.
- Mapear correctamente el espacio `0x4000-0x7FFF` al banco seleccionado.
- Resolver el problema de VRAM vacía causado por lectura de bancos ROM no mapeados.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.hpp`**:
   - Añadido miembro `std::vector<uint8_t> rom_data_` para almacenar el cartucho ROM completo.
   - Añadido miembro `uint8_t current_rom_bank_` para rastrear el banco ROM actualmente seleccionado.

2. **Modificado `src/core/cpp/MMU.cpp` (Constructor)**:
   - Inicializado `current_rom_bank_ = 1` en el constructor.

3. **Modificado `src/core/cpp/MMU.cpp` (Método `load_rom`)**:
   - Modificado para cargar toda la ROM en `rom_data_` en lugar de solo 32KB.
   - También copiar el banco 0 (primeros 16KB) a `memory_[0x0000-0x3FFF]` para compatibilidad.

4. **Modificado `src/core/cpp/MMU.cpp` (Método `read`)**:
   - Añadida lógica para leer del banco correcto según la dirección:
     - `0x0000-0x3FFF`: Siempre mapea al Banco 0 (fijo).
     - `0x4000-0x7FFF`: Mapea al banco seleccionado (`current_rom_bank_`).

5. **Modificado `src/core/cpp/MMU.cpp` (Método `write`)**:
   - Añadida lógica para interceptar escrituras en `0x2000-0x3FFF` y cambiar el banco ROM.
   - Validación de que el banco no exceda el tamaño de la ROM.
   - Log de diagnóstico limitado a las primeras 10 veces.

**Concepto de Hardware:**
**MBC1 (Memory Bank Controller 1)**: Los cartuchos grandes (>32KB) usan MBC1 para intercambiar bancos de ROM. El espacio `0x0000-0x3FFF` siempre mapea al Banco 0 (fijo), pero el espacio `0x4000-0x7FFF` puede mapear a diferentes bancos (1, 2, 3, etc.) escribiendo en registros especiales del MBC.

**MBC1 Banking Control**: El MBC1 controla el cambio de bancos mediante escrituras en el rango de ROM (que normalmente es de solo lectura):
- **0x2000-0x3FFF**: Selección de banco ROM. El valor escrito (bits 0-4) selecciona el banco que aparecerá en `0x4000-0x7FFF`. Nota: El banco 0 se trata como banco 1.
- **0x0000-0x1FFF**: Habilitación/deshabilitación de RAM externa (ignorado en esta implementación básica).

**Problema Resuelto**: Pokémon Red (1024KB ROM) intentaba copiar gráficos desde el banco 2, 3, etc., pero nuestra MMU solo tenía mapeado el banco 0. El juego leía ceros o basura, y copiaba esos ceros a la VRAM, resultando en una pantalla verde. Con MBC1, el juego puede seleccionar el banco correcto y leer los datos gráficos reales.

**Fuente:** Pan Docs - "MBC1", "Memory Bank Controllers", "Cartridge Types", "Memory Map"

**Archivos Afectados:**
- `src/core/cpp/MMU.hpp` - Añadidos miembros `rom_data_` y `current_rom_bank_` para soportar MBC1 (Step 0260).
- `src/core/cpp/MMU.cpp` - Modificado constructor, `load_rom()`, `read()` y `write()` para implementar MBC1 básico (Step 0260).

**Decisiones de Diseño:**
- **Almacenamiento completo de ROM**: Se almacena toda la ROM en `rom_data_` para permitir acceso a cualquier banco, no solo los primeros 32KB.
- **Compatibilidad con código existente**: El banco 0 también se copia a `memory_[0x0000-0x3FFF]` para mantener compatibilidad con código que accede directamente a `memory_`.
- **Validación de bancos**: Se valida que el banco seleccionado no exceda el tamaño de la ROM para evitar accesos fuera de rango.
- **Log limitado**: El log de cambio de bancos se limita a las primeras 10 veces para no saturar la salida.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon Red es ideal porque tiene 1024KB de ROM y necesita MBC1).
- Observar el log:
  - `[MBC1] ROM loaded: X bytes (Y banks)` - Confirma que la ROM se cargó correctamente.
  - `[MBC1] PC:XXXX -> ROM Bank changed to N` - Confirma que el juego está cambiando bancos.
  - `[VRAM] PC:XXXX -> Write VRAM [XXXX] = XX` - Los valores deberían ser distintos de `00` ahora.
- Observación Visual: Si MBC1 funciona correctamente, deberías ver gráficos en pantalla (con la paleta de debug activa).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y verificar que los gráficos aparecen en pantalla.
- Si los gráficos aparecen, confirmamos que MBC1 funciona correctamente.
- Si hay problemas, verificar que el banco seleccionado no exceda el tamaño de la ROM y que el cálculo del offset del banco es correcto.

### 2025-12-23 - Step 0259: VRAM Write Monitor & MBC Check
**Estado**: ✅ IMPLEMENTADO

Este Step instrumenta la MMU para monitorear las escrituras en VRAM y analiza la lógica de lectura de ROM para confirmar si hay soporte de MBC (Memory Bank Controllers). El objetivo es determinar si la VRAM está vacía porque el juego intenta leer gráficos de bancos ROM no mapeados, lo que explicaría por qué la CPU copia ceros a la VRAM.

**Objetivo:**
- Añadir un monitor de escrituras en VRAM para ver qué datos está copiando la CPU.
- Analizar la lógica de lectura de ROM para confirmar si hay soporte de MBC.
- Determinar si la VRAM está vacía porque el juego intenta leer gráficos de bancos ROM no mapeados.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp` (Método `write`)**:
   - Añadido monitor específico para el rango de VRAM (`0x8000` - `0x9FFF`) que registra las primeras 50 escrituras.
   - El monitor registra: PC (Program Counter), dirección de VRAM, y valor escrito.
   - Si los valores son todos `00`, la CPU está copiando ceros (confirma teoría de MBC roto).
   - Si los valores son `FF` o variados, hay datos (el problema vuelve a ser la PPU).

2. **Modificado `src/core/cpp/MMU.cpp` (Método `read`)**:
   - Añadido comentario crítico que documenta la falta de soporte de MBC.
   - Explica que la ROM se carga de forma plana en `memory_[0x0000-0x7FFF]` mediante `load_rom()`.
   - Para juegos grandes (>32KB), solo se carga el banco 0. Si el juego intenta cambiar de banco, leerá basura o ceros.

**Concepto de Hardware:**
**VRAM (Video RAM)**: La VRAM en la Game Boy ocupa el rango `0x8000-0x9FFF` (8KB) y contiene:
- **Tile Data (0x8000-0x97FF)**: Datos de los tiles (gráficos) que se usan para renderizar el fondo y los sprites.
- **Tile Map (0x9800-0x9FFF)**: Mapas de tiles que indican qué tile se dibuja en cada posición del fondo.

**MBC (Memory Bank Controllers)**: Los cartuchos de Game Boy pueden tener diferentes tamaños de ROM:
- **ROM ONLY (32KB)**: Cabe entero en el espacio de direcciones `0x0000-0x7FFF`. No necesita MBC.
- **MBC1/MBC3 (>32KB)**: Usan un Memory Bank Controller para intercambiar bancos de ROM. El espacio `0x0000-0x3FFF` siempre mapea al Banco 0, pero el espacio `0x4000-0x7FFF` puede mapear a diferentes bancos (1, 2, 3, etc.) escribiendo en registros especiales del MBC.

**Problema Crítico**: Si nuestro emulador C++ (`MMU.cpp`) **NO** implementa MBC1/MBC3, el juego intenta leer gráficos del Banco X, pero lee el Banco 1 (o basura), o ceros. La CPU copia esos "ceros" a la VRAM. Resultado: Pantalla Verde.

**Fuente:** Pan Docs - "Memory Bank Controllers", "Cartridge Types", "Memory Map", "VRAM"

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Modificado el método `write()` para añadir monitor de escrituras en VRAM (Step 0259).
- `src/core/cpp/MMU.cpp` - Modificado el método `read()` para añadir comentario sobre falta de soporte de MBC (Step 0259).

**Decisiones de Diseño:**
- **Monitor limitado a 50 escrituras**: Se limita a las primeras 50 escrituras para no saturar el log. Esto es suficiente para ver si la CPU está copiando ceros o datos reales.
- **Incluir PC en el log**: Se incluye el Program Counter para saber desde dónde escribe el juego (probablemente una rutina de copia `LDI` o `LD`).
- **Documentación de MBC**: Se añadió un comentario crítico que documenta la falta de soporte de MBC, explicando por qué la VRAM puede estar vacía.

**Validación:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/pkmn.gb` (Pokémon es ideal porque sabemos que intenta dibujar).
- Observar los logs de `[VRAM]`:
  - **¿Ves logs de `[VRAM]`?** Si no, la CPU no está escribiendo en VRAM (problema más grave).
  - **Mira los valores (`Val`)**: Si son `00`, la CPU está copiando ceros (confirma teoría de MBC roto). Si son `FF` o variados, hay datos (el problema vuelve a ser la PPU).
  - **Mira el `PC`**: ¿Desde dónde escribe? (Probablemente una rutina de copia `LDI` o `LD`).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar los valores que se escriben en VRAM.
- Si todos son `00`: Confirmar que la CPU está copiando ceros, lo que sugiere un problema de MBC.
- Si confirmamos que el problema es MBC: Implementar soporte básico de MBC1/MBC3 en la MMU para permitir que los juegos grandes carguen gráficos desde bancos superiores.

### 2025-12-23 - Step 0258: VRAM Vital Signs (VRAM Sum)
**Estado**: ✅ IMPLEMENTADO

Este Step añade un diagnóstico de integridad de VRAM en el monitor GPS de `src/viboy.py`. Calculamos la suma de bytes de la VRAM (muestreo cada 16 bytes) para determinar si contiene gráficos o está completamente vacía. Si la VRAM está llena de ceros, la PPU renderizará píxeles de índice 0 (verdes/blancos), funcionando "correctamente" sobre datos vacíos.

**Objetivo:**
- Añadir un diagnóstico de VRAM en el monitor GPS para calcular la suma de bytes de la VRAM.
- Determinar si la VRAM está completamente vacía (suma = 0) o contiene datos (suma > 0).
- Distinguir entre problemas de VRAM vacía (CPU/DMA no copia gráficos) y problemas de PPU (VRAM contiene datos pero no se renderizan).

**Implementación:**
1. **Modificado `src/viboy.py`**: 
   - Añadido código en el monitor GPS (Step 0240) para calcular la suma de bytes de la VRAM usando un muestreo cada 16 bytes (rango `0x8000-0xA000`).
   - El diagnóstico se ejecuta una vez por segundo (cada 60 frames), igual que el resto del monitor GPS.
   - Se añadió tanto en el bloque de C++ como en el bloque de Python (fallback).

**Concepto de Hardware:**
**VRAM (Video RAM)**: La VRAM en la Game Boy ocupa el rango `0x8000-0x9FFF` (8KB) y contiene:
- **Tile Data (0x8000-0x97FF)**: Datos de los tiles (gráficos) que se usan para renderizar el fondo y los sprites. Cada tile ocupa 16 bytes (2 bytes por línea de 8 píxeles).
- **Tile Map (0x9800-0x9FFF)**: Mapas de tiles que indican qué tile se dibuja en cada posición del fondo. Cada byte del mapa apunta a un tile en el Tile Data.

**Problema Crítico**: Si la VRAM está completamente vacía (todo ceros), la PPU renderizará píxeles de índice 0 (que corresponde al color más claro de la paleta). Con la paleta de debug de Python (Step 0256), el índice 0 se mapea a verde/blanco, lo que explica por qué vemos una pantalla completamente verde incluso cuando el LCD está encendido.

**Diagnóstico de VRAM**: Al calcular la suma de bytes de la VRAM (usando un muestreo cada 16 bytes para no matar el rendimiento), podemos determinar:
- **Sum = 0**: La VRAM está vacía. El juego no ha copiado gráficos. Esto indica un problema de CPU/DMA (el juego no está ejecutando el código que copia los tiles desde la ROM a la VRAM).
- **Sum > 0**: Hay datos en la VRAM. Si la pantalla sigue verde, el problema está en la PPU (no está leyendo correctamente los tiles desde VRAM) o en el mapeo de tiles (Tile Map apunta a tiles vacíos).

**Fuente:** Pan Docs - VRAM, Tile Data, Tile Maps

**Archivos Afectados:**
- `src/viboy.py` - Modificado el monitor GPS (Step 0240) para añadir cálculo de suma de VRAM (Step 0258).

**Decisiones de Diseño:**
- **Muestreo cada 16 bytes**: Se eligió leer cada 16 bytes en lugar de todos los bytes para no matar el rendimiento. El muestreo es suficiente para detectar si la VRAM está completamente vacía (suma = 0) o contiene datos (suma > 0).
- **Frecuencia de ejecución**: El diagnóstico se ejecuta solo una vez por segundo (cada 60 frames), igual que el resto del monitor GPS, para no impactar el rendimiento.
- **Log claro**: Se usa un mensaje de log claro que indica explícitamente que si la suma es 0, no hay gráficos en la VRAM.

**Validación:**
- Ejecutar: `python main.py roms/pkmn.gb` (o cualquier ROM con LCD encendido).
- Observar el log y buscar `[MEMORY] VRAM_SUM: X` cada segundo.
- **Si X = 0**: La VRAM está vacía. El juego no ha copiado gráficos. Esto indica un problema de CPU/DMA.
- **Si X > 0**: Hay datos en la VRAM. Si la pantalla sigue verde, el problema está en la PPU o en el mapeo de tiles.

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar el valor de `VRAM_SUM`.
- Si X = 0: Investigar por qué el juego no está ejecutando el código que copia los tiles desde la ROM a la VRAM (problema de CPU/DMA).
- Si X > 0: Investigar por qué la PPU no está leyendo correctamente los tiles desde VRAM o por qué el Tile Map apunta a tiles vacíos.

### 2025-12-23 - Step 0257: Hardware Palette Bypass (C++)
**Estado**: ✅ IMPLEMENTADO

Este Step modifica `src/core/cpp/PPU.cpp` para forzar valores estándar de paleta (`0xE4`) directamente en el motor de renderizado de C++, ignorando completamente los registros de paleta de la MMU (BGP, OBP0, OBP1). El objetivo es garantizar que los índices de color (0-3) generados desde la VRAM se preserven en el framebuffer, independientemente del estado de los registros de paleta en la MMU.

**Objetivo:**
- Forzar BGP = 0xE4 (mapeo identidad: 3→3, 2→2, 1→1, 0→0) en `render_scanline()`.
- Forzar OBP0 = 0xE4 y OBP1 = 0xE4 (mapeo identidad) en `render_sprites()`.
- Garantizar que los índices de color se preserven en el framebuffer, independientemente del estado de los registros de paleta en la MMU.
- Distinguir entre problemas de paleta (PPU funciona pero paletas incorrectas) y problemas de VRAM (PPU no genera píxeles).

**Implementación:**
1. **Modificado `src/core/cpp/PPU.cpp`**: 
   - **`render_scanline()` (líneas 341-378)**: Agregado código para forzar `BGP = 0xE4` y aplicar el mapeo de paleta antes de escribir en el framebuffer. El valor `0xE4` (11100100 en binario) implementa un mapeo identidad que preserva los índices originales.
   - **`render_sprites()` (líneas 549-674)**: Agregado código para forzar `OBP0 = 0xE4` y `OBP1 = 0xE4` y aplicar el mapeo de paleta según el atributo del sprite (palette_num).

**Concepto de Hardware:**
**Registro BGP (0xFF47)**: Paleta del Background. Cada par de bits (0-1, 2-3, 4-5, 6-7) mapea un índice de color crudo (0-3) a un índice final (0-3). El valor estándar es `0xE4` (11100100 en binario), que implementa un mapeo identidad:
- Bits 0-1 (00): Índice 0 → Color 0
- Bits 2-3 (01): Índice 1 → Color 1
- Bits 4-5 (10): Índice 2 → Color 2
- Bits 6-7 (11): Índice 3 → Color 3

**Problema Crítico**: Si BGP está en `0x00` (00000000), todos los índices se mapean al color 0 (blanco). Esto significa que incluso si la VRAM contiene datos válidos (tiles con píxeles negros, índice 3), la PPU los convierte a índice 0 antes de escribirlos en el framebuffer. Cuando Python lee el framebuffer, solo ve ceros, y la paleta de debug de Python (Step 0256) mapea el índice 0 a verde/blanco.

**Solución de Bypass**: Al forzar `BGP = 0xE4` directamente en el código C++ de la PPU, ignoramos cualquier valor erróneo que pueda estar en la MMU y garantizamos que los índices de color se preserven. Si después de este bypass vemos formas negras/grises en la pantalla, confirmamos que:
1. La VRAM contiene datos válidos (tiles cargados correctamente).
2. La PPU está leyendo y decodificando los tiles correctamente.
3. El problema estaba en los registros de paleta (BGP/OBP) en la MMU.

**Fuente:** Pan Docs - Palette Registers (BGP, OBP0, OBP1), Background Palette Register

**Archivos Afectados:**
- `src/core/cpp/PPU.cpp` - Modificado `render_scanline()` y `render_sprites()` para forzar BGP = 0xE4 y OBP0/OBP1 = 0xE4 (Step 0257).

**Decisiones de Diseño:**
- **Bypass en C++**: Se eligió forzar los valores de paleta directamente en C++ en lugar de solo en Python (Step 0256) para garantizar que el framebuffer de C++ contenga índices válidos (0-3) desde el principio. Esto elimina cualquier punto de fallo en la transferencia de datos desde C++ a Python.
- **Valor 0xE4**: Se eligió `0xE4` porque es el valor estándar que usan muchos juegos de Game Boy y implementa un mapeo identidad que preserva los índices originales. Esto permite ver los datos visuales reales de la VRAM sin distorsión.
- **Aplicación de Paleta**: Aunque el valor es un mapeo identidad, se aplica la lógica de paleta completa para mantener la consistencia con el hardware real. Esto facilita la depuración futura cuando se restaure la lectura normal de BGP/OBP.
- **Comentarios Explicativos**: Se agregaron comentarios detallados explicando el propósito del bypass y el mapeo de paleta para facilitar la comprensión y el mantenimiento futuro.

**Validación:**
- Ejecutar: `.\rebuild_cpp.ps1` para recompilar la extensión Cython con los cambios en C++.
- Ejecutar: `python main.py roms/pkmn.gb` (o cualquier ROM con sprites).
- **Si vemos formas negras/grises moviéndose** (logo de GAME FREAK, intro de Gengar vs Nidorino): ✅ ÉXITO - La VRAM contiene datos válidos y la PPU los está procesando correctamente. El problema estaba en los registros de paleta (BGP/OBP) en la MMU.
- **Si seguimos viendo todo verde/blanco**: ❌ PROBLEMA - El problema está en la VRAM misma (tiles no cargados) o en la lectura de tiles desde VRAM.

**Próximos Pasos:**
- Ejecutar `.\rebuild_cpp.ps1` y `python main.py roms/pkmn.gb` y observar la pantalla.
- Si vemos formas negras/grises:
  - Confirmar que la VRAM y la PPU funcionan correctamente.
  - Investigar por qué los registros de paleta (BGP, OBP0, OBP1) están en `0x00` o por qué la MMU no los está sirviendo correctamente.
  - Corregir la lectura/escritura de los registros de paleta en la MMU.
  - Restaurar la lógica normal de paletas (quitar el bypass) y validar que los colores se muestran correctamente.
- Si seguimos viendo todo verde/blanco:
  - Verificar que el framebuffer de la PPU C++ contiene índices válidos (0-3) usando un debugger o logs.
  - Verificar que la VRAM contiene datos válidos (tiles cargados) inspeccionando la memoria en tiempo de ejecución.
  - Investigar por qué la PPU no está generando píxeles o por qué el framebuffer está vacío.

### 2025-12-23 - Step 0256: Paleta de Debug (High Contrast)
**Estado**: ✅ IMPLEMENTADO

Este Step implementa una paleta de debug de alto contraste en el renderizador de Python (`src/gpu/renderer.py`) que ignora completamente los registros de paleta del hardware (BGP, OBP0, OBP1) y mapea directamente los índices de color (0-3) del framebuffer de la PPU a colores fijos de alto contraste. El objetivo es revelar cualquier píxel que la PPU esté generando, incluso si los registros de paleta están en `0x00` (todo blanco) o si la MMU no está sirviendo correctamente los valores de paleta al frontend.

**Objetivo:**
- Forzar una paleta de debug de alto contraste que ignore BGP/OBP0/OBP1.
- Revelar cualquier píxel que la PPU esté generando, independientemente del estado de los registros de paleta.
- Distinguir entre problemas de paleta (PPU funciona pero paletas incorrectas) y problemas de PPU (PPU no genera píxeles).

**Implementación:**
1. **Modificado `src/gpu/renderer.py`**: 
   - **Renderizado con PPU C++ (líneas 444-515)**: Reemplazada la lógica de lectura y decodificación de BGP con un mapeo directo de índices a colores de alto contraste.
   - **Renderizado con método Python (líneas 525-832)**: Aplicada la misma paleta de debug al método Python que calcula tiles desde VRAM.
   - **Renderizado de Sprites (líneas 873-1027)**: Modificado `render_sprites()` para usar la misma paleta de debug, ignorando OBP0 y OBP1.

**Paleta de Debug:**
- Índice 0 → (224, 248, 208) - White/Greenish
- Índice 1 → (136, 192, 112) - Light Gray
- Índice 2 → (52, 104, 86) - Dark Gray
- Índice 3 → (8, 24, 32) - Black

**Concepto de Hardware:**
**Registros de Paleta**: En la Game Boy, los registros de paleta controlan cómo se traducen los índices de color (0-3) generados por la PPU a colores RGB visibles en pantalla. El framebuffer de la PPU contiene índices de color (0, 1, 2, 3), no colores RGB directamente. Estos índices deben pasar por una paleta para convertirse en colores visibles.

**BGP (0xFF47)**: Paleta del Background. Cada par de bits (0-1, 2-3, 4-5, 6-7) mapea un índice de color (0-3) a un tono de gris (0-3). Si BGP es `0x00`, todos los índices se mapean al color 0 (blanco), haciendo que incluso píxeles negros (índice 3) se rendericen como blancos.

**OBP0/OBP1 (0xFF48/0xFF49)**: Paletas de Sprites. Similar a BGP, pero el color 0 es siempre transparente en sprites.

**Problema Crítico**: Si los registros de paleta están en `0x00` o si la MMU no está sirviendo correctamente estos valores, todos los píxeles se renderizarán como blancos, incluso si la PPU está generando correctamente los índices de color. Esto hace que sea imposible distinguir entre un problema de renderizado (PPU no genera píxeles) y un problema de paleta (PPU genera píxeles pero se renderizan como blancos).

**Solución de Debug**: Al forzar una paleta fija de alto contraste que mapea directamente los índices 0-3 a colores visibles (Blanco, Gris Claro, Gris Oscuro, Negro), podemos "ver" cualquier píxel que la PPU esté generando, independientemente del estado de los registros de paleta. Si vemos formas negras/grises, sabemos que la PPU funciona; si seguimos viendo todo blanco, el problema está en la PPU misma.

**Fuente:** Pan Docs - Palette Registers (BGP, OBP0, OBP1)

**Archivos Afectados:**
- `src/gpu/renderer.py` - Modificado `render_frame()` y `render_sprites()` para forzar paleta de debug de alto contraste (Step 0256).

**Decisiones de Diseño:**
- **Paleta de Alto Contraste**: Se eligieron colores con suficiente contraste para que cualquier píxel con índice > 0 sea claramente visible, incluso en fondos claros.
- **Mapeo Directo**: Se evita cualquier decodificación de BGP/OBP para eliminar posibles puntos de fallo. Si el framebuffer tiene índice 3, se renderiza como negro directamente.
- **Consistencia Visual**: Se usa la misma paleta para fondo y sprites para facilitar la comparación visual.
- **No Requiere Recompilación**: Esta modificación es puramente en Python, por lo que no requiere recompilar C++. Esto permite iterar rápidamente durante el debugging.

**Validación:**
- Ejecutar: `python main.py roms/pkmn.gb` (o cualquier ROM con sprites).
- **Si vemos formas negras/grises moviéndose** (logo de GAME FREAK, intro de Gengar vs Nidorino): ✅ ÉXITO - La PPU funciona correctamente, el problema está en los registros de paleta.
- **Si seguimos viendo todo blanco/verde**: ❌ PROBLEMA - La PPU no está generando píxeles o el framebuffer no se está leyendo correctamente.

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y observar la pantalla.
- Si vemos formas negras/grises:
  - Verificar por qué BGP/OBP0/OBP1 están en 0x00 o por qué la MMU no los está sirviendo correctamente.
  - Corregir la lectura/escritura de los registros de paleta en la MMU.
  - Restaurar la lógica normal de paletas y validar que los colores se muestran correctamente.
- Si no vemos formas:
  - Verificar que el framebuffer de la PPU C++ contiene índices válidos (0-3).
  - Verificar que el framebuffer se está transfiriendo correctamente desde C++ a Python.
  - Investigar por qué la PPU no está generando píxeles o por qué el framebuffer está vacío.

### 2025-12-23 - Step 0255: Inspector OAM y Paletas
**Estado**: ✅ IMPLEMENTADO

Este Step extiende el monitor GPS (Step 0240) en `src/viboy.py` para incluir inspección en tiempo real de los registros de paleta (BGP, OBP0, OBP1) y los primeros sprites de la OAM (Object Attribute Memory). El objetivo es diagnosticar por qué la pantalla aparece verde/blanca cuando debería mostrar sprites, verificando si el problema está en los datos (OAM vacía o DMA no funcionando) o en el renderizado (paletas incorrectas).

**Objetivo:**
- Añadir instrumentación de diagnóstico al monitor GPS para inspeccionar OAM y paletas en tiempo real.
- Permitir distinguir entre problemas de datos (OAM vacía) y problemas de renderizado (paletas incorrectas).
- No modificar el núcleo C++, solo añadir herramientas de diagnóstico en Python.

**Implementación:**
1. **Modificado `src/viboy.py`**: Extendido el bloque GPS (Step 0240) con inspección de OAM y paletas:
   - Lectura de registros de paleta: `0xFF47` (BGP), `0xFF48` (OBP0), `0xFF49` (OBP1).
   - Lectura de Sprite 0: `0xFE00-0xFE03` (Y, X, Tile, Attributes).
   - Lectura de Sprite 1: `0xFE04-0xFE07` (Y, X, Tile, Attributes).
   - Logging con formato hexadecimal usando `logger.info()`.
   - Implementado tanto para modo C++ como modo Python (fallback).

**Concepto de Hardware:**
**OAM (Object Attribute Memory)**: La OAM se encuentra en el rango `0xFE00-0xFE9F` (160 bytes = 40 sprites × 4 bytes). Cada sprite ocupa 4 bytes consecutivos:
- **Byte 0 (Y)**: Posición vertical (0-255, pero Y=0 o Y≥160 oculta el sprite).
- **Byte 1 (X)**: Posición horizontal (0-255, pero X=0 o X≥168 oculta el sprite).
- **Byte 2 (Tile)**: Índice del tile en VRAM (0-255).
- **Byte 3 (Attributes)**: Atributos (paleta, flip X/Y, prioridad, etc.).

**Palette Registers**: Los registros de paleta controlan cómo se traducen los colores de los tiles:
- **BGP (0xFF47)**: Paleta del Background (4 colores: 00, 01, 10, 11).
- **OBP0 (0xFF48)**: Paleta de Sprites (canal 0, colores 1-3; color 0 es transparente).
- **OBP1 (0xFF49)**: Paleta de Sprites (canal 1, colores 1-3; color 0 es transparente).

**Problema Crítico**: Si `OBP0` o `OBP1` están en `0x00` o `0xFF` (todos blancos o todos transparentes), los sprites serán invisibles incluso si están correctamente renderizados. Si la OAM está vacía (todos ceros), la DMA no está funcionando o el juego no ha inicializado los sprites aún.

**Fuente:** Pan Docs - OAM (Object Attribute Memory), Sprite Attributes, Palette Registers

**Archivos Afectados:**
- `src/viboy.py` - Extendido el monitor GPS con inspección de OAM y paletas (Step 0255).

**Decisiones de Diseño:**
- **Instrumentación en Python**: Se eligió añadir la instrumentación en Python en lugar de C++ para evitar impactar el rendimiento del núcleo y facilitar el debugging.
- **Frecuencia de Reporte**: Se mantiene la frecuencia del GPS (cada 60 frames = 1 segundo) para no saturar los logs.
- **Formato de Log**: Se usa formato hexadecimal con prefijos `[VIDEO]` y `[SPRITE]` para facilitar el filtrado y análisis.

**Escenarios de Diagnóstico:**
- **OAM vacía (Y:00 X:00 T:00)**: La DMA no está copiando datos o la memoria se borra.
- **OAM con datos válidos (Y:10 X:08 T:5A)**: Los sprites están presentes. Si no se ven, el problema está en el renderizado C++ o en las paletas.
- **Paletas en 0x00 o 0xFF**: Los sprites serán invisibles (blancos o transparentes).

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` (o cualquier ROM con sprites) y observar los logs `[VIDEO]` y `[SPRITE]`.
- Analizar los valores reportados para determinar si el problema es de datos (OAM vacía) o renderizado (paletas incorrectas).
- Si OAM está vacía: Investigar la DMA y verificar que se ejecuta frecuentemente.
- Si OAM tiene datos pero sprites invisibles: Verificar el renderizado C++ y el mapeo de paletas.
- Corregir el problema identificado y validar que los sprites se muestran correctamente.

### 2025-12-23 - Step 0254: PPU Fase E - Renderizado de Sprites
**Estado**: ✅ IMPLEMENTADO

Este Step implementa el renderizado de Sprites (OBJ - Objects) en la PPU de C++. Hasta ahora, la PPU solo podía renderizar el Background (fondo), pero con la DMA funcionando (Step 0251), la memoria OAM (`0xFE00-0xFE9F`) ahora contiene datos válidos de los personajes y objetos del juego. Este Step completa el pipeline de renderizado permitiendo que los sprites se dibujen encima del fondo, respetando transparencia, prioridad y atributos (flip X/Y, paleta).

**Objetivo:**
- Implementar el renderizado completo de Sprites en la PPU de C++.
- Integrar el renderizado de sprites en `render_scanline()` después del Background.
- Respetar transparencia (color 0), prioridad del fondo y atributos (flip X/Y, paleta).

**Implementación:**
1. **Modificado `src/core/cpp/PPU.cpp`**: Completada la implementación de `render_sprites()`:
   - Verificación de habilitación de sprites (LCDC bit 1).
   - Determinación de altura de sprites (8x8 o 8x16 según LCDC bit 2).
   - Iteración sobre los 40 sprites en OAM (`0xFE00-0xFE9F`).
   - Filtrado por visibilidad (Y/X != 0, intersección con línea actual).
   - Decodificación de atributos (prioridad, Y-Flip, X-Flip, paleta).
   - Cálculo de línea del sprite con soporte para Y-Flip.
   - Manejo de sprites 8x16 (dos tiles consecutivos).
   - Decodificación de tiles desde VRAM usando `decode_tile_line()`.
   - Renderizado de píxeles con respeto a transparencia y prioridad.
   - Límite de 10 sprites por línea (comportamiento del hardware real).
2. **Integración en `render_scanline()`**: Añadida llamada a `render_sprites()` después de renderizar el Background.

**Concepto de Hardware:**
**Sprites (OBJ - Objects)**: Los sprites son objetos móviles que se dibujan encima del Background y la Window. La memoria OAM contiene 40 entradas de 4 bytes cada una, con información de posición, tile ID y atributos. Cada sprite puede ser 8x8 o 8x16 píxeles, y puede tener atributos de prioridad (detrás del fondo), flip vertical/horizontal y selección de paleta (OBP0/OBP1).

**Prioridad del Fondo**: Los sprites con prioridad (bit 7 de attributes = 1) se dibujan detrás del fondo, excepto si el fondo es color 0 (transparente). Esto permite efectos visuales como sprites que pasan "detrás" de objetos del fondo.

**Transparencia**: El color 0 en sprites siempre es transparente, permitiendo formas irregulares y efectos de superposición.

**Límite de Hardware**: En hardware real, solo se pueden dibujar 10 sprites por línea de escaneo. Si hay más de 10 sprites que intersectan con una línea, solo los primeros 10 (en orden de OAM) se dibujan.

**Fuente:** Pan Docs - OAM, Sprite Attributes, Sprite Rendering

**Archivos Afectados:**
- `src/core/cpp/PPU.cpp` - Completada implementación de `render_sprites()` e integración en `render_scanline()`.

**Decisiones de Diseño:**
- **Límite de 10 Sprites por Línea**: Se implementó un contador `sprites_drawn` que limita el renderizado a 10 sprites por línea, respetando el comportamiento del hardware real.
- **Prioridad del Fondo**: Se verifica el color del fondo en cada píxel antes de dibujar el sprite. Si el sprite tiene prioridad y el fondo no es transparente, el sprite no se dibuja.
- **Transparencia**: El color 0 del sprite siempre es transparente, independientemente de la prioridad.
- **Paleta**: Los índices de color (0-3) se guardan en el framebuffer. La aplicación de la paleta (OBP0/OBP1) se hace en Python al renderizar.

**Próximos Pasos:**
- Ejecutar `python main.py roms/pkmn.gb` y verificar que los sprites aparecen correctamente (logo de "POKÉMON", Gengar, Jigglypuff).
- Si hay problemas de ordenamiento visual, implementar renderizado en orden inverso (sprite 39 a sprite 0).
- Verificar que la prioridad del fondo funciona correctamente (sprites pasando detrás de objetos).

---

### 2025-12-23 - Step 0253: Silencio Total (Release Candidate)
**Estado**: ✅ IMPLEMENTADO

Este Step elimina **toda** la instrumentación de depuración (`printf`) de `MMU.cpp` y `CPU.cpp` para permitir que el emulador corra a velocidad real (60 FPS). El Step 0252 confirmó que la lógica funcional (protección de ROM, DMA, interrupciones) está correcta, pero los miles de logs estaban ralentizando masivamente la ejecución, impidiendo ver el resultado final en pantalla. Esta es la limpieza final antes del "momento de la verdad": ejecutar Tetris a velocidad nativa.

**Objetivo:**
- Eliminar todos los `printf()` activos del bucle crítico de emulación.
- Permitir que el emulador ejecute a 60 FPS reales sin overhead de I/O.
- Verificar que Tetris arranca correctamente cuando el emulador corre a velocidad nativa.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp`**: Eliminados todos los `printf()` activos:
   - Eliminados logs de `[TIME]`, `[SENTINEL]`, `[DMA]`, `[WRAM-WRITE]`, `[HRAM]`.
   - Eliminada variable estática `wram_log_count`.
   - Eliminado `#include <cstdio>`.
   - Se mantiene la lógica funcional: protección de ROM, DMA, registros de hardware.
2. **Modificado `src/core/cpp/CPU.cpp`**: Eliminados todos los `printf()` activos:
   - Eliminados logs de `[DI]`, `[EI]`, `[INT]`, `[SNIPER]`.
   - Eliminado `#include <cstdio>`.
   - Se mantiene la lógica funcional: procesamiento de interrupciones, instrucciones, flags.

**Concepto de Hardware:**
**Overhead de I/O**: Las operaciones de I/O (`printf`, `std::cout`) son órdenes de magnitud más lentas que las operaciones aritméticas o de memoria. En un bucle crítico que ejecuta millones de iteraciones por segundo, incluso un solo `printf()` puede reducir el rendimiento de 60 FPS a menos de 1 FPS. Para la CPU emulada, el tiempo pasa normal, pero para el usuario, el juego parece congelado.

**Zero-Cost Abstractions**: En el bucle crítico de emulación, cada operación debe ser lo más eficiente posible. Las abstracciones de alto nivel (como logging) deben eliminarse o moverse fuera del bucle crítico. El código C++ compilado debe ejecutarse sin overhead de I/O en el camino crítico.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Eliminados todos los `printf()` activos y `#include <cstdio>`.
- `src/core/cpp/CPU.cpp` - Eliminados todos los `printf()` activos y `#include <cstdio>`.

**Decisiones de Diseño:**
- **Eliminación Total de Logs**: En lugar de usar flags de compilación condicionales (`#ifdef DEBUG`), se eliminaron todos los logs activos. Esto simplifica el código y garantiza que no haya overhead en builds de release.
- **Preservación de Comentarios**: Los logs comentados se mantienen en el código para referencia futura. Esto permite reactivar la instrumentación rápidamente si es necesario.
- **Lógica Funcional Preservada**: Se mantiene intacta toda la lógica funcional crítica: protección de ROM, DMA, interrupciones, registros de hardware.

**Próximos Pasos:**
- Ejecutar `python main.py roms/tetris.gb` y verificar que el emulador corre a 60 FPS reales.
- Confirmar que Tetris arranca y muestra el copyright o el menú principal.
- Si el juego arranca correctamente, celebrar el hito y documentar el éxito.
- Si la pantalla sigue verde, reactivar el logging selectivo (solo GPS de Python) para diagnóstico.

---

### 2025-12-23 - Step 0252: ROM Protection & Interrupt Trace
**Estado**: ✅ IMPLEMENTADO

Este Step implementa dos mejoras críticas de integridad: **protección de ROM** y **rastreo de interrupciones**. El análisis del Step 0251 reveló que el juego estaba escribiendo en el rango de ROM (`0x0000-0x7FFF`), lo que podría corromper el código del juego en tiempo de ejecución. Además, el misterio de `IME:0` constante requiere instrumentación para detectar quién desactiva las interrupciones.

**Objetivo:**
- Proteger la ROM contra escrituras que podrían corromper el código del juego.
- Instrumentar los puntos donde IME se desactiva para entender por qué las interrupciones no se procesan.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp`**: Añadida protección de ROM en el método `write()` (líneas ~399-408).
   - Si `addr < 0x8000`, se retorna inmediatamente sin escribir en `memory_`.
   - Los logs de `SENTINEL` y `DMA` se mantienen para diagnóstico, pero la memoria no se modifica.
2. **Modificado `src/core/cpp/CPU.cpp`**: Añadidos logs de rastreo en dos puntos:
   - En `case 0xF3` (DI): Log `[DI] ¡Interrupciones Deshabilitadas en PC:XXXX!`
   - En `handle_interrupts()`: Log `[INT] ¡Interrupcion disparada! Tipo: XX. Saltando a Vector. (IME desactivado)`

**Concepto de Hardware:**
**Protección de ROM**: En hardware real, la ROM del cartucho (`0x0000-0x7FFF`) es físicamente de solo lectura. Intentar escribir en este rango no modifica los datos de la ROM, sino que se envía al MBC (Memory Bank Controller) del cartucho para controlar el cambio de bancos de memoria. Para cartuchos "ROM ONLY" (Type 0x00) como Tetris, las escrituras simplemente se ignoran silenciosamente.

**Rastreo de Interrupciones**: El sistema de interrupciones tiene dos formas principales de desactivar IME:
1. **Instrucción `DI` (0xF3)**: Desactiva IME inmediatamente. Se usa típicamente al inicio de rutinas críticas.
2. **Procesamiento de Interrupción**: Cuando se dispara una interrupción, el hardware desactiva IME automáticamente para evitar interrupciones anidadas.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadida protección de ROM en el método `write()`.
- `src/core/cpp/CPU.cpp` - Añadidos logs de rastreo en `DI` y `handle_interrupts()`.

**Decisiones de Diseño:**
- **Protección Silenciosa**: No generamos errores ni warnings cuando se intenta escribir en ROM. El hardware real simplemente ignora estas escrituras silenciosamente.
- **Logs de Diagnóstico**: Los logs de `SENTINEL` y `DMA` se mantienen para diagnóstico, pero la memoria no se modifica.
- **Instrumentación Temporal**: Los logs de `[DI]` y `[INT]` son temporales para diagnóstico. Una vez que identifiquemos el problema, pueden desactivarse para mejorar el rendimiento.

**Próximos Pasos:**
- Ejecutar el emulador con Tetris y analizar los logs de protección de ROM.
- Verificar si los logs de `[DI]` y `[INT]` revelan quién desactiva IME.
- Si la protección de ROM resuelve el problema, considerar implementar manejo de MBC para cartuchos con bancos de memoria.

---

### 2025-12-23 - Step 0251: Implementación de DMA (OAM Transfer)
**Estado**: ✅ IMPLEMENTADO

Este Step implementa la transferencia DMA (Direct Memory Access) para copiar datos a la OAM (Object Attribute Memory). El análisis de los logs de Tetris, Mario y Pokémon reveló que Tetris intenta usar DMA (`Write DMA [FF46] = 00`), mientras que Mario y Pokémon ya muestran actividad gráfica. La implementación de DMA es crítica para que los juegos puedan actualizar los sprites y completar su secuencia de arranque.

**Objetivo:**
- Implementar la transferencia DMA cuando se escribe en el registro `0xFF46`.
- Copiar 160 bytes desde la dirección `XX00` (donde XX es el valor escrito) hasta la OAM (`0xFE00-0xFE9F`).
- Permitir que Tetris y otros juegos completen su secuencia de arranque.

**Implementación:**
1. **Modificado `src/core/cpp/MMU.cpp`**: Añadida lógica de transferencia DMA en el método `write()` (líneas 302-323).
   - Cuando se detecta una escritura en `0xFF46`, se calcula la dirección origen (`value << 8`).
   - Se copian 160 bytes desde la dirección origen hasta la OAM usando el método `read()` para respetar el mapeo de memoria.
   - Se incluye un log de confirmación: `[DMA] Transferencia completada: XXXX -> FE00 (160 bytes)`.

**Concepto de Hardware:**
**DMA (Direct Memory Access)**: La Game Boy incluye un mecanismo de DMA que permite copiar datos a la OAM sin intervención directa de la CPU. Escribir un valor `XX` en `0xFF46` inicia una transferencia que copia 160 bytes desde `XX00` hasta `0xFE00-0xFE9F`. En hardware real, la transferencia tarda ~160 microsegundos (640 ciclos), y durante este tiempo la CPU solo puede acceder a HRAM (`0xFF80-0xFFFE`).

**Uso de DMA en juegos**: Los juegos usan DMA no solo para copiar sprites, sino también como mecanismo de sincronización o como parte de su secuencia de inicialización. Tetris, por ejemplo, intenta usar DMA durante su arranque, y si no está implementada, puede quedarse en un bucle infinito.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadida lógica de transferencia DMA en el método `write()`.

**Decisiones de Diseño:**
- **DMA Instantánea**: Por simplicidad, implementamos una copia instantánea. Una implementación más precisa requeriría contar 640 ciclos y bloquear el acceso a memoria (excepto HRAM) durante la transferencia.
- **Uso de `read()`**: Se usa el método `read()` de la MMU para leer desde la dirección origen, garantizando que se respeten todas las reglas de mapeo de memoria (Echo RAM, registros especiales, etc.).

**Próximos Pasos:**
- Probar Tetris y verificar si sale del bucle infinito.
- Verificar que los sprites aparecen correctamente en Mario y Pokémon.
- Si es necesario, implementar timing preciso de DMA (640 ciclos) y bloqueo de acceso a memoria durante DMA.

---

### 2025-12-23 - Step 0250: La Precuela (Volcado ROM Expandido)
**Estado**: 🔍 EN DEPURACIÓN

El Step 0249 reveló que el bucle infinito en `0x2B20` busca el valor `0xFD` en la memoria apuntada por `HL`. Como nuestra memoria está vacía (todo `0x00`), el bucle nunca termina. Este Step expande el volcado de ROM al rango anterior (`0x2AE0` - `0x2B20`) para encontrar cómo se inicializa `HL` antes de entrar en el bucle.

**Objetivo:**
- Volcar el rango `0x2AE0` - `0x2B20` para ver el código que precede al bucle infinito.
- Identificar cómo se inicializa el registro `HL` antes de entrar en el bucle.
- Entender qué datos espera el juego encontrar en la memoria.

**Implementación:**
1. **Modificado `tools/dump_rom_zone.py`**: Cambiado el rango por defecto a `0x2AE0` - `0x2B20`.
2. **Creado `tools/analyze_code_flow.py`**: Script que desensambla y analiza el flujo de código entre `0x2B05` y `0x2B20` con explicaciones detalladas.

**Concepto de Hardware:**
**Tablas de Punteros en ROM**: Los juegos de Game Boy frecuentemente almacenan tablas de punteros en la ROM que apuntan a datos en RAM. Estas tablas permiten que el código acceda dinámicamente a diferentes regiones de memoria basándose en un índice. El formato típico es little-endian: el byte bajo va primero, seguido del byte alto.

**Indirección de Memoria**: El código puede usar múltiples niveles de indirección: primero lee un puntero desde la ROM, luego usa ese puntero para leer datos desde la RAM, y finalmente usa esos datos como otra dirección o valor. Si cualquiera de estos niveles no está inicializado correctamente, el programa puede fallar o entrar en un bucle infinito.

**Archivos Afectados:**
- `tools/dump_rom_zone.py` - Modificado: Cambiado rango por defecto a `0x2AE0` - `0x2B20`.
- `tools/analyze_code_flow.py` - Nuevo: Script de análisis de flujo de código con desensamblado detallado.

**Hallazgos Clave del Análisis:**
- **0x2B05**: `LD HL, 0x2BAC` - Inicializa HL apuntando a una tabla de punteros en ROM.
- **0x2B08**: `RLCA` - Rota el registro A (probablemente un índice).
- **0x2B0C**: `ADD HL,DE` - Calcula la dirección de la entrada en la tabla: `HL = 0x2BAC + A`.
- **0x2B0D-0x2B0F**: Lee un puntero desde `[HL]` y lo almacena en `DE`.
- **0x2B10-0x2B14**: Lee datos desde `[DE]` y los usa para configurar `HL`.
- **0x2B20**: `INC HL` - **¡AQUÍ EMPIEZA EL BUCLE!**

**Tabla de Punteros en 0x2BAC:**
El volcado de `0x2BAC` revela una tabla de direcciones (punteros little-endian) que apuntan a direcciones en el rango `0x2C68` - `0x2CAC`. El código usa el valor de `A` como índice para seleccionar uno de estos punteros.

**Hipótesis Principal:**
El juego espera que una rutina de inicialización (probablemente ejecutada durante el boot o en una interrupción V-Blank) copie datos desde la ROM a la RAM antes de ejecutar el código en `0x2B05`. Como esta rutina nunca se ejecuta o falla, los datos no están en RAM, `HL` se configura incorrectamente (probablemente `0x0000` o una dirección inválida), y el bucle en `0x2B20` nunca encuentra el terminador `0xFD` porque está buscando en memoria vacía.

**Próximos Pasos:**
- Verificar el valor de `A` cuando se ejecuta `RLCA` en `0x2B08` (tracking de registros).
- Volcar la región de memoria apuntada por la tabla (por ejemplo, `0x2C68`) para ver qué datos espera el juego.
- Buscar en la ROM rutinas de inicialización que copien datos a RAM.
- Verificar si el juego espera que DMA copie estos datos (revisar si hay escrituras a `0xFF46` antes de `0x2B05`).
- Implementar tracking de registros para ver el valor exacto de `HL` cuando entra al bucle en `0x2B20`.

**Fuente**: Pan Docs - CPU Instruction Set, GBEDG - Game Boy Opcodes Reference

---

### 2025-12-23 - Step 0249: Volcado de Zona Cero (Desensamblador de ROM)
**Estado**: 🔍 EN DEPURACIÓN

El Step 0248 reveló que el juego ejecuta `EI` (Enable Interrupts) en `0x033A`, pero el GPS muestra `IME:0` permanentemente. El análisis forense identificó un bucle infinito en `0x2B24` y escrituras en HRAM en `0x2BA3`. Para entender exactamente qué está haciendo el código del juego en esa región crítica, se creó una herramienta de volcado de ROM con desensamblado básico.

**Objetivo:**
- Crear un script que volcara la zona crítica de la ROM (`0x2B20` - `0x2BC0`) en formato hexadecimal.
- Desensamblar los opcodes para entender el flujo de control del programa.
- Identificar las instrucciones clave que causan el bucle infinito.

**Implementación:**
1. **Creado `tools/dump_rom_zone.py`**: Script que lee una zona específica de la ROM y la muestra en formato hexadecimal con desensamblado básico.
2. **Diccionario de opcodes Game Boy**: Mapeo completo de los 256 opcodes posibles del LR35902 con sus mnemónicos.
3. **Detección automática de longitud**: El script identifica si una instrucción tiene 1, 2 o 3 bytes y muestra los operandos.
4. **Cálculo de saltos relativos**: Para instrucciones `JR r8`, calcula la dirección de destino.
5. **Creado `tools/analizar_zona_critica.py`**: Script de análisis que interpreta los resultados del volcado.

**Concepto de Hardware:**
**Desensamblado**: El proceso de convertir código máquina (bytes) en instrucciones legibles (mnemónicos) se llama desensamblado. Cada opcode tiene un significado específico según la especificación del procesador LR35902.

**Análisis de Flujo**: Al examinar una secuencia de opcodes, podemos reconstruir el flujo de control del programa: saltos condicionales, bucles, llamadas a subrutinas, etc. Esto es esencial para entender por qué un programa se queda atascado.

**Archivos Afectados:**
- `tools/dump_rom_zone.py` - Script de volcado de ROM con desensamblado básico (nuevo)
- `tools/analizar_zona_critica.py` - Script de análisis de la zona crítica (nuevo)

**Hallazgos Clave del Volcado:**
- **0x2B20**: `INC HL` - Inicio del bucle, incrementa el puntero HL
- **0x2B24**: `LD A,(HL)` seguido de `CP 0xFF` - Compara el byte en (HL) con 0xFF
- **0x2B96**: `LD (HL+),A` - Escribe A en (HL) e incrementa HL (parte de rutina de copia)
- **0x2BA3**: `LDH (FF8D),A` - Escribe en HRAM[0xFF8D] (configuración)
- **0x2BA9**: `JP 2B20` - **⚠️ SALTO INCONDICIONAL AL INICIO (BUCLE INFINITO)**

**Hipótesis Principal:**
El juego está en un bucle que lee datos desde una dirección (apuntada por HL) y espera encontrar `0xFF` como terminador. Si nunca encuentra `0xFF`, el bucle continúa indefinidamente. El juego probablemente espera que DMA o una interrupción modifique esos datos o active un flag, pero como esas operaciones no funcionan correctamente en el emulador, el bucle nunca termina.

**Próximos Pasos:**
- Verificar qué dirección apunta HL cuando el bucle comienza (tracking de registros)
- Verificar qué datos están en esa dirección y si contienen el terminador `0xFF`
- Verificar si el juego espera que DMA modifique esos datos
- Verificar si el juego espera una interrupción que modifique un flag

**Fuente**: Pan Docs - CPU Instruction Set, GBEDG - Game Boy Opcodes Reference

---

### 2025-12-23 - Step 0248: EI Watchdog
**Estado**: 🔍 EN DEPURACIÓN

El análisis del Timeline Logger (Step 0247) reveló que el juego está intentando usar DMA (`PC:2B96` escribe `00` en `FF46`) y escribiendo el centinela `FD` en HRAM (`PC:2BA3` escribe `FD` en `FF8D`), pero el GPS muestra constantemente `IME:0` (interrupciones deshabilitadas). 

**Hipótesis de Bloqueo:**
La rutina que copia los datos de HRAM/ROM a WRAM (donde se espera el `FD`) probablemente reside en una rutina de interrupción (V-Blank). Como `IME` es 0, la interrupción nunca se dispara, la copia nunca ocurre, y el bucle principal espera eternamente.

**Objetivo:**
- Instrumentar la instrucción `EI` (Enable Interrupts, opcode 0xFB) para detectar si el juego intenta habilitar las interrupciones.
- Determinar si el juego nunca ejecuta `EI` (confirmando que IME permanece deshabilitado) o si lo ejecuta pero en un momento incorrecto.

**Implementación:**
1. **Re-añadido `#include <cstdio>` temporalmente** en `CPU.cpp` (aunque se eliminó en Step 0243 para rendimiento).
2. **Añadido log `[EI]` en el caso 0xFB**: Registra cada ejecución de `EI` con el PC actual para determinar cuándo y dónde el juego intenta habilitar interrupciones.

**Concepto de Hardware:**
**EI (Enable Interrupts, Opcode 0xFB)**: Instrucción que habilita el Interrupt Master Enable (IME) con un retraso de 1 instrucción. En hardware real, cuando se ejecuta `EI`, el IME no se activa inmediatamente, sino después de ejecutar la siguiente instrucción. Esto permite que la instrucción siguiente a `EI` se ejecute sin interrupciones.

**IME (Interrupt Master Enable)**: Flag global que controla si la CPU puede procesar interrupciones. Si IME está deshabilitado (`IME:0`), la CPU ignora todas las interrupciones, incluso si están habilitadas en el registro IE (Interrupt Enable, 0xFFFF) y hay señales pendientes en IF (Interrupt Flag, 0xFF0F).

**El Problema del Deadlock por IME**: Muchos juegos de Game Boy usan interrupciones V-Blank para sincronizar operaciones críticas como copias de datos a VRAM o WRAM. Si el juego espera una interrupción que nunca ocurre (porque IME está deshabilitado), puede quedar atascado en un bucle infinito esperando un evento que nunca llegará.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido log en caso 0xFB (EI) y re-añadido #include &lt;cstdio&gt; temporalmente (Step 0248)

**Resultados Esperados:**
- **Escenario A (EI aparece)**: Si aparece `[EI] ¡Interrupciones Habilitadas en PC:XXXX!`, el juego intenta habilitar interrupciones. Necesitamos verificar si ocurre antes o después del bucle de espera.
- **Escenario B (EI nunca aparece)**: Si NO aparece `[EI]`, el juego nunca ejecuta `EI`, lo que confirma que las interrupciones permanecen deshabilitadas y explica el deadlock.

**Fuente**: Pan Docs - CPU Instruction Set (EI), Interrupt Master Enable (IME)

---

### 2025-12-23 - Step 0247: Memory Timeline & PC Tracker
**Estado**: 🔍 EN DEPURACIÓN

El Step 0246 confirmó que el juego **sí está escribiendo en la WRAM**, pero lo está haciendo de manera descendente (desde `DFFF` hacia abajo) y con valor **`0x00`** (ceros). Esto es una **rutina de limpieza de memoria (Zero-Fill)** que es normal y correcta durante la inicialización.

Sin embargo, aún falta la pieza clave: **La Cronología**. ¿En qué orden ocurren las operaciones y quién las ejecuta? Si el juego limpia toda la WRAM a ceros y luego busca `0xFD`... nunca lo va a encontrar. El `0xFD` debe escribirse **DESPUÉS** de la limpieza, o la limpieza no debería tocar esa zona.

**Objetivo:**
- Implementar un sistema de rastreo temporal que combine el Program Counter (PC) con las escrituras clave en memoria.
- Reconstruir la secuencia temporal completa de operaciones de memoria para determinar qué instrucción (PC) está provocando cada operación.
- Determinar si la limpieza de WRAM ocurre antes o después de escribir el marcador `0xFD`.

**Implementación:**
1. **Añadido miembro público `debug_current_pc` en `MMU.hpp`**: Campo para rastrear el PC actual de la CPU.
2. **Actualizado `CPU::step()`**: Actualiza `mmu_->debug_current_pc` antes de ejecutar cada instrucción.
3. **Reemplazado logging del Step 0246 con Timeline Logger en `MMU::write()`**: Registra escrituras en WRAM, marcador `0xFD`, y DMA junto con el PC que las provocó.

**Concepto de Hardware:**
**Program Counter (PC)**: Registro de 16 bits que contiene la dirección de memoria de la próxima instrucción a ejecutar. Cada vez que la CPU ejecuta una instrucción, el PC avanza al siguiente opcode.

**Rastreo Temporal de Operaciones**: Para entender la secuencia de eventos en un programa, es crucial conocer no solo *qué* operaciones ocurren, sino también *cuándo* ocurren y *desde dónde* (qué instrucción las provocó). Esto permite reconstruir la "historia" o "timeline" de las operaciones de memoria.

**El Problema de la Cronología**: El Step 0246 confirmó que el juego escribe `0xFD` en HRAM, limpia la WRAM a ceros, y busca `0xFD` en WRAM. Pero falta saber: ¿En qué orden ocurre esto? Si la limpieza ocurre *después* de escribir el marcador, entonces está borrando el marcador. Si la escritura del marcador ocurre *después* de la limpieza, entonces el problema está en otro lado.

**Archivos Afectados:**
- `src/core/cpp/MMU.hpp` - Añadido miembro público `debug_current_pc` (Step 0247)
- `src/core/cpp/MMU.cpp` - Inicializado `debug_current_pc` en constructor. Reemplazado logging del Step 0246 con Timeline Logger (Step 0247)
- `src/core/cpp/CPU.cpp` - Añadida actualización de PC en MMU antes de ejecutar instrucción (Step 0247)

**Resultados Esperados:**
- **Escenario A (Limpieza antes del marcador)**: Se ven múltiples escrituras en WRAM con valor `00`, seguidas de escritura del marcador `FD`. *Diagnóstico:* La limpieza ocurre antes, lo cual es correcto. El problema está en que el marcador no se copia a WRAM después.
- **Escenario B (Marcador antes de la limpieza)**: Se ve escritura del marcador, seguido de múltiples escrituras en WRAM con valor `00`. *Diagnóstico:* La limpieza está borrando el marcador después de escribirlo.
- **Escenario C (Nunca se escribe el marcador)**: No se ve ninguna escritura del marcador. *Diagnóstico:* El juego nunca escribe el marcador, o la rutina que lo escribe no se ejecuta.

---

### 2025-12-23 - Step 0246: WRAM Writer Profiler
**Estado**: 🔍 EN DEPURACIÓN

El análisis del Step 0245 reveló un resultado desconcertante: **cero actividad detectada**. Esto contradice parcialmente al Step 0244 (que sí vio escrituras de `0xFD`), lo que sugiere que el emulador puede estar entrando en el bucle de espera antes de llegar a la escritura, o que el script de análisis filtró demasiado.

La conclusión neta es que el juego **NO** usa DMA (`FF46`) ni lee la HRAM (`FF8D`) para copiarla. Sin embargo, el juego **BUSCA** datos en WRAM y se cuelga porque está vacía.

**Objetivo:**
- Instrumentar `MMU::write` para registrar las primeras 100 escrituras en WRAM (`0xC000-0xDFFF`).
- Determinar si la WRAM permanece virgen (solo ceros/sin escrituras) o si se está escribiendo "basura".
- Confirmar si la rutina de inicialización que debe copiar datos desde la ROM a la WRAM se está ejecutando.

**Implementación:**
1. **Eliminada instrumentación de Steps 0244 y 0245**: Se limpió el código de instrumentación anterior para reducir el ruido en los logs.
2. **Añadido bloque de instrumentación en `MMU::write`**: Registra las primeras 100 escrituras en WRAM con formato `[WRAM-WRITE #N] Addr: XXXX | Val: XX`.

**Concepto de Hardware:**
**Work RAM (WRAM)**: La WRAM del Game Boy es una región de memoria de 8KB ubicada en el rango `0xC000-0xDFFF`. Esta memoria es utilizada por los juegos para almacenar variables de estado, buffers temporales, y datos de trabajo durante la ejecución.

**Rutina de Inicialización de Memoria**: Durante el arranque de un juego, típicamente ocurre una rutina de inicialización que copia datos desde el cartucho (ROM) hacia la WRAM. Esta rutina puede ser:
- **Rutina de copia masiva (memcpy)**: Mueve bloques de datos desde la ROM hacia la WRAM.
- **Rutina de inicialización de variables**: Escribe valores específicos en direcciones concretas de la WRAM.
- **Rutina de limpieza**: Llena la WRAM con ceros o valores por defecto.

Si la WRAM permanece vacía (llena de ceros), significa que **esa rutina de copia nunca ocurrió** o escribió ceros. Esto puede deberse a que el Program Counter (PC) tomó un camino erróneo antes de llegar al `CALL` de copia, o que la rutina de inicialización falló silenciosamente.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadido profiler de escrituras en WRAM (Step 0246). Eliminada instrumentación de Steps 0244 y 0245.

**Resultados Esperados:**
- **Escenario A (Silencio Total)**: No se detectan escrituras en WRAM. *Diagnóstico:* La CPU se salta la inicialización. El `PC` toma un camino erróneo antes de llegar al `CALL` de copia.
- **Escenario B (Escrituras detectadas)**: Se detectan escrituras en WRAM. *Análisis:* Si los valores son todo `00`, es una rutina de limpieza (`XOR A`). Si los valores son variados (`12`, `F0`, `FD`), es una rutina de copia de datos.

---

### 2025-12-22 - Step 0245: Interceptor de Transferencia DMA/HRAM
**Estado**: 🔍 EN DEPURACIÓN

El Centinela (Step 0244) confirmó que el juego escribe el marcador `0xFD` en **HRAM** (`0xFF8D`), pero luego lo busca desesperadamente en **WRAM**, causando un bucle infinito. Falta el eslabón perdido: ¿Quién mueve los datos de HRAM a WRAM? Se implementa un interceptor de transferencia que monitorea escrituras en el registro DMA (`0xFF46`) y lecturas en HRAM (`0xFF8D`) para determinar si el juego intenta usar DMA o una rutina de copia manual.

**Objetivo:**
- Instrumentar `MMU::read` para detectar lecturas en HRAM (`0xFF8D`).
- Instrumentar `MMU::write` para detectar escrituras en el registro DMA (`0xFF46`).
- Crear un script de análisis automático para procesar logs y generar un resumen estructurado.

**Implementación:**
1. **Añadido bloque de instrumentación en `MMU::read`**: Detecta lecturas en `0xFF8D` (HRAM) para determinar si alguien intenta leer el marcador `0xFD` para copiarlo a WRAM.
2. **Añadido bloque de instrumentación en `MMU::write`**: Detecta escrituras en `0xFF46` (registro DMA) para determinar si el juego intenta activar una transferencia DMA.
3. **Creado script de análisis automático**: `tools/analizar_dma_0245.py` procesa los logs del emulador y genera un resumen estructurado con estadísticas, correlaciones y conclusiones.

**Concepto de Hardware:**
**DMA (Direct Memory Access)**: El Game Boy tiene un registro DMA (`0xFF46`) que permite copiar 160 bytes de datos desde cualquier dirección de memoria a la OAM (Object Attribute Memory, `0xFE00-0xFE9F`). Cuando el juego escribe un byte en `0xFF46`, el hardware inicia automáticamente una transferencia desde la dirección `(valor × 0x100)` a OAM. Sin embargo, el hardware real solo copia a OAM, no a otras áreas de memoria como WRAM.

**Transferencias Manuales de Memoria**: Además de DMA, los programas pueden usar instrucciones de copia manual como `LDI` (Load Increment) o `LDD` (Load Decrement) para mover datos entre áreas de memoria. Estas instrucciones copian un byte desde la dirección apuntada por `HL` a la dirección apuntada por `DE`, incrementando o decrementando ambos punteros.

**El Problema del Eslabón Perdido**: El Step 0244 confirmó que el juego escribe `0xFD` en HRAM y lo busca en WRAM, pero el marcador nunca aparece en WRAM. Esto sugiere que hay una transferencia de datos que debería ocurrir entre la escritura en HRAM y la búsqueda en WRAM, pero que no está funcionando. Las posibilidades son:
- **Opción A**: El juego intenta usar DMA para copiar datos, pero nuestra implementación de DMA no está funcionando o no está copiando a la dirección correcta.
- **Opción B**: El juego usa una rutina de copia manual (LDI/LDD) que lee desde HRAM y escribe en WRAM, pero la lectura o escritura falla silenciosamente.
- **Opción C**: El juego escribió en HRAM pero nunca intentó copiar los datos (problema anterior en la lógica de inicialización).

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadidos bloques de instrumentación en `MMU::read` (HRAM) y `MMU::write` (DMA)
- `tools/analizar_dma_0245.py` - Script de análisis automático para procesar logs y generar resumen
- `docs/bitacora/entries/2025-12-22__0245__interceptor-dma-hram.html` - Entrada de bitácora
- `docs/bitacora/index.html` - Actualizado con nueva entrada
- `INFORME_FASE_2.md` - Actualizado con Step 0245

**Próximos Pasos:**
- Recompilar la extensión C++: `python setup.py build_ext --inplace`
- Ejecutar el emulador durante 10 segundos: `python main.py roms/tetris.gb > dma_check.log 2>&1`
- Analizar el log: `python tools/analizar_dma_0245.py dma_check.log > RESUMEN_DMA_0245.txt`
- **Si se detectan eventos DMA**: Investigar por qué la transferencia DMA falla (verificar implementación de DMA, dirección de destino, etc.)
- **Si se detectan lecturas HRAM**: Investigar por qué la copia manual falla (verificar instrucciones LDI/LDD, redirección de Echo RAM, etc.)
- **Si NO se detecta nada**: Instrumentar más áreas (por ejemplo, rastreador de escrituras en WRAM) o investigar la lógica de inicialización del juego

---

### 2025-12-22 - Step 0244: El Rastreador del Centinela
**Estado**: 🔍 EN DEPURACIÓN

Tras confirmar un bucle infinito en `0x2B24` donde el juego escanea la WRAM buscando el byte `0xFD` (que nunca encuentra porque la memoria está inicializada a `0x00`), se implementa un rastreador del centinela (sentinel search) en la MMU para detectar cualquier intento de escritura de este valor mágico. Esto permitirá determinar si el juego intentó escribir el marcador y falló, o si nunca llegó a ejecutar la instrucción de escritura.

**Objetivo:**
- Instrumentar el método `MMU::write` para detectar y registrar cualquier intento de escribir el valor `0xFD` en la memoria RAM (direcciones `>= 0xC000`).
- Determinar si el juego intentó escribir el marcador mágico y falló, o si nunca llegó a ejecutar la instrucción de escritura.

**Implementación:**
1. **Añadido bloque de diagnóstico en `MMU::write`**: Se coloca justo después de enmascarar el valor y antes de los registros especiales, para capturar todas las escrituras relevantes, incluyendo las que se redirigen desde Echo RAM.
2. **Condición de detección**: Se verifica tanto el valor (`0xFD`) como la dirección (`>= 0xC000`) para evitar falsos positivos en otras áreas de memoria.
3. **Formato del mensaje**: El mensaje incluye el prefijo `[SENTINEL]` para facilitar su búsqueda en los logs y muestra la dirección exacta donde se intentó escribir.

**Concepto de Hardware:**
**Marcadores Mágicos en Memoria (Sentinel Values)**: Muchos programas usan valores especiales (marcadores o "sentinels") para indicar estados o marcar posiciones en memoria. En el caso de Tetris, el juego parece estar buscando el byte `0xFD` en la WRAM como un marcador que indica que alguna fase de inicialización se completó correctamente.

**Diagnóstico de Bucle Infinito**: Cuando un programa entra en un bucle infinito buscando un valor que nunca encuentra, hay dos posibles causas:
- **Opción A**: El programa intentó escribir el marcador, pero la escritura falló (problema en la MMU o en la lógica de escritura).
- **Opción B**: El programa nunca llegó a ejecutar la instrucción que escribe el marcador (problema anterior en la ejecución, posiblemente en la CPU o en la lógica de inicialización).

El **rastreador del centinela** es una técnica de debugging que consiste en instrumentar el punto de escritura (en este caso, el método `MMU::write`) para detectar y registrar cualquier intento de escribir el valor buscado. Si el rastreador detecta la escritura, sabemos que el juego intentó escribir el marcador (y debemos investigar por qué no se guardó correctamente). Si el rastreador nunca se activa, sabemos que el problema está antes de la escritura (posiblemente en la lógica de inicialización o en un salto condicional incorrecto).

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadido bloque de diagnóstico del rastreador del centinela en `MMU::write`
- `docs/bitacora/entries/2025-12-22__0244__rastreador-del-centinela.html` - Entrada de bitácora
- `docs/bitacora/index.html` - Actualizado con nueva entrada
- `INFORME_FASE_2.md` - Actualizado con Step 0244

**Próximos Pasos:**
- Recompilar la extensión C++: `.\rebuild_cpp.ps1`
- Ejecutar Tetris: `python main.py roms/tetris.gb`
- Observar la consola para detectar mensajes `[SENTINEL]`
- **Si aparece el mensaje**: Investigar por qué la escritura no se guardó correctamente (verificar redirección de Echo RAM, lógica de escritura, etc.)
- **Si NO aparece el mensaje**: Investigar la lógica de inicialización del juego para encontrar dónde se supone que debería escribirse el marcador (posible problema en saltos condicionales o en la lógica de inicialización)

---

### 2025-12-22 - Step 0243: Operación Silencio
**Estado**: 🔍 EN DEPURACIÓN

Tras el "Hard Reset" (Step 0242), se confirmó que el código basura ha desaparecido y ahora observamos un bucle de escaneo de memoria legítimo (`INC HL`, `CP FD`). Sin embargo, la instrumentación de depuración (`printf` por instrucción) está ralentizando masivamente el emulador, impidiendo saber si el bucle termina naturalmente. Se elimina toda la instrumentación pesada (Francotirador y Marcador Radiactivo) para permitir la ejecución a velocidad nativa (60 FPS) y usar el monitor GPS (Step 0240) para verificar el avance.

**Objetivo:**
- Eliminar toda la instrumentación de depuración pesada en `CPU.cpp` (Francotirador y Marcador Radiactivo).
- Permitir la ejecución a velocidad nativa (60 FPS) sin ralentizaciones.
- Usar el monitor GPS para verificar el avance del emulador.

**Implementación:**
1. **Eliminado bloque del Francotirador (Step 0241)**: Se elimina el bloque que logueaba cada instrucción en el rango `0x2B20-0x2B30`.
2. **Eliminado Marcador Radiactivo (Step 0242)**: Se elimina el `printf` dentro del `case 0x08`.
3. **Eliminado `#include <cstdio>`**: Ya no se usa ningún `printf` ni función de I/O estándar.

**Concepto de Hardware:**
**Efecto Observador en Emulación**: La instrumentación de depuración (logs, `printf`, trazas) consume tiempo de CPU y puede ralentizar el emulador hasta 1,000 veces, impidiendo que el juego alcance su velocidad natural (60 FPS). Esto puede hacer que bucles que normalmente terminarían en milisegundos tarden minutos o incluso horas. El **monitor GPS** (implementado en Step 0240) proporciona suficiente información para diagnóstico sin ralentizar la ejecución, reportando periódicamente el estado de la CPU (PC, SP, IME, IE, IF, LCDC, LY).

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Eliminada toda la instrumentación de depuración (Francotirador y Marcador Radiactivo). Eliminado `#include <cstdio>`.
- `docs/bitacora/entries/2025-12-22__0243__operacion-silencio.html` - Entrada de bitácora
- `docs/bitacora/index.html` - Actualizado con nueva entrada
- `INFORME_FASE_2.md` - Actualizado con Step 0243

**Próximos Pasos:**
- Recompilar la extensión C++: `.\rebuild_cpp.ps1`
- Ejecutar Tetris: `python main.py roms/tetris.gb`
- Observar los logs del GPS (cada segundo) para verificar si el PC cambia o se queda fijo.
- Si el PC cambia drásticamente (sale de la zona `0x2Bxx` y va a `0x02xx`, `0x2Cxx`, etc.): **ÉXITO** - Hemos superado la inicialización.
- Si el PC se queda fijo en `0x2B24` durante más de 5-10 segundos: Investigar por qué la memoria WRAM no contiene el byte marcador `0xFD`.

---

### 2025-12-22 - Step 0242: Hard Reset y Marcador Radiactivo
**Estado**: 🔍 EN DEPURACIÓN

El análisis del log del Francotirador (Step 0241) revela una secuencia de instrucciones absurda en `0x2B20`: múltiples ejecuciones de `LD (nn), SP` (opcode `0x08`) mezcladas con operaciones aritméticas sin sentido. Esto sugiere que la CPU está ejecutando **datos ("basura")** en lugar de código válido, o que estamos sufriendo un problema de persistencia de binarios compilados antiguos en Windows. Se implementa un "marcador radiactivo" (printf muy visible) dentro del `case 0x08` para confirmar que estamos ejecutando la versión correcta del código C++ y no una DLL/PYD cacheada.

**Objetivo:**
- Añadir un marcador radiactivo (printf muy visible) dentro del `case 0x08` para confirmar su ejecución.
- Proporcionar instrucciones de Hard Reset para eliminar artefactos de compilación anteriores.
- Verificar que estamos ejecutando la versión correcta del código y no una DLL/PYD cacheada.

**Implementación:**
1. **Añadido marcador radiactivo en `CPU.cpp`**: Se coloca al inicio del `case 0x08` con un mensaje muy visible (`!!! EJECUTANDO OPCODE 0x08 EN C++ !!!`).
2. **Instrucciones de Hard Reset**: Cerrar terminales, eliminar `build/` y archivos `.pyd`, recompilar desde cero.

**Concepto de Hardware:**
**Problema de Persistencia de Binarios en Windows**: Python puede cachear extensiones compiladas (`.pyd` o `.dll`) en memoria o en el directorio de trabajo. Si se modifica el código fuente C++ pero no se limpia correctamente el caché, Python puede seguir usando la versión antigua del binario. El **marcador radiactivo** es una técnica de debugging que consiste en añadir un marcador muy visible en un punto específico del código para confirmar que se está ejecutando la versión correcta.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido marcador radiactivo en el `case 0x08`
- `docs/bitacora/entries/2025-12-22__0242__hard-reset-marcador-radiactivo.html` - Entrada de bitácora

**Próximos Pasos:**
- Realizar Hard Reset: Cerrar terminales, eliminar `build/` y archivos `.pyd`.
- Recompilar y ejecutar Tetris.
- Analizar si aparece el mensaje del marcador radiactivo en los logs.
- Si aparece: Confirmar que el código es real y investigar el origen del salto incorrecto.
- Si no aparece: Hacer un Hard Reset más agresivo o verificar la configuración de compilación.

---

### 2025-12-22 - Step 0241: Francotirador: Recarga
**Estado**: 🔍 EN DEPURACIÓN

Tras implementar Echo RAM (Step 0239) y el monitor GPS (Step 0240), el análisis del GPS revela que la CPU sigue atrapada en la zona `0x2B24`. Aunque la lógica de Echo RAM está implementada, el juego sigue fallando la validación de memoria. Se reactiva el "Francotirador" (traza detallada) en el rango `0x2B20-0x2B30` para observar el comportamiento dinámico del bucle y determinar si HL avanza (escaneando memoria) o se reinicia constantemente.

**Objetivo:**
- Reactivar el bloque de debug del Francotirador en `CPU.cpp` para capturar cada instrucción ejecutada en el rango crítico.
- Observar el comportamiento dinámico del bucle: ¿HL avanza o se reinicia?
- Determinar si el problema es un fallo temprano (HL estático) o un bucle lento (HL avanza).

**Implementación:**
1. **Añadido bloque de debug en `CPU.cpp`**: Se activa cuando `regs_->pc >= 0x2B20 && regs_->pc <= 0x2B30`.
2. **Formato del log**: `[SNIPER] PC:XXXX | OP:XX | A:XX | HL:XXXX` para ver PC, opcode, acumulador y HL.
3. **Ubicación**: Justo antes del `fetch_byte()` para capturar el PC antes de que se incremente.

**Concepto de Hardware:**
**Análisis Dinámico de Bucles de Verificación**: Cuando un juego verifica la integridad de la memoria, típicamente ejecuta un bucle que inicializa HL, lee un byte, compara con un valor esperado, y si pasa, incrementa HL y repite. Si el bucle avanza (HL incrementa), la verificación está progresando pero es lenta. Si el bucle es estático (HL se reinicia), hay un fallo temprano. El "Francotirador" es una técnica de debugging que activa trazas detalladas solo en un rango específico de direcciones, permitiendo observar el comportamiento sin saturar la consola.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Reactivación del bloque de debug del Francotirador en el método `step()`
- `docs/bitacora/entries/2025-12-22__0241__francotirador-recarga.html` - Entrada de bitácora

**Próximos Pasos:**
- Recompilar la extensión C++ y ejecutar Tetris.
- Analizar los logs del Francotirador para determinar si HL avanza o se reinicia.
- Si HL avanza: Dejar correr el bucle o optimizar los logs.
- Si HL es estático: Investigar por qué la memoria no contiene los valores esperados.

---

### 2025-12-22 - Step 0240: Monitor GPS (El Navegador)
**Estado**: ✅ VERIFICADO

Tras superar el bucle de Echo RAM en `0x2B30`, el emulador corre estable a 60 FPS, pero la pantalla sigue mostrando solo el color de fondo (verde claro). Para diagnosticar el estado actual de la CPU sin saturar la consola con logs masivos, se implementa un **monitor GPS (Navegador)** que reporta periódicamente la posición del Program Counter (PC), el Stack Pointer (SP), el estado de las interrupciones (IME, IE, IF) y el estado del video (LCDC, LY).

**Objetivo:**
- Implementar un monitor no intrusivo que reporte el estado del sistema cada segundo (60 frames).
- Mostrar información crítica: PC, SP, IME, IE, IF, LCDC, LY en formato compacto.
- Permitir diagnosticar si la CPU está ejecutando código normalmente, esperando interrupciones, o atascada en un bucle.

**Implementación:**
1. **Añadido bloque de diagnóstico en `src/viboy.py`**: Se activa cuando `frame_count % 60 == 0` (cada 60 frames).
2. **Lectura de registros**: Accede a `self._regs.pc`, `self._regs.sp`, `self._cpu.get_ime()`, `self._mmu.read(0xFFFF)`, `self._mmu.read(0xFF0F)`, `self._mmu.read(0xFF40)`, y `self._ppu.ly`.
3. **Formato compacto**: `[GPS] PC:XXXX | SP:XXXX | IME:X | IE:XX IF:XX | LCDC:XX LY:XX`

**Concepto de Hardware:**
**Diagnóstico No Intrusivo**: Un monitor periódico permite observar el estado del sistema sin modificar su comportamiento. Los registros clave (PC, SP, IME, IE, IF, LCDC, LY) son suficientes para determinar si el sistema está funcionando correctamente o está atascado. La frecuencia de muestreo (1 segundo) es un equilibrio entre obtener información suficiente y no saturar la consola.

**Archivos Afectados:**
- `src/viboy.py` - Añadido bloque de monitor GPS en el método `run()`
- `docs/bitacora/entries/2025-12-22__0240__monitor-gps-navegador.html` - Entrada de bitácora

**Próximos Pasos:**
- Ejecutar el emulador con Tetris y observar los logs del GPS.
- Analizar los valores de PC para determinar si la CPU está ejecutando código normalmente o está atascada.
- Verificar el estado de LCDC para confirmar si el LCD está encendido.
- Si el PC está fijo, investigar qué condición está esperando la CPU.

---

### 2025-12-22 - Step 0239: Implementación de Echo RAM (El Espejo)
**Estado**: ✅ VERIFICADO

La autopsia del Step 0237 y el análisis forense del Step 0238 revelaron la causa raíz del bucle infinito en Tetris: la dirección `0xE645` pertenece a la región de **Echo RAM (0xE000-0xFDFF)**, que en el hardware real es un espejo exacto de la **WRAM (0xC000-0xDDFF)**. El juego escribió `0xFD` en `0xC645` (memoria real) y luego lee `0xE645` (espejo) para verificar la integridad de la memoria. Como nuestra MMU no implementaba Echo RAM, devolvía `0x00`, causando que la comparación `CP 0xFD` fallara y el bucle nunca terminara.

**Objetivo:**
- Implementar la lógica de Echo RAM en `MMU.cpp` para redirigir accesos a `0xE000-0xFDFF` hacia `0xC000-0xDDFF`.
- Limpiar los logs del "Francotirador" (Step 0237) que ya cumplieron su misión.

**Implementación:**
1. **Modificación en `MMU::read()`**: Detectar si `addr` está entre `0xE000` y `0xFDFF`, y redirigir a `addr - 0x2000`.
2. **Modificación en `MMU::write()`**: Misma lógica de redirección para escrituras.
3. **Limpieza en `CPU.cpp`**: Eliminación de los logs del Francotirador que ralentizaban la ejecución.

**Concepto de Hardware:**
**Echo RAM (Mirror RAM)**: Es una peculiaridad del hardware de Game Boy causada por el cableado del bus de direcciones. Debido a limitaciones en el diseño del chip, acceder a direcciones en el rango `0xE000-0xFDFF` accede físicamente a la misma memoria que `0xC000-0xDDFF`. Los juegos a veces usan esta característica para verificar la integridad de la memoria: escriben un valor en WRAM y luego leen su espejo en Echo RAM para confirmar que la memoria funciona correctamente.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Implementación de Echo RAM en `read()` y `write()`
- `src/core/cpp/CPU.cpp` - Eliminación de logs del Francotirador
- `docs/bitacora/entries/2025-12-22__0239__implementacion-echo-ram.html` - Entrada de bitácora

**Próximos Pasos:**
- Ejecutar Tetris y verificar que sale del bucle infinito en `0x2B2A`.
- Confirmar que el juego avanza a la pantalla de Copyright.
- Si el juego sigue fallando, investigar otras posibles causas (inicialización de WRAM, rutinas de copia, etc.).

---

### 2025-12-22 - Step 0238: Análisis Forense de la Traza - El Origen del 0x00
**Estado**: 🔍 EN DEPURACIÓN

El análisis de la traza del Step 0237 reveló que el problema no está en la carga del acumulador, sino en que la memoria WRAM no contiene los valores esperados. El bucle en `0x2B20-0x2B2C` ejecuta `LD A, (HL)` en `0x2B25`, leyendo correctamente de WRAM, pero obtiene `0x00` cuando el juego espera `0xFD`.

**Objetivo:**
- Confirmar que `LD A, (HL)` funciona correctamente (lee de memoria).
- Identificar qué rutina debería escribir `0xFD` en WRAM antes de llegar a `0x2B20`.
- Determinar por qué esa rutina no se ejecutó o falló.

**Hallazgos:**
1. **Fuente del valor en A**: `LD A, (HL)` en `0x2B25` lee de WRAM (direcciones `0xE645`, `0xE646`, etc.).
2. **Valor leído**: Siempre `0x00`, pero el juego espera `0xFD`.
3. **Patrón**: `HL` se incrementa en cada iteración, sugiriendo un bucle de verificación de memoria.
4. **Hipótesis**: Una rutina de inicialización que debería copiar datos a WRAM no se ejecutó o falló.

**Concepto de Hardware:**
**Reverse Taint Analysis (Análisis de Mancha Inverso)**: Técnica de depuración donde se rastrea un valor incorrecto desde su manifestación (sink: `CP 0xFD`) hasta su origen (source: `LD A, (HL)`). Sin embargo, el análisis reveló que la fuente no es el problema: la memoria simplemente no fue inicializada correctamente.

**Archivos Afectados:**
- `docs/bitacora/entries/2025-12-22__0238__analisis-trace-forense.html` - Análisis forense

**Próximos Pasos:**
- Rastrear hacia atrás para encontrar la rutina de inicialización que debería escribir `0xFD` en WRAM.
- Verificar si los registros I/O `0xFF8C` y `0xFF94` necesitan implementación.
- Buscar en el código de Tetris qué debería escribir `0xFD` en WRAM.

---

### 2025-12-22 - Step 0237: Francotirador Expandido (Retroceso)
**Estado**: 🔍 EN DEPURACIÓN

La traza del Step 0236 reveló un bucle infinito en `0x2B2A` donde el juego compara el acumulador `A` con `0xFD` mediante `CP 0xFD`. El valor de `A` es constantemente `0x00`, causando que la comparación falle y el salto condicional `JR NZ` se ejecute, creando un bucle infinito.

**Objetivo:**
- Identificar la instrucción que precede a `CP 0xFD` y carga el valor en `A`.
- Determinar de dónde lee el valor (memoria, registro, pila).
- Verificar si la memoria está inicializada correctamente o si el valor se escribió en una dirección diferente.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Expandido el rango de trazado del Francotirador desde `0x2B2A-0x2B35` a `0x2B20-0x2B30`, moviendo el límite inferior hacia atrás para capturar las instrucciones que preceden a la comparación.
2. **Salida simplificada**: Mostramos solo `A` y `HL` en los logs para facilitar la identificación de cargas desde memoria.

**Concepto de Hardware:**
Cuando un programa entra en un bucle infinito debido a una comparación que siempre falla, es crítico identificar qué instrucción carga el valor que se está comparando. Si el valor proviene de memoria (WRAM, VRAM, HRAM), puede indicar que la memoria no se ha inicializado correctamente, que una rutina de inicialización no se ejecutó, o que el valor esperado se escribió en una dirección diferente. En el caso de Tetris, la traza mostró que `HL` apunta a `0xE7F9` (WRAM) y que `DE` se incrementa de 2 en 2, sugiriendo un bucle de copia o verificación de memoria.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Expansión del rango de trazado del Francotirador (Step 0237)

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/tetris.gb`
- Observar los logs `[SNIPER]` cuando el PC entre en la zona 0x2B20-0x2B30
- Buscar instrucciones que carguen `A` antes de llegar a `0x2B2A` (LD A, (HL), LD A, (DE), POP AF, etc.)

---

### 2025-12-22 - Step 0236: Francotirador II - El Bucle de la Muerte
**Estado**: 🔍 EN DEPURACIÓN

La autopsia reveló que la CPU se ha estancado en la dirección `0x2B30` tras 9.5 millones de ciclos, con la VRAM vacía y el LCD apagado. Activamos una traza quirúrgica en esa dirección para identificar la instrucción exacta y la condición de espera que impide que el juego continúe.

**Objetivo:**
- Identificar el opcode en `0x2B30`.
- Determinar qué condición (Registro, Memoria, Flag) está bloqueando el avance.
- Verificar si es un bucle de espera de hardware (STAT, DIV, Serial) o una condición de flag.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Agregado `#include <cstdio>` y bloque de debug quirúrgico que imprime información detallada cuando el PC está en la zona 0x2B2A-0x2B35.
2. **Modificación en `viboy.py`**: Desactivada la Autopsia (Step 0235) para limpiar la consola y ver solo los logs del Francotirador.

**Concepto de Hardware:**
Cuando un programa se detiene en una dirección específica durante millones de ciclos, generalmente está esperando una condición que nunca se cumple. Esto puede ser un Busy Wait Loop que lee un registro de hardware (STAT, DIV, Serial) esperando que un bit cambie, o una instrucción condicional (JR NZ, JR Z) que salta a sí misma porque el flag nunca cambia. El análisis de la autopsia mostró que IE tiene el Bit 3 habilitado (Serial Interrupt), algo inusual para el arranque de Tetris.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Agregado debug quirúrgico en step()
- `src/viboy.py` - Desactivada Autopsia (Step 0235)

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/tetris.gb`
- Observar los logs `[SNIPER]` cuando el PC entre en la zona 0x2B2A-0x2B35

---

### 2025-12-22 - Step 0234: Paciencia y Puntería (Autopsia Mejorada)
**Estado**: 🔍 EN DEPURACIÓN

La autopsia anterior mostró que la CPU avanza (salió del bucle de arranque) y que el Timer funciona. Sin embargo, el LCD sigue apagado. Observamos que `LCDC` tiene el Bit 3 activado, lo que indica que el juego usa el segundo mapa de tiles (`0x9C00`), no el primero (`0x9800`) que estábamos inspeccionando. Ajustamos la autopsia para leer el mapa correcto según la configuración del juego y aumentamos el tiempo de espera a 10 segundos para descartar lentitud en la carga.

**Objetivo:**
- Inspeccionar la región de VRAM correcta según `LCDC` (Bit 3 determina 0x9800 vs 0x9C00).
- Dar más tiempo al juego para arrancar (600 frames = 10 segundos).
- Verificar si el Tile Map contiene datos válidos en la región correcta.

**Implementación:**
1. **Modificación en `viboy.py`**: La autopsia ahora lee `LCDC` (0xFF40) y verifica el Bit 3 para determinar qué región de Tile Map inspeccionar.
2. **Tiempo de espera extendido**: Cambio de 180 frames (3 segundos) a 600 frames (10 segundos).

**Concepto de Hardware:**
El registro LCDC Bit 3 controla qué región de VRAM se usa como Tile Map base. Si el juego configura este bit y escribe en 0x9C00, pero nuestra herramienta lee siempre desde 0x9800, veremos datos vacíos aunque el juego funcione correctamente. Es crítico adaptar las herramientas de diagnóstico al estado actual del hardware emulado.

**Archivos Afectados:**
- `src/viboy.py` - Modificación de la función de autopsia (Step 0234)

**Tests:**
- Ejecutar: `python main.py roms/tetris.gb`
- Esperar 10 segundos y observar la autopsia
- Verificar si el Tile Map en la región correcta contiene datos válidos

---

### 2025-12-22 - Step 0233: Limpieza Final y Arranque (Release)
**Estado**: ✅ COMPLETADO

El fix del Opcode 0x08 (LD (nn), SP) desbloqueó el flujo de la CPU, permitiendo que el juego avance más allá de la dirección 0x2B10. Se procedió a limpiar toda la instrumentación de depuración para permitir la ejecución a velocidad nativa.

**Objetivo:**
- Eliminar logs de debug (Francotirador, Estetoscopio, marcadores radiactivos).
- Permitir que el juego complete su inicialización y encienda la pantalla.
- Ejecutar el emulador a velocidad nativa sin overhead de logging.

**Implementación:**
1. **Limpieza en `CPU.cpp`**: Eliminado `#include <cstdio>`, bloque del Francotirador (Step 0228), y printf del opcode 0x08 (Step 0232).
2. **Limpieza en `viboy.py`**: Eliminado bloque del Estetoscopio (Step 0230) que imprimía estado vital cada 60 frames.

**Concepto de Hardware:**
La instrumentación de depuración (logs, trazas) es esencial para diagnosticar problemas, pero tiene un costo en rendimiento y precisión. Una vez confirmado que un fix funciona, es crítico eliminar toda la instrumentación para permitir ejecución a velocidad real y sincronización precisa entre componentes.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Eliminados bloques de debug y `#include <cstdio>`
- `src/viboy.py` - Eliminado bloque del Estetoscopio

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/tetris.gb`
- Resultado esperado: Consola limpia, emulador ejecutando a velocidad real, pantalla de título de Tetris visible.

---

### 2025-12-22 - Step 0232: Hard Reset del Binario (Verificación de Código)
**Estado**: 🔧 EN PROCESO

El análisis de logs demostró que el fix del Opcode 0x08 (Step 0231) no se aplicó en el binario ejecutado: el PC solo avanzaba 1 byte en lugar de 3, indicando que el código nuevo no se estaba ejecutando. Esto sugiere un problema de persistencia de DLLs antiguas en Windows, donde los archivos `.pyd` se bloquean en memoria mientras Python está activo.

**Objetivo:**
- Forzar la recompilación real del núcleo C++ mediante limpieza agresiva de binarios.
- Confirmar visualmente que el código nuevo se está ejecutando mediante un "marcador radiactivo" (printf de debug).

**Implementación:**
1. **Modificación en `CPU.cpp`**: Añadido `printf("!!! EJECUTANDO OPCODE 0x08 EN C++ !!!\n")` dentro del `case 0x08` para confirmar su ejecución.
2. **Limpieza manual**: Proceso crítico de eliminación de carpeta `build/` y archivos `.pyd` antes de recompilar.

**Concepto de Hardware:**
En Windows, cuando Python carga una extensión compilada (`.pyd`), el sistema bloquea el archivo en memoria. Si intentas recompilar mientras Python tiene el módulo cargado, el compilador puede fallar silenciosamente o escribir en otra ubicación, dejando el binario antiguo activo.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido printf de debug en `case 0x08`

**Tests:**
- Cerrar todas las ventanas de Python/Viboy
- Eliminar carpeta `build/` y archivos `.pyd`
- Recompilar: `.\rebuild_cpp.ps1`
- Ejecutar: `python main.py roms/tetris.gb`
- Verificar: Buscar el mensaje `!!! EJECUTANDO OPCODE 0x08 EN C++ !!!` en la consola
- Si aparece, el código nuevo está activo y el PC debería avanzar 3 bytes correctamente.

---

### 2025-12-22 - Step 0231: Fix - Desalineamiento de CPU (Opcode 0x08)
**Estado**: 🔧 EN PROCESO

El análisis forense de la traza del "Francotirador" (Step 0228) reveló un error crítico de sincronización: el opcode `0x08` (`LD (nn), SP`) no estaba implementado. Esto causaba que la CPU interpretara los 2 bytes de dirección siguientes como instrucciones, desalineando completamente el flujo de ejecución y ejecutando "basura" que corrompía los flags y la lógica del juego.

**Objetivo:**
- Implementar `0x08` correctamente consumiendo 2 bytes adicionales para la dirección.
- Restaurar la alineación del flujo de instrucciones.
- Permitir que el juego avance correctamente en su secuencia de inicialización.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Añadido caso `0x08` en el switch de opcodes del método `step()`. La instrucción lee 2 bytes para la dirección (Little-Endian), escribe SP en esa dirección (también en Little-Endian), y consume 5 M-Cycles según Pan Docs.

**Concepto de Hardware:**
`LD (nn), SP` es una instrucción de 3 bytes que guarda el Stack Pointer en una dirección de memoria absoluta. Si no está implementada, la CPU trata el opcode como de 1 byte y luego interpreta los bytes 2 y 3 como nuevas instrucciones, causando desalineamiento y ejecución de código corrupto.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido caso `0x08` en el switch de opcodes

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1` o `python setup.py build_ext --inplace`
- Ejecutar: `python main.py roms/tetris.gb`
- Resultado esperado: La CPU ya no ejecuta opcodes `0x2F` y `0x3F` después de `0x08`. El juego debería avanzar más allá del punto de bloqueo anterior.

---

### 2025-12-22 - Step 0230: El Regreso del Estetoscopio (Diagnóstico en Vivo)
**Estado**: 🔍 EN DEPURACIÓN

A pesar de que el emulador corre a velocidad real tras eliminar los logs (Step 0229), la pantalla sigue mostrando el color de fondo (verde/blanco) y no hay gráficos. Esto indica que la PPU está apagada (`LCDC` bit 7 = 0) o no está renderizando. Reactivamos el monitor de estado periódico ("Estetoscopio", Step 0222) para observar el Program Counter (PC) y el registro `LCDC` en tiempo real y determinar si el juego está atascado en un bucle de carga o si ha fallado silenciosamente.

**Objetivo:**
- Monitorizar `PC` para ver si avanza o está estático en un bucle.
- Verificar `LCDC` para saber si el juego intenta encender la pantalla.
- Verificar `VRAM` (TileMap y TileData) para saber si el juego ha copiado gráficos.

**Implementación:**
1. **Modificación en `viboy.py`**: Reactivado bloque de diagnóstico "El Estetoscopio" en el método `run()`. El código imprime una línea de estado cada 60 frames (1 segundo) con los valores de PC, LCDC, TileMap[0x9904] y TileData[0x8010].

**Concepto de Hardware:**
Cuando un juego de Game Boy arranca, típicamente sigue esta secuencia: inicialización, carga de gráficos, configuración del TileMap, encendido del LCD, y bucle principal. Si la pantalla sigue verde después de eliminar los logs, puede ser porque el juego apagó la pantalla voluntariamente, está copiando gráficos (bucle largo), está atascado en un bucle infinito, o ha terminado y está esperando una interrupción. El Estetoscopio nos permite observar los signos vitales del emulador sin afectar el rendimiento.

**Archivos Afectados:**
- `src/viboy.py` - Reactivado bloque de diagnóstico "El Estetoscopio" en el método `run()` (líneas ~819-834)

**Tests:**
- Ejecutar: `python main.py roms/tetris.gb`
- Resultado esperado: Cada segundo aparece una línea `[VITAL] PC: XXXX | LCDC: XX | Map[9904]: XX | Data[8010]: XX`
- Análisis: Si PC cambia, la CPU está corriendo. Si PC está fijo, hay deadlock. Si LCDC bit 7 está encendido, el juego intenta encender la pantalla.

---

### 2025-12-22 - Step 0229: Silencio Total (Arranque a Velocidad Real)
**Estado**: ✅ COMPLETADO

Los logs del "Francotirador" (Step 0228) confirmaron que el hardware funciona correctamente: el registro `LY` avanza de 26 a 38, la CPU lee correctamente el registro, y no hay deadlock. El aparente bloqueo era causado por la latencia extrema de imprimir logs en cada ciclo de CPU. Se procedió a eliminar toda la instrumentación de depuración en C++ para permitir que el emulador alcance su velocidad nativa (60 FPS) y supere el bucle de espera de V-Blank en tiempo real.

**Objetivo:**
- Eliminar todos los `printf` del núcleo C++.
- Permitir la ejecución fluida del juego a velocidad nativa.
- Confirmar que el juego arranca completamente después de eliminar los logs.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Comentado el bloque del "Francotirador" (Step 0228) que imprimía logs cuando PC estaba en 0x2B10-0x2B20. También se comentó el `#include <cstdio>`.
2. **Modificación en `MMU.cpp`**: Comentado el "Sensor de VRAM" (Step 0204) que imprimía cuando se detectaba la primera escritura en VRAM.

**Concepto de Hardware:**
El Efecto del Observador: Imprimir texto en la consola (`printf`) es una operación extremadamente lenta comparada con la ejecución de una instrucción de CPU. Una llamada a `printf` puede tomar cientos o miles de microsegundos, mientras que una instrucción de CPU se ejecuta en nanosegundos. Si imprimimos un log en cada ciclo de CPU, el emulador se ralentiza miles de veces, haciendo que parezca que está colgado cuando en realidad solo está ejecutándose a "cámara super-lenta". Para llegar de la línea 38 a la 144, la Game Boy necesita aproximadamente 4 milisegundos en hardware real. Con los logs activados, esos 4 milisegundos se convertían en minutos.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Comentado bloque del Francotirador y `#include <cstdio>`
- `src/core/cpp/MMU.cpp` - Comentado bloque del Sensor de VRAM

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1` o `python setup.py build_ext --inplace`
- Ejecutar: `python main.py roms/tetris.gb`
- Resultado esperado: El emulador debe arrancar a velocidad nativa (60 FPS) y el juego debe avanzar más allá del bucle de espera de V-Blank.

---

### 2025-12-22 - Step 0228: El Francotirador en la Zona Alta (0x2B15)
**Estado**: 🔍 EN DEPURACIÓN

El fix de `LY=0` funcionó a la perfección. La PPU ahora se comporta como un hardware real. La autopsia reveló que la CPU ha escapado de la BIOS y está ejecutando código del juego en la zona alta de la ROM (PC: `0x2B15`), pero mantiene la pantalla apagada (LCDC: `0x08`). Para entender por qué la secuencia de carga se ha detenido, reactivamos el trazado quirúrgico centrado en la dirección donde la CPU pasa su tiempo ahora.

**Objetivo:**
- Identificar el bucle de código en `0x2B15`.
- Verificar si el juego está esperando al Timer (`DIV`) o una interrupción.
- Determinar si el bloqueo es por hardware (Timer, Interrupciones, Joypad) o lógico (bucle infinito).

**Implementación:**
1. **Modificación en `CPU.cpp`**: Reactivado el "Francotirador" (sniper) en el método `step()` para trazar instrucciones cuando PC está en el rango `0x2B10-0x2B20`. El trazado imprime PC, opcode, registros (AF, BC, DE, HL) y el valor del Timer (DIV) para analizar el comportamiento.

**Concepto de Hardware:**
Cuando un juego de Game Boy inicia, típicamente sigue esta secuencia: (1) Fase de Arranque (BIOS), (2) Transferencia de Control al cartucho, (3) Inicialización del Juego (apaga pantalla, carga gráficos, configura paletas, vuelve a encenderla). El hecho de que la CPU esté en `0x2B15` (zona alta de la ROM) indica que el juego ha superado la fase de arranque. Sin embargo, si el juego mantiene la pantalla apagada y no avanza, puede estar esperando: Timer (DIV), Interrupciones, Joypad, o puede estar en un bucle infinito. El trazado quirúrgico nos permitirá ver exactamente qué instrucciones está ejecutando la CPU y qué registros está consultando.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido bloque de debug quirúrgico en `step()` para rango 0x2B10-0x2B20

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1` o `python setup.py build_ext --inplace`
- Ejecutar: `python main.py roms/tetris.gb`
- Analizar salida: Buscar líneas con `[SNIPER]` en la consola
- Lo que buscamos:
  - Si el código lee `0xFF04` (DIV) y compara, es un problema de Timer.
  - Si el código lee `0xFF00` (Joypad), está esperando un botón.
  - Si es un salto incondicional `JR -1`, es un cuelgue explícito (Game Over del emulador).

---

### 2025-12-22 - Step 0227: Fix - Comportamiento de LCD Apagado (Reset LY)
**Estado**: 🔧 EN PROCESO

La autopsia del Step 0225 reveló que la PPU seguía incrementando `LY` (valor 97) a pesar de que el LCD estaba apagado (`LCDC Bit 7 = 0`). Esto viola la especificación del hardware (Pan Docs), que dicta que cuando el LCD se deshabilita, la PPU se detiene inmediatamente y el registro `LY` debe reiniciarse y mantenerse en 0. Este comportamiento errático puede desincronizar la lógica de reinicio de pantalla del juego.

**Objetivo:**
- Forzar `LY = 0`, `clock = 0` y `mode = 0` (H-Blank) en `PPU::step()` cuando el LCD está apagado.
- Asegurar que cuando el juego vuelve a encender el LCD, encuentra `LY` en 0 como espera.

**Implementación:**
1. **Modificación en `PPU.cpp`**: Actualizado el bloque de verificación de LCD apagado en `step()` para resetear explícitamente los contadores internos (`ly_ = 0`, `clock_ = 0`, `mode_ = MODE_0_HBLANK`) en lugar de solo retornar. Esto garantiza que el estado interno de la PPU refleje correctamente que el LCD está deshabilitado.

**Concepto de Hardware:**
Según Pan Docs, cuando el bit 7 de LCDC (LCD Enable) es 0, la PPU se apaga inmediatamente. El registro LY (0xFF44) se resetea a 0 y permanece fijo en ese valor mientras el LCD esté deshabilitado. El reloj interno de la PPU también se detiene. Esta es una característica crítica del hardware que los juegos utilizan para sincronizar el reinicio de la pantalla. Si LY no está en 0 cuando el juego vuelve a encender el LCD, puede confundirse sobre en qué línea se encuentra y fallar al renderizar.

**Archivos Afectados:**
- `src/core/cpp/PPU.cpp` - Modificado `step()` para resetear contadores cuando LCD está apagado

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1` o `python setup.py build_ext --inplace`
- Ejecutar: `python main.py roms/tetris.gb`
- Verificar en la autopsia que `LY` sea 0 cuando `LCDC` tiene el bit 7 apagado

---

### 2025-12-22 - Step 0226: El Testigo de LY (Verificación de Lectura)
**Estado**: 🔍 EN DEPURACIÓN

La autopsia confirmó que la CPU está atascada esperando V-Blank (`LY=144`) con la VRAM vacía. Para entender por qué el bucle de espera nunca termina, instrumentamos `MMU::read` para verificar si la CPU está leyendo correctamente el registro `LY` y si este valor cambia con el tiempo.

**Objetivo:**
- Confirmar que la CPU lee la dirección `0xFF44`.
- Verificar si el valor leído se incrementa hasta 144.
- Determinar si hay una desincronización entre la CPU y la PPU.

**Implementación:**
1. **Modificación en `MMU.cpp`**: Añadido bloque de debug para LY (0xFF44) en el método `read()`. El código está comentado por defecto para evitar saturar la consola, pero puede activarse descomentando una línea.
   - El debug imprime el valor de LY cada vez que la CPU lee el registro.
   - Para activar: Descomentar el `printf` y redirigir la salida a un archivo: `python main.py roms/tetris.gb > ly_log.txt 2>&1`

**Concepto de Hardware:**
El registro LY (0xFF44) es de solo lectura y contiene la línea de escaneo actual (0-153). Los juegos esperan a que LY llegue a 144 (V-Blank) antes de copiar datos gráficos. Si la CPU nunca ve LY=144, el bucle de espera se ejecuta indefinidamente.

**Archivos Afectados:**
- `src/core/cpp/MMU.cpp` - Añadido bloque de debug para LY (0xFF44)

**Tests:**
- Recompilar: `.\rebuild_cpp.ps1` o `python setup.py build_ext --inplace`
- Activar debug: Descomentar el `printf` en `MMU.cpp`
- Ejecutar con redirección: `python main.py roms/tetris.gb > ly_log.txt 2>&1`
- Interrumpir tras 2-3 segundos (Ctrl+C)
- Buscar en `ly_log.txt` si aparece el valor 144

---

### 2025-12-22 - Step 0225: La Autopsia de los 3 Segundos
**Estado**: 🔍 EN PROCESO

Ante la persistencia de la pantalla en blanco (verde) sin errores aparentes, cambiamos la estrategia de depuración. En lugar de trazar la ejecución paso a paso (que introduce latencia y distorsiona el comportamiento), dejamos correr el emulador durante 3 segundos (180 frames) y realizamos un volcado de estado completo ("Autopsia"). Esto revelará si el juego logró avanzar más allá de la inicialización, si configuró los registros de vídeo correctamente y si llegó a escribir datos gráficos en la VRAM.

**Objetivo:**
- Obtener una "foto" del estado interno tras la secuencia de arranque.
- Determinar si el fallo es de CPU (atascada), Lógico (LCDC apagado) o de Datos (VRAM vacía).

**Implementación:**
1. **Modificación en `viboy.py`**: Añadido bloque de autopsia en el método `run()` que se ejecuta una sola vez cuando `frame_count >= 180`. El bloque imprime:
   - Estado de la CPU (PC, SP, registros AF/BC/DE/HL, flags, estado HALT)
   - Registros de vídeo (LCDC, STAT, LY, BGP)
   - Muestra de VRAM Tile Data (0x8010-0x801F)
   - Muestra de VRAM Tile Map (0x9900-0x990F)
   - Estado de interrupciones (IE, IF)
   - Estadísticas del sistema (ciclos totales, frames)

**Concepto de Hardware:**
Cuando un juego de Game Boy arranca, sigue una secuencia típica: inicialización → espera V-Blank → copia gráficos → configura mapa → habilita pantalla → configura paleta. Si el emulador funciona a 60 FPS, en 3 segundos habrá ejecutado millones de ciclos. El estado después de 3 segundos responde preguntas binarias: ¿avanzó la CPU? ¿Se configuró LCDC? ¿Se escribió VRAM? Esto reduce el espacio de búsqueda del problema.

**Interpretación de la Autopsia:**
- **Si PC sigue en 0x02B4 (o cerca):** El problema es el **Timing**. La CPU no ve avanzar a LY.
- **Si BGP es 0x00:** El juego corre pero **la paleta está negra/blanca**. (Tetris escribe `0xFC` o `0xE4`).
- **Si LCDC Bit 0 es OFF:** El juego corre pero **no ha encendido la pantalla**.
- **Si VRAM Tile Data son todos 0x00:** El juego corre pero **no copia gráficos** (falla DMA o `LDI/LDD`).
- **Si VRAM Tile Map son todos 0x00:** El juego tiene gráficos pero **el mapa está vacío** (dibuja el tile 0 en todas partes).

**Archivos Afectados:**
- `src/viboy.py` - Añadido bloque de autopsia en el método `run()`

**Tests:**
- Ejecutar `python main.py roms/tetris.gb` y esperar 3 segundos.
- Analizar el volcado de estado completo en la consola.
- Interpretar los valores para determinar el tipo de fallo (Timing, Lógico, o Datos).

---

### 2025-12-22 - Step 0224: Cese el Fuego (Ejecución Final)
**Estado**: ✅ COMPLETADO

El debug quirúrgico confirmó que la CPU estaba funcionando correctamente, esperando a que `LY` llegara a 144 (V-Blank). La aparente congelación se debía a la latencia introducida por los logs de consola. Se retiró toda la instrumentación de debug (Francotirador y Estetoscopio) para permitir la ejecución a velocidad nativa.

**Objetivo:**
- Eliminar logs de Francotirador y Estetoscopio.
- Confirmar la carga y visualización de Tetris.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Eliminado el bloque del Francotirador (Step 0223) y comentado el include de `<cstdio>`.
2. **Modificación en `viboy.py`**: Comentado el bloque del Estetoscopio (Step 0222).

**Concepto de Hardware:**
Un frame de Game Boy (0 a 144 líneas) dura 16 milisegundos. Con logs activos, imprimiendo cada instrucción del bucle de espera de V-Blank, llegar a la línea 144 puede tardar minutos en tiempo real. Al eliminar los logs, el bucle se completa en una fracción de segundo y el juego procede normalmente.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Eliminado bloque del Francotirador
- `src/viboy.py` - Comentado bloque del Estetoscopio

**Tests:**
- Ejecutar `.\rebuild_cpp.ps1` para recompilar sin logs.
- Ejecutar `python main.py roms/tetris.gb` y verificar que el juego carga y muestra gráficos a 60 FPS.

---

### 2025-12-22 - Step 0223: El Francotirador (Debug Quirúrgico en 0x02B4)
**Estado**: ✅ COMPLETADO (Instrumentación retirada en Step 0224)

El estetoscopio reveló que la CPU está atrapada en un bucle en `0x02B4`, con el fondo apagado y la VRAM vacía. Para entender qué condición de salida no se está cumpliendo (probablemente esperando V-Blank o un estado específico de hardware), implementamos un trazado condicional que solo se activa cuando el PC está en el rango `0x02B0-0x02C0`. Esta instrumentación quirúrgica nos permitirá ver las instrucciones del bucle y los valores de los registros sin saturar la consola.

**Objetivo:**
- Identificar las instrucciones exactas del bucle en `0x02B4`.
- Ver el estado de los registros (especialmente AF) y LY durante el bucle.
- Determinar si el juego está esperando V-Blank (LY = 144) o algún otro estado de hardware.

**Implementación:**
1. **Modificación en `CPU.cpp`**: Añadido bloque de debug condicional en el método `step()` que solo imprime cuando `regs_->pc >= 0x02B0 && regs_->pc <= 0x02C0`. El log incluye: PC, Opcode, AF (flags y acumulador), y LY (línea de escaneo actual).

**Concepto de Hardware:**
Muchos juegos de Game Boy esperan V-Blank antes de copiar gráficos a VRAM porque es el único momento "seguro" en que la PPU no está leyendo VRAM. El juego típicamente hace polling del registro LY (0xFF44) en un bucle hasta que LY alcanza 144 (0x90), momento en que la PPU entra en modo V-Blank. Si LY nunca alcanza 144 (porque la PPU no está actualizando el registro o no está entrando en V-Blank), el juego se queda atascado en este bucle infinitamente. El "Francotirador" nos permitirá ver exactamente qué instrucciones se están ejecutando y qué valores están comparando.

**Archivos Afectados:**
- `src/core/cpp/CPU.cpp` - Añadido bloque de debug quirúrgico "El Francotirador" en el método `step()`

**Tests:**
- Ejecutar `.\rebuild_cpp.ps1` para recompilar la extensión Cython.
- Ejecutar `python main.py roms/tetris.gb` y observar la salida de la consola. Deberían aparecer líneas `[SNIPER] PC: 0x02B4 | Opcode: 0xXX | AF: 0xXXXX | LY: XX`. Analizar el patrón para identificar si el juego está esperando V-Blank (LDH A, (0x44) seguido de CP 0x90) o algún otro estado.

---

### 2025-12-22 - Step 0222: El Estetoscopio (Diagnóstico de Estado en Vivo)
**Estado**: 🔍 EN DEPURACIÓN

Tras la limpieza final, la pantalla aparece verde (vacía). Para diagnosticar por qué el juego no muestra gráficos sin recurrir a logs masivos, implementamos un monitor de estado en Python que imprime signos vitales (PC, LCDC, VRAM) una vez por segundo. Esto nos revelará si la CPU está atascada o si el hardware gráfico no está configurado como esperamos.

**Objetivo:**
- Monitorizar PC para ver si el emulador avanza.
- Verificar LCDC para ver si el fondo está habilitado (Bit 0).
- Verificar VRAM para ver si el logo se ha copiado.

**Implementación:**
1. **Modificación en `viboy.py`**: Añadido bloque de diagnóstico en el método `run()` que se ejecuta cada 60 frames (1 segundo). El diagnóstico lee directamente del hardware: PC, LCDC (0xFF40), TileMap[0x9904], y TileData[0x8010].

**Concepto de Hardware:**
Cuando la pantalla aparece completamente verde (Color 0), significa que el renderizador funciona (dibuja el color de fondo) y la PPU funciona (envía índices 0), pero la PPU solo envía ceros. Esto puede ocurrir porque: (1) LCDC Bit 0 está apagado (el juego no ha activado el fondo), (2) VRAM está vacía (el juego no ha copiado los gráficos), o (3) TileMap está vacío (el juego no ha configurado qué tiles dibujar). Sin logs masivos, es imposible saber si la CPU está ejecutando código o si está en un bucle infinito. El "estetoscopio" es una sonda no intrusiva que imprime información clave cada 60 frames sin afectar el rendimiento.

**Archivos Afectados:**
- `src/viboy.py` - Añadido bloque de diagnóstico "El Estetoscopio" en el método `run()`

**Tests:**
- Ejecutar `python main.py roms/tetris.gb` y observar la salida de la consola. Cada segundo aparecerá una línea `[VITAL] PC: XXXX | LCDC: XX | Map[9904]: XX | Data[8010]: XX`. Analizar los valores para determinar si la CPU está corriendo, si el LCDC está configurado, y si la VRAM contiene datos.

---

### 2025-12-22 - Step 0220: El Amanecer de Tetris (Limpieza Final)
**Estado**: ✅ COMPLETADO

Tras confirmar visualmente el funcionamiento de todo el pipeline con el "Test de la Caja Azul", se retiraron todas las herramientas de diagnóstico, hacks visuales y sondas de datos. Se restauró la lógica original de lectura de VRAM en C++ y la paleta de colores correcta en Python. El sistema está ahora limpio y operando con precisión de hardware.

**Objetivo:**
- Restaurar el código a su estado de producción.
- Ejecutar Tetris y visualizar los gráficos reales del juego.

**Implementación:**
1. **Restauración en `renderer.py`**: Eliminado el cuadro azul de prueba y el forzado de color rojo en la paleta. Mantenida la lógica robusta de renderizado.
2. **Restauración en `PPU.cpp`**: Eliminado el "Test del Rotulador Negro" (rayas verticales forzadas). Restaurada la lógica original de lectura de VRAM con validación correcta.
3. **Limpieza en `viboy.py`**: Eliminados los prints de sondas de datos. Mantenida la lógica del `bytearray` (buena práctica defensiva).

**Concepto de Hardware:**
Durante la fase de depuración, implementamos múltiples "andamios" (scaffolding) para diagnosticar problemas: hacks visuales, paleta de debug, test del rotulador negro, y sondas de datos. Estos andamios cumplieron su propósito confirmando que cada componente funciona correctamente. Sin embargo, en producción, estos hacks interfieren con el renderizado real del juego. La restauración elimina todos estos andamios y deja solo la lógica limpia y precisa del hardware.

**Archivos Afectados:**
- `src/gpu/renderer.py` - Eliminación de hacks visuales y restauración de paleta
- `src/core/cpp/PPU.cpp` - Restauración de lógica VRAM y eliminación de sondas
- `src/viboy.py` - Eliminación de sondas de datos

**Tests:**
- Ejecutar `python main.py roms/tetris.gb` y verificar que se muestren los gráficos reales del juego (pantalla de copyright o logo de Nintendo cayendo).
- Verificar que no haya rayas rojas ni cuadros azules, solo la emulación pura.

---

### 2025-12-22 - Step 0219: Fix - Snapshot de Memoria (Bytearray Copy)
**Estado**: 🔧 EN PROCESO

Se detectó una discrepancia de datos: la sonda principal leía `3` pero el renderizador leía `0`. Para solucionar esto y desacoplar el renderizado de la memoria volátil de C++, implementamos una copia obligatoria (`bytearray`) del framebuffer en el momento exacto en que el frame está listo. Esto garantiza que el renderizador trabaje con datos estables.

**Objetivo:**
- Forzar una copia `bytearray` en `viboy.py`.
- Lograr que el renderizador reciba y dibuje los valores `3` (Rojo).
- Eliminar condiciones de carrera entre C++ y Python.

**Implementación:**
1. **Modificación en `viboy.py`**: Se reemplazó la verificación de `current_ly == 144` por `get_frame_ready_and_reset()`, y se cambió la copia de `bytes(fb_view)` a `bytearray(raw_view)` para garantizar que la copia es mutable y vive completamente en Python.
2. **Modificación en `renderer.py`**: Se añadió el parámetro opcional `framebuffer_data: bytearray | None = None` al método `render_frame()`. Si se proporciona, se usa ese snapshot en lugar de leer desde la PPU.

**Concepto de Hardware:**
En la arquitectura híbrida Python/C++, el framebuffer vive en memoria C++ y se expone a Python mediante un `memoryview` (vista de memoria). Un `memoryview` es una referencia directa a la memoria subyacente: si C++ modifica esa memoria (por ejemplo, limpiando el framebuffer para el siguiente frame), el `memoryview` reflejará inmediatamente esos cambios. La solución es hacer una copia inmutable (`bytearray`) del framebuffer en el momento exacto en que sabemos que está completo y correcto. Esta copia vive en la memoria de Python y no puede ser modificada por C++, garantizando que el renderizador siempre trabaje con datos estables.

**Archivos Afectados:**
- `src/viboy.py` - Modificación del método `run()` para captura de snapshot (líneas 753-789)
- `src/gpu/renderer.py` - Modificación del método `render_frame()` para aceptar snapshot (líneas 414-444)

**Tests:**
- Ejecutar `python main.py roms/tetris.gb` y verificar que ambas sondas muestren el mismo valor (3).
- Verificar que la pantalla muestre rayas rojas verticales de fondo + cuadro azul en el centro.

---

