# Bitácora de Desarrollo - Fase 2 (v0.0.2)

**Objetivo**: Migración del Núcleo a C++/Cython y Audio (APU).

**Estado**: En desarrollo.

---

## Objetivos Principales de la Fase 2

### 1. Migración del Núcleo a C++/Cython
- [ ] Reescritura de CPU (LR35902) en C++ con wrapper Cython
- [x] Migración de MMU a código compilado
- [x] Migración de PPU a código compilado (Fase A: Timing y Estado)
- [ ] Optimización de sincronización ciclo a ciclo
- [ ] Mantener interfaz Python para frontend y tests

### 2. Implementación de Audio (APU)
- [ ] Canal 1: Onda cuadrada con Sweep y Envelope
- [ ] Canal 2: Onda cuadrada con Envelope
- [ ] Canal 3: Onda arbitraria (Wave RAM)
- [ ] Canal 4: Ruido blanco (LFSR)
- [ ] Mezcla de canales y salida a 44100Hz/48000Hz
- [ ] Sincronización de audio con emulación (Dynamic Rate Control o Ring Buffer)

### 3. Mejoras de Arquitectura
- [x] Arquitectura híbrida Python/C++ establecida
- [ ] Gestión de memoria optimizada
- [ ] Tests híbridos (Python instancia Cython -> Cython llama C++)

---

## Entradas de Desarrollo

### 2026-01-02 - Step 0418: Repo Hygiene: Step Order + Informe Dividido
**Estado**: ✅ Completado

**Objetivo**: Restaurar coherencia del repositorio antes de continuar con PPU/Zelda: organizar el informe dividido (`docs/informe_fase_2/`) cumpliendo rangos declarados, eliminar duplicados, y resolver stashes pendientes.

**Contexto**: El archivo `parte_00_steps_0370_0412.md` indicaba rango hasta 0412 pero contenía Steps hasta 0417. El índice (`index.md`) declaraba "370-416" pero el archivo tenía hasta 0417. Existían 4 versiones duplicadas (0378, 0379, 0401, 0412) sin limpiar. Dos stashes pendientes con código sin clasificar.

**Concepto: Gestión de Documentación en Proyectos Grandes**:
- **Informe Dividido**: Límite de ~2000 líneas por archivo para facilitar lectura por humanos y agentes IA
- **Rangos Explícitos**: Nombres de archivo indican rango de contenido (ej: `parte_01_steps_0412_0450.md`)
- **Índice Central**: `index.md` lista todas las partes con rangos actualizados
- **No Duplicación**: Un Step debe aparecer en exactamente una parte
- **Gestión de Stashes**: Clasificar (Tipo A: docs-only vs Tipo B: código), Analizar (comparar con HEAD), Decidir (aplicar/aparcar/descartar)

**Implementación**:

1. **T1: Auditoría**: Identificación del estado actual (HEAD `7da1360`, 2 stashes Tipo B, parte_00 con 5365 líneas hasta Step 0417, 4 duplicados)

2. **T2: Reorganización del Informe Dividido**:
   - Creación de `parte_01_steps_0412_0450.md` (535 líneas, 6 Steps: 0412-0417)
   - Corrección de `parte_00_steps_0370_0411.md` (4863 líneas, 42 Steps: 0370-0411)
   - Renumeración: 01→02, 02→03, 03→04, 04→05, 05→06, 06→07
   - Eliminación de duplicados: 4 archivos `parte_00_steps_0370_*.md` obsoletos
   - Actualización de `index.md` con rangos correctos

3. **T3: Resolución de Stashes**:
   - `stash@{0}`: "WIP before STEP0417A diag" - Contenía código de Step 0416 [REVERTIDO] en `PPU.cpp` → **DESCARTADO**
   - `stash@{1}`: "WIP preflight baseline" - Contenía código de Step 0415 [REVERTIDO] en `MMU.cpp`/`PPU.cpp`/`renderer.py` → **DESCARTADO**
   - Decisión: Ambos stashes eran código obsoleto ya revertido en HEAD

4. **T4: Verificación**:
   - BUILD: Exit 0 ✅
   - TEST_BUILD: Exit 0 ✅
   - PYTEST: Exit 1 (10 failed, 17 passed - tests ALU pre-existentes) ⚠️
   - PYTEST_CPU: Exit 0 (6/6 passed) ✅

**Archivos afectados**:
- **Creados**: `parte_01_steps_0412_0450.md`, `2026-01-02__0418__repo-hygiene-step-order-informe-dividido.html`
- **Modificados**: `parte_00_steps_0370_0411.md`, `index.md`, `bitacora/index.html`
- **Renombrados**: 6 archivos de partes (01-06 → 02-07)
- **Eliminados**: 4 duplicados obsoletos

**Tests y Verificación**:
- **Verificación de rangos**: `parte_00` no contiene Steps 0413+ ✅, `parte_01` contiene Steps 0412-0417 ✅
- **Comandos**: `python3 setup.py build_ext --inplace` (Exit 0), `pytest tests/test_core_cpu.py` (6/6)
- **Validación**: Este Step es **docs-only**, sin cambios en código fuente

**Tabla de Verificación Post-Reorganización**:

| Step | Archivo Informe | Entry HTML | Estado |
|------|----------------|------------|--------|
| 0414 | parte_01 (línea 202) | ✅ Existe | ✅ OK |
| 0415 | parte_01 (línea 158) | ✅ Existe | ✅ OK |
| 0416 | parte_01 (línea 115) | ✅ Existe | ✅ OK |
| 0417 | parte_01 (línea 35) | ✅ Existe | ✅ OK |
| 0418 | parte_01 (esta entrada) | ✅ Esta entrada | ✅ OK |

**Conclusión**: Repositorio limpio y coherente. Sistema de informe dividido cumple rangos declarados. Stashes resueltos sin contaminar `develop`. ✅ Compilación exitosa. ✅ Tests CPU pasando. Step docs-only sin regresiones de código.

**Próximos pasos**: Continuar con investigación PPU/Zelda-DX (problema de framebuffer blanco del Step 0416). Mantener informe dividido actualizado. Crear nueva parte cuando `parte_01` exceda 2000 líneas.

---

### 2026-01-02 - Step 0417: Fix CPU Unit Tests (Ejecutar desde WRAM)
**Estado**: ✅ Completado

**Objetivo**: Refactorizar el harness de tests unitarios de CPU para ejecutar programas de prueba desde WRAM (0xC000) en lugar de intentar escribir en ROM (0x0000-0x7FFF). Resolver el problema de que los tests estaban escribiendo en direcciones ROM donde `PyMMU.write()` no escribe memoria (solo controla MBC), causando que la CPU ejecutara NOPs (0x00) en lugar de las instrucciones reales.

**Contexto**: Los tests unitarios de CPU en `tests/test_core_cpu.py` escribían opcodes en direcciones ROM (0x0000) usando `mmu.write(0x0000, opcode)`, pero en la implementación real de MMU, escribir a ROM no modifica la memoria (ROM es read-only). Esto causaba que:
1. La CPU leyera 0x00 (NOP) en lugar del opcode esperado
2. Los tests pasaran por razones incorrectas (ejecutando NOPs en lugar de instrucciones reales)
3. El test de "opcode desconocido" usaba 0xFF (RST 38h), que está implementado, por lo que fallaba

**Concepto de Hardware: Mapa de Memoria Game Boy (Pan Docs - Memory Map)**:

El Game Boy tiene un mapa de memoria bien definido:
- **0x0000-0x7FFF**: ROM (Read Only Memory) - ❌ No escribible (escrituras controlan MBC)
- **0x8000-0x9FFF**: VRAM - ✅ Escribible (excepto Mode 3)
- **0xA000-0xBFFF**: External RAM (Cartridge) - ✅ Escribible
- **0xC000-0xDFFF**: WRAM (Work RAM) - ✅ Escribible (RAM interna)
- **0xE000-0xFDFF**: Echo RAM - ✅ Escribible (espejo de WRAM)
- **0xFE00-0xFE9F**: OAM (Sprite Attribute Table) - ✅ Escribible (excepto Mode 2/3)
- **0xFF00-0xFF7F**: I/O Registers - ✅ Escribible
- **0xFF80-0xFFFE**: HRAM (High RAM) - ✅ Escribible
- **0xFFFF**: IE Register - ✅ Escribible

**Solución**: Ejecutar programas de test desde WRAM (0xC000), que es memoria escribible y legible. Los juegos reales usan WRAM para código temporal, stacks de llamadas, y buffers. Ejecutar tests desde WRAM es más realista que modificar la MMU para permitir escrituras a ROM (contaminaría emulación real).

**Implementación**:

1. **Helper de carga de programas** (`tests/helpers_cpu.py`):
   - Constante `TEST_EXEC_BASE = 0xC000` (dirección base en WRAM)
   - Función `load_program(mmu, regs, program_bytes, start_addr=TEST_EXEC_BASE)`:
     - Escribe cada byte del programa en WRAM
     - Configura `regs.pc = start_addr`
     - Verifica escritura con read-back check

2. **Refactorización de tests** (`tests/test_core_cpu.py`):
   - Import del helper: `from .helpers_cpu import load_program, TEST_EXEC_BASE`
   - Cambio de patrón en los 6 tests:
     - **Antes**: `mmu.write(0x0000, opcode); regs.pc = 0x0000`
     - **Después**: `load_program(mmu, regs, [opcode, imm...])`
   - Ajuste de asserts: `assert regs.pc == TEST_EXEC_BASE + offset`

3. **Corrección de test de opcode desconocido**:
   - **Problema**: Usaba 0xFF (RST 38h), que está implementado (retorna 4 M-Cycles)
   - **Solución**: Cambiar a 0xD3, un opcode ilegal en Game Boy (no definido en instruction set)
   - **Resultado**: Test ahora valida correctamente que opcodes desconocidos retornan 0

**Archivos afectados**:
- `tests/helpers_cpu.py` (creado) - Helper de carga de programas para tests
- `tests/test_core_cpu.py` (modificado) - 6 tests refactorizados para ejecutar desde WRAM

**Tests refactorizados**:
1. `test_nop_instruction` - NOP en WRAM
2. `test_ld_a_d8_instruction` - LD A, d8 en WRAM
3. `test_ld_a_d8_multiple_executions` - Múltiples LD en WRAM
4. `test_unknown_opcode_returns_zero` - Opcode ilegal 0xD3
5. `test_cpu_with_shared_mmu_and_registers` - Inyección de dependencias en WRAM
6. `test_cpu_initialization` - (no requiere cambio, no usa memoria)

**Tests y Verificación**:
- **Comando**: `pytest -v tests/test_core_cpu.py`
- **Resultado**: `6 passed in 0.36s` (100% success rate)
- **Validación de módulo compilado C++**: ✅ Los tests validan `viboy_core.so` (C++/Cython)
- **Test clave individual**: `pytest -v tests/test_core_cpu.py::TestCoreCPU::test_ld_a_d8_instruction` → `1 passed in 0.47s`

**Descubrimientos**:
- ✅ El opcode 0xFF (RST 38h) está implementado correctamente (retorna 4 M-Cycles, hace PUSH PC y salta a 0x0038)
- ✅ El opcode 0xD3 es realmente desconocido (ilegal en Game Boy, retorna 0)
- ✅ Los tests ahora ejecutan las instrucciones reales en lugar de NOPs

**Beneficios**:
1. **Robustez**: Los tests ahora validan las instrucciones reales que están implementadas
2. **Realismo**: Ejecutar desde WRAM es más cercano a cómo funcionan los juegos reales
3. **Mantenibilidad**: Helper reutilizable (`load_program()`) para futuros tests de CPU
4. **Integridad**: No se modificó la MMU para permitir escrituras a ROM (no contamina emulación real)
5. **Descubrimiento**: Identificación de que RST 38h está implementado correctamente

**Próximos pasos**: Usar este patrón (ejecutar desde WRAM) para todos los nuevos tests de CPU. Expandir cobertura de tests a más opcodes y edge cases (flags, overflows, etc.).

---

### 2026-01-02 - Step 0416: Fix PPU: framebuffer blanco con TileData alta (render_bg/render_window/swap) [REVERTIDO]
**Estado**: ⚠️ DRAFT/REVERTIDO

**Objetivo**: Corregir el criterio de gating `vram_has_tiles_` que era demasiado estricto para juegos CGB con tiledata alta pero baja diversidad de tile IDs únicos. El problema se manifestaba en juegos como `tetris_dx.gbc` y `zelda-dx.gbc` que reportaban TileData alta pero el framebuffer quedaba completamente blanco.

**Contexto**: En Step 0415, los logs mostraban que `tetris_dx.gbc` y `zelda-dx.gbc` tenían `tiledata_effective` alta (56.6% y 79.0% respectivamente) pero `fb_nonzero=0/23040` (framebuffer completamente blanco). El análisis reveló que el criterio de `vram_has_tiles_` requería diversidad >= 5 tile IDs únicos, pero `zelda-dx.gbc` solo tenía 1 tile ID único, causando que `vram_has_tiles_` fuera false aunque había tiledata válida.

**Concepto de Hardware: Criterio de Detección de Tiles en VRAM**:
- La PPU necesita determinar cuándo hay tiles válidos en VRAM para decidir si renderizar el fondo o mostrar un patrón de prueba (checkerboard).
- En juegos reales, especialmente durante inicialización o transiciones de pantalla, puede haber situaciones donde hay datos de tiles cargados pero con baja diversidad de tile IDs únicos en el tilemap.
- **Problema**: El criterio anterior requería tanto datos de tiles (`tiledata_nonzero >= 200` o `complete_tiles >= 10`) **Y** diversidad en el tilemap (`unique_tile_ids >= 5`). Esto causaba falsos negativos en juegos CGB como `zelda-dx.gbc` que tienen tiledata alta pero solo 1 tile ID único.
- **Solución Intentada (Revertida)**: Relajar el criterio para modo CGB: si `tiledata_effective >= 200` y `unique_tile_ids >= 1`, permitir render aunque la diversidad sea baja. Fuente: Pan Docs - "Video RAM", "Tile Data", "Background Tile Map".

**Implementación (Cambios Revertidos)**:
- Modificación del criterio de `vram_has_tiles_` en `PPU::render_scanline()` (líneas ~1559-1578).
- Cálculo de `tiledata_effective` como máximo entre bank0 y bank1 para CGB.
- Override condicional: `cgb_high_tiledata_override = (tiledata_effective >= 200) && (unique_tile_ids >= 1)`.
- Nuevo criterio: `vram_has_tiles_ = has_tiles_data && (has_tilemap_diversity || cgb_high_tiledata_override)`.

**Archivos afectados**:
- `src/core/cpp/PPU.cpp` - Relajación del criterio de `vram_has_tiles_` (líneas ~1559-1578) - **CAMBIOS REVERTIDOS**

**Tests y Verificación**:
- **Comando**: Suite paralela de 2 minutos con todas las ROMs (estándar Step 0414).
- **Resultado**: ✅ Suite completada. `tetris_dx.gbc`: mejora significativa (`[VRAM-STATE-CHANGE] Frame 676 | has_tiles: 0 -> 1`), CGB-RGB-CHECK muestra "Non-white pixels: YES". `zelda-dx.gbc`: activación correcta de `vram_has_tiles_` (`Frame 13 | has_tiles: 0 -> 1`), pero framebuffer sigue blanco (requiere investigación adicional).
- **Validación de módulo compilado C++**: ✅ Compilación exitosa.

**Análisis Post-Mortem**:
1. **El gating no es el único problema**: Aunque `vram_has_tiles_` se activa correctamente en `zelda-dx.gbc`, el framebuffer sigue blanco.
2. **Diversidad baja puede ser válida**: `zelda-dx.gbc` tiene 352 tiles completos pero solo 1 tile ID único (posiblemente carga el mismo tile en toda la pantalla durante inicialización).
3. **Problema más profundo**: El renderizado inline no usa `vram_has_tiles_` como gating (el bucle for en `render_scanline()` no verifica este flag), por lo que debe haber otro problema en el pipeline de renderizado.

**Por qué se Revirtió**:
- El cambio mejora el comportamiento de `tetris_dx.gbc` pero no resuelve `zelda-dx.gbc`.
- El criterio relajado podría causar falsos positivos en otros juegos.
- Se necesita una investigación más profunda del pipeline de renderizado antes de modificar el gating.

**Conclusión**: Este Step documentó un intento de corrección que fue revertido porque no resolvió completamente el problema del framebuffer blanco. Los cambios fueron beneficiosos para `tetris_dx.gbc` pero insuficientes para `zelda-dx.gbc`. El análisis reveló que el problema no es solo el gating de `vram_has_tiles_` sino que hay un problema más profundo en el pipeline de renderizado.

**Próximos pasos sugeridos**: Instrumentar el bucle de renderizado inline, verificar `swap_framebuffers()`, auditar `get_tile_color_for_bg()`, considerar problemas específicos de CGB (bancos de VRAM, paletas CGB).

---

### 2026-01-02 - Step 0415: Fix test_build.py Runner (Root)
**Estado**: ✅ Completado

**Objetivo**: Corregir el checkpoint obligatorio `test_build.py` que verifica la compilación del módulo C++/Cython. El script estaba ubicado en `tests/temp/test_build.py` y fallaba al ejecutarse desde subdirectorios por problemas de `sys.path`. Crear un runner robusto en la raíz del repositorio que maneje correctamente el `sys.path` y pueda ejecutarse desde cualquier ubicación.

**Contexto**: Durante el pre-flight check (baseline), se identificó que `test_build.py` no existía en la raíz del repositorio donde se esperaba según la metodología del proyecto. El script existía en `tests/temp/test_build.py` pero fallaba con el error `No module named 'viboy_core'` al ejecutarse debido a que Python no encontraba el módulo compilado cuando se ejecutaba desde un subdirectorio.

**Concepto Técnico: sys.path y Resolución de Módulos en Python**:
- Cuando Python ejecuta un script, agrega el directorio donde está ubicado ese script al principio de `sys.path` (la lista de rutas donde Python busca módulos).
- Si el script se ejecuta desde un subdirectorio, Python intentará importar módulos relativos a ese subdirectorio, no a la raíz del proyecto.
- **Problema identificado**: Al ejecutar `tests/temp/test_build.py` directamente, Python establece `sys.path[0] = tests/temp/`, lo que impide encontrar el módulo `viboy_core` que está compilado en la raíz del proyecto.
- **Solución**: Colocar el script principal en la raíz del repositorio y asegurar que el directorio raíz esté en `sys.path` antes de cualquier importación usando `Path(__file__).resolve().parent`.

**Implementación**:

1. **Nuevo script en raíz** (`test_build.py`):
   - Calcula dinámicamente la raíz del proyecto usando `Path(__file__).resolve().parent`
   - Inserta la raíz en `sys.path` antes de cualquier importación
   - Verifica la importación del módulo `viboy_core`
   - Ejecuta un smoke-test instanciando `PyNativeCore` y llamando a `core.add(2, 2)`
   - Devuelve códigos de salida correctos (0=OK, 1=FAIL) para integración en pipelines

2. **Wrapper de compatibilidad** (`tests/temp/test_build.py`):
   - Convertido en wrapper que redirige al runner de la raíz mediante `subprocess`
   - Mantiene compatibilidad con scripts que puedan llamar al test desde subdirectorios

**Archivos afectados**:
- `test_build.py` (nuevo) - Runner principal en raíz con manejo de sys.path
- `tests/temp/test_build.py` (modificado) - Convertido en wrapper que redirige al runner de la raíz

**Tests y Verificación**:
- **Comando**: `python3 test_build.py`
- **Resultado**: Exit code 0, importación exitosa de `viboy_core`, instanciación de `PyNativeCore()` exitosa, smoke-test `core.add(2, 2) == 4` pasa
- **Validación de módulo compilado C++**: ✅ El pipeline Python→Cython→C++ funciona correctamente

**Exit codes**:
- Build: 0 (compilación exitosa)
- test_build.py: 0 (checkpoint OK)
- pytest: 1 (10 failed, 13 passed - tests pre-existentes, no relacionados con este step)

**Próximos pasos**: Investigar y corregir los 10 tests fallantes de pytest (principalmente relacionados con conteo de M-Cycles en CPU).

---

### 2026-01-02 - Step 0414: Timer MMIO dinámico + VRAM Mode3 + Suite Paralela 2min
**Estado**: ✅ Completado

**Objetivo**: Implementar tres mejoras técnicas críticas: Timer MMIO dinámico (0xFF05-0xFF07 reflejan estado real del Timer), métricas de VRAM TileData bloqueada por Mode 3 (logs periódicos cada 120 frames), y verificación RGB real en Python (detecta si framebuffer CGB contiene datos aunque ventana se vea blanca). Establecer nuevo estándar de testing: suite paralela de 2 minutos con todas las ROMs ejecutándose simultáneamente.

**Contexto**: Tras Step 0413, las correcciones de STAT/LY/LCDC permitieron a algunos juegos avanzar en wait-loops. Sin embargo, persisten problemas de pantalla blanca en varias ROMs CGB (Oro.gbc, zelda-dx.gbc) y se necesita mejor instrumentación para diagnosticar si el problema es de renderizado (buffer RGB vacío) o de visualización (buffer tiene datos pero no se muestran).

**Concepto de Hardware**:

1. **Timer MMIO Dinámico (Pan Docs - Timer and Divider Register)**:
   - Los registros TIMA (0xFF05), TMA (0xFF06) y TAC (0xFF07) son controlados por hardware y cambian dinámicamente
   - TIMA se incrementa automáticamente a la frecuencia configurada en TAC
   - Problema: Los logs de wait-loops leían de `memory_[addr]` en lugar del estado real del Timer
   - Solución: Usar `timer_->read_tima/tma/tac()` en logs para coherencia

2. **VRAM Mode 3 Blocking (Pan Docs - LCD Status Register, Video RAM)**:
   - En hardware real, VRAM no es accesible durante Mode 3 (Pixel Transfer)
   - Objetivo: Medir cuántas escrituras CPU a TileData ocurren durante Mode 3
   - Implementación: Contadores `vram_tiledata_total_writes_` y `vram_tiledata_blocked_mode3_`
   - Log periódico cada 120 frames (2 segundos a 60 FPS) con ratio de bloqueo

3. **CGB RGB Buffer Verification (Step 0406)**:
   - En modo CGB, la PPU genera framebuffer RGB888 (160×144×3 = 69120 bytes)
   - Pregunta crítica: ¿El buffer RGB contiene datos o está completamente blanco?
   - Verificación: Samplear 5 píxeles distribuidos y reportar si alguno es "no-blanco" (R/G/B < 240)

**Implementación**:

1. **Timer MMIO dinámico** (`src/core/cpp/MMU.cpp`, líneas 383-391):
```cpp
// Antes (INCORRECTO):
printf("[WAIT-MMIO-READ] PC:0x%04X -> TIMA(0xFF05) = 0x%02X\n", debug_current_pc, memory_[addr]);

// Después (CORRECTO):
uint8_t tima_val = (timer_ != nullptr) ? timer_->read_tima() : memory_[addr];
printf("[WAIT-MMIO-READ] PC:0x%04X -> TIMA(0xFF05) = 0x%02X\n", debug_current_pc, tima_val);
```

2. **Métricas VRAM Mode3** (`src/core/cpp/MMU.hpp`, líneas 441-443):
```cpp
// --- Step 0414: Métricas de VRAM bloqueada por Mode 3 ---
mutable int vram_tiledata_total_writes_;    // Total escrituras a TileData (0x8000-0x97FF)
mutable int vram_tiledata_blocked_mode3_;   // Escrituras bloqueadas por Mode 3
mutable int vram_tiledata_summary_frames_;  // Frames procesados para resumen periódico
```

Lógica (`src/core/cpp/MMU.cpp`, líneas 2048-2115):
```cpp
// Contar escrituras y verificar bloqueo por Mode 3
bool is_tiledata_write = (addr >= 0x8000 && addr <= 0x97FF);
if (is_tiledata_write) {
    vram_tiledata_total_writes_++;
    if (ppu_ != nullptr && ppu_->get_mode() == 3) {
        vram_tiledata_blocked_mode3_++;
    }
}

// Log periódico cada 120 frames
if (ppu_ != nullptr) {
    uint64_t current_frame = ppu_->get_frame_counter();
    if ((current_frame % 120) == 0 && (current_frame / 120) <= 10) {
        printf("[VRAM-MODE3-SUMMARY] Frame:%lu | TileData: total=%d nonzero=%d blocked_mode3=%d (%.2f%%) | Bank:%d\n",
               current_frame, vram_tiledata_total_writes_, vram_tiledata_nonzero_writes_,
               vram_tiledata_blocked_mode3_, blocked_ratio, vram_bank_actual);
    }
}
```

3. **CGB RGB Check** (`src/gpu/renderer.py`, líneas 564-596):
```python
# Samplear 5 píxeles distribuidos del buffer RGB
sample_positions = [
    (72, 80),   # Centro
    (10, 10),   # Esquina superior izquierda
    (133, 149), # Esquina inferior derecha
    (50, 50),   # Centro-superior
    (100, 100)  # Centro-inferior
]

non_white_found = False
for y, x in sample_positions:
    r, g, b = rgb_array[y, x]
    is_white = (r > 240 and g > 240 and b > 240)
    if not is_white:
        non_white_found = True

print(f"[CGB-RGB-CHECK] Frame check #{count} | Non-white pixels: {'YES' if non_white_found else 'NO'} | Samples: ...")
```

**Tests y Verificación**:

1. **Compilación**:
```bash
python3 setup.py build_ext --inplace > build_log_step0414.txt 2>&1
```
✅ Compilación exitosa sin errores críticos.

2. **Suite Paralela (2 minutos por ROM)**:
```bash
mkdir -p logs/step0414_suite
pids=()
while IFS= read -r rom; do
  timeout 120s python3 main.py "$rom" > "logs/step0414_suite/${rom}.log" 2>&1 &
  pids+=("$!")
done < <(find roms -type f -iname '*.gb' -o -iname '*.gbc')
for pid in "${pids[@]}"; do wait "$pid" || true; done
```
✅ Suite completada: 8 ROMs ejecutadas en paralelo (mario.gbc 4.0GB, MortalKombat.gb 830MB, pkmn.gb 2.2GB, Oro.gbc 103MB, pkmn-amarillo.gb 153MB, tetris_dx.gbc 23MB, tetris.gb 102MB, zelda-dx.gbc 26MB).

**Tabla de Métricas por ROM**:

| ROM | IRQ Requests | VRAM Mode3 Logs | CGB RGB Checks | Wait-Loops | Estado |
|-----|--------------|-----------------|----------------|------------|--------|
| mario.gbc | 50 (límite) | 6 | 10 (límite) | 0 | ✅ Funciona |
| tetris_dx.gbc | 50 (límite) | 0 | 10 (límite) | 14 | ✅ Funciona |
| zelda-dx.gbc | 50 (límite) | 0 | 10 (límite) | 0 | ⚠️ Pantalla blanca post-frame 1 |
| Oro.gbc | 50 (límite) | 0 | 10 (límite) | 0 | ⚠️ Buffer RGB blanco |
| pkmn-amarillo.gb | 50 (límite) | 0 | 10 (límite) | 14 | ⚠️ Buffer RGB blanco |
| pkmn.gb | 50 (límite) | 0 | 0 (DMG) | 0 | ⚠️ Modo DMG |
| tetris.gb | 50 (límite) | 0 | 0 (DMG) | 0 | ⚠️ Modo DMG |
| MortalKombat.gb | 50 (límite) | 0 | 0 (DMG) | 14 | ⚠️ Modo DMG |

**Hallazgos Clave**:

1. **VRAM Mode3 Metrics (mario.gbc)**:
```
[VRAM-MODE3-SUMMARY] Frame:240 | TileData: total=0 nonzero=0 blocked_mode3=0 (0.00%) | Bank:0
[VRAM-MODE3-SUMMARY] Frame:360 | TileData: total=0 nonzero=0 blocked_mode3=0 (0.00%) | Bank:1
```
0% de bloqueo por Mode 3. Esperado porque nuestro emulador no bloquea VRAM actualmente. Bajo número de escrituras sugiere que mario.gbc usa HDMA para transferencias grandes.

2. **CGB RGB Check - mario.gbc** (✅ Funciona):
```
[CGB-RGB-CHECK] Frame check #1 | Non-white pixels: YES | Samples: (72,80)=RGB(255,255,255) | (10,10)=RGB(0,0,0) | (133,149)=RGB(255,255,255)
```
Detecta píxeles no-blancos (0,0,0 en esquina), confirmando que buffer RGB contiene datos reales.

3. **CGB RGB Check - Oro.gbc** (⚠️ Problema):
```
[CGB-RGB-CHECK] Frame check #1 | Non-white pixels: NO | Samples: (72,80)=RGB(255,255,255) | (10,10)=RGB(255,255,255) | (133,149)=RGB(255,255,255)
```
Buffer RGB completamente blanco. Confirma problema de renderizado: PPU no genera datos de color correctos.

4. **CGB RGB Check - zelda-dx.gbc** (⚠️ Intermitente):
```
[CGB-RGB-CHECK] Frame check #1 | Non-white pixels: YES | Samples: (72,80)=RGB(255,255,255) | (10,10)=RGB(0,0,0) | (133,149)=RGB(255,255,255)
[CGB-RGB-CHECK] Frame check #2 | Non-white pixels: NO | Samples: (72,80)=RGB(255,255,255) | (10,10)=RGB(255,255,255) | (133,149)=RGB(255,255,255)
```
Primera frame tiene píxeles no-blancos, frames subsecuentes son blancas. Problema ocurre después de inicialización.

**Archivos Afectados**:
- `src/core/cpp/MMU.hpp`: Nuevos contadores Step 0414 (líneas 441-443)
- `src/core/cpp/MMU.cpp`: Timer MMIO fix (líneas 383-391), métricas VRAM Mode3 (líneas 2048-2115)
- `src/gpu/renderer.py`: CGB RGB Check (líneas 564-596)
- `docs/bitacora/entries/2026-01-02__0414__timer-mmio-dinamico-vram-mode3-suite-paralela-2min.html`: Entrada HTML completa
- `docs/bitacora/index.html`: Actualizado con entrada 0414

**Conclusiones**:
1. ✅ Timer MMIO dinámico implementado correctamente
2. ✅ VRAM Mode3 metrics funcionando (logs periódicos cada 120 frames)
3. ✅ CGB RGB Check muy útil: detecta diferencia entre ROMs funcionales (mario, tetris_dx) y problemáticas (Oro, zelda-dx)
4. ✅ Suite paralela 2min establecida como nuevo estándar de testing
5. ⚠️ **Próximo paso**: Investigar por qué Oro.gbc y zelda-dx.gbc tienen buffer RGB blanco (posibles causas: paletas CGB no configuradas, tiles en blanco, LCD apagado, problema con CGB boot ROM)

**Referencias**:
- Pan Docs - Timer and Divider Registers: https://gbdev.io/pandocs/Timer_and_Divider_Registers.html
- Pan Docs - LCD Status Register (STAT): https://gbdev.io/pandocs/STAT.html
- Pan Docs - Video RAM (VRAM): https://gbdev.io/pandocs/Video_RAM.html

---

### 2026-01-02 - Step 0413: Fix STAT/LY/LCDC (PPU-MMIO) + LCD Toggle para Romper Wait-Loops
**Estado**: ✅ Completado

**Objetivo**: Corregir el registro STAT (0xFF41) para reflejar dinámicamente el modo PPU y coincidencia LYC=LY + implementar LCD toggle (LCDC bit 7) para resetear timing correctamente, permitiendo que juegos que pollean STAT/LY salgan de wait-loops infinitos.

**Contexto**: Tras Step 0412, `tetris_dx.gbc` progresa (`tiledata_effective=56.6%`), pero `pkmn.gb` y `Oro.gbc` siguen con `tiledata_effective=0%` y pantalla blanca. Los Steps 0410/0411 sugieren que Pokémon se queda en **wait-loops** esperando condiciones de hardware (STAT, LY, IRQ). El problema: cuando la CPU lee STAT (0xFF41), devuelve un valor estático de `memory_[0xFF41]` sin reflejar el modo actual de la PPU ni la coincidencia LYC=LY.

**Concepto de Hardware (Pan Docs - LCD Status Register FF41 - STAT)**:
1. **STAT (0xFF41)**: Registro híbrido con comportamiento Read-Only y Read-Write:
   - **Bits 0-1 (RO)**: Modo PPU actual (00: H-Blank, 01: V-Blank, 10: OAM Search, 11: Pixel Transfer)
   - **Bit 2 (RO)**: Coincidencia LYC=LY (1 si LY == LYC)
   - **Bits 3-6 (RW)**: Máscaras de interrupción STAT (Mode 0/1/2 y LYC=LY interrupts)
   - **Bit 7**: Siempre 1 (no implementado)
2. **LCD Toggle (LCDC bit 7)**: Controla encendido/apagado del LCD:
   - **LCD OFF**: PPU se detiene, LY=0, Mode=0 (H-Blank)
   - **LCD ON**: PPU comienza desde inicio de frame: LY=0, Mode=2 (OAM Search), clock=0
3. **Wait-Loops**: Muchos juegos (especialmente Pokémon) pollean STAT/LY esperando condiciones específicas. Si STAT no refleja el estado real, el juego se queda esperando infinitamente.

**Implementación**:
1. **`PPU::get_stat()` - STAT Dinámico** (`PPU.cpp`, `PPU.hpp`):
   - Añadido método `get_stat()` que construye STAT dinámicamente:
     - Bits 0-1: `mode_ & 0x03` (modo actual)
     - Bit 2: `(ly_ == lyc_) ? 0x04 : 0x00` (coincidencia)
     - Bits 3-7: Preserva bits 3-7 de `memory_[0xFF41]` (máscaras de interrupción + bit 7)
2. **`MMU::read(0xFF41)` Usa `get_stat()`** (`MMU.cpp`):
   - Cuando se lee 0xFF41, llamar a `ppu_->get_stat()` en lugar de devolver `memory_[0xFF41]`.
3. **`PPU::handle_lcd_toggle(bool lcd_on)` - Reset de Timing** (`PPU.cpp`, `PPU.hpp`):
   - Detecta transiciones de LCDC bit 7:
     - **LCD ON**: Reset `ly_=0`, `mode_=MODE_2_OAM_SEARCH`, `clock_=0`, actualiza STAT (modo 2, verifica LYC=LY).
     - **LCD OFF**: Reset `ly_=0`, `mode_=MODE_0_HBLANK`, `clock_=0`, actualiza STAT (modo 0, verifica LYC=LY).
   - Logs acotados: primeros 10 toggles con formato `[PPU-LCD-TOGGLE] LCD turned ON/OFF | LY=%d Mode=%d STAT=0x%02X`.
4. **Detectar Toggle en `MMU::write(0xFF40)`** (`MMU.cpp`):
   - En escritura a LCDC, detectar cambios en bit 7: `if (lcd_on_old != lcd_on_new && ppu_ != nullptr) ppu_->handle_lcd_toggle(lcd_on_new);`

**Archivos Modificados**:
- `src/core/cpp/PPU.hpp`: Declaraciones de `get_stat()` y `handle_lcd_toggle()`.
- `src/core/cpp/PPU.cpp`: Implementaciones de ambos métodos.
- `src/core/cpp/MMU.cpp`: Lectura dinámica de STAT + detección de LCD toggle.

**Tests y Verificación**:
```bash
python3 setup.py build_ext --inplace > build_log_step0413.txt 2>&1
✅ Compilación exitosa sin errores críticos
```

**Validación Conceptual**:
- ✅ STAT bits 0-2 son read-only y reflejan estado actual de PPU
- ✅ LCD toggle resetea LY, mode y clock según Pan Docs
- ✅ LCD ON comienza en Mode 2 (OAM Search) con LY=0
- ✅ LCD OFF queda en Mode 0 (H-Blank) con LY=0

**Impacto Esperado**:
- **Pokémon Red (pkmn.gb)**: Esperamos que `tiledata_effective` pase de 0% a >0%
- **Pokémon Gold (Oro.gbc)**: Progreso similar
- **Tetris DX**: No regresiones (ya funcionaba)

**Próximos Pasos**:
- Tests exhaustivos con Pokémon Red/Gold para verificar salida de wait-loops
- Si persisten problemas, analizar otros registros MMIO dinámicos (IF, IE, TAC)
- Implementar diagnóstico de "snapshot de bloqueo" para debugging

**Referencias**:
- Pan Docs - LCD Status Register (STAT): https://gbdev.io/pandocs/STAT.html
- Pan Docs - LCD Control Register (LCDC): https://gbdev.io/pandocs/LCDC.html
- Pan Docs - LCD Timing: https://gbdev.io/pandocs/Rendering.html

---

### 2026-01-01 - Step 0412: Paletas CGB Post-Boot + Simulación Input
**Estado**: ✅ Completado

**Objetivo**: Recuperar imagen en pantalla (especialmente en `tetris_dx.gbc`) evitando pantalla blanca total causada por paletas CGB sin inicializar, y desbloquear progreso en juegos que esperan input mediante simulación controlada de botones.

**Contexto**: Tras los Steps 0410-0411, se identificó que el problema de pantalla blanca en juegos CGB se debe a que las paletas CGB (`bg_palette_data_[]` y `obj_palette_data_[]`) se inicializaban a `0xFF`, lo que convierte todos los colores a blanco puro (`0xFFFF BGR555`) hasta que el juego las sobrescriba. Adicionalmente, algunos juegos (Pokémon) quedan bloqueados en wait-loops esperando input.

**Concepto de Hardware (Pan Docs - CGB Registers, Palettes FF68-FF6B)**:
1. **Paletas CGB**: 8 paletas BG y 8 paletas OBJ, cada una con 4 colores de 15 bits en formato BGR555 (64 bytes por tipo).
   - **FF68 (BCPS)**: BG Color Palette Specification. Bits 0-5: índice (0x00-0x3F), Bit 7: auto-increment.
   - **FF69 (BCPD)**: BG Color Palette Data. Byte del color actual (low/high BGR555).
   - **FF6A (OCPS)**: OBJ Color Palette Specification (igual que BCPS).
   - **FF6B (OCPD)**: OBJ Color Palette Data (igual que BCPD).
2. **Formato BGR555**: Cada color se representa con 15 bits (2 bytes). Blanco: `0x7FFF`, Negro: `0x0000`.
3. **Inicialización Post-Boot (Clean-Room)**: Sin Boot ROM real, inicializamos las paletas a un gradiente gris determinista (equivalente a DMG) para evitar pantalla blanca total. Esto NO pretende copiar la Boot ROM, solo evita estado basura.

**Implementación**:
1. **Inicialización de Paletas CGB** (`MMU.cpp`, `MMU::initialize_io_registers()`):
   - Cuando `hardware_mode_ == CGB`, inicializar `bg_palette_data_[]` y `obj_palette_data_[]` con gradiente gris DMG-equivalente en BGR555:
     - Color 0 (Blanco): `0x7FFF` (RGB 255,255,255)
     - Color 1 (Gris claro): `0x6318` (RGB 192,192,192)
     - Color 2 (Gris oscuro): `0x318C` (RGB 96,96,96)
     - Color 3 (Negro): `0x0000` (RGB 0,0,0)
   - Aplicar a las 8 paletas BG y 8 paletas OBJ.
2. **Monitoreo de Writes a Paletas** (`MMU.cpp`, `MMU::write()`):
   - Añadir contador `palette_write_log_count_` (límite 200) en `MMU.hpp`.
   - Logs de writes a `0xFF68-0xFF6B` con formato: `[PALETTE-WRITE] PC:0x%04X Bank:%d | FF68(BCPS) <- 0x%02X | Index:%d AutoInc:%d`.
   - Incluye: PC, ROM Bank, registro, valor, índice de paleta, auto-increment, paleta y color afectados.
3. **Simulación de Input Más Agresiva** (`src/viboy.py`):
   - Modificar `simulated_actions` para incluir 4 secuencias de START+A distribuidas en ~17.5s:
     - Secuencia 1: frames 60, 90, 120, 150 (1.0s-2.5s)
     - Secuencia 2: frames 360, 390, 420, 450 (6.0s-7.5s)
     - Secuencia 3: frames 660, 690, 720, 750 (11.0s-12.5s)
     - Secuencia 4: frames 960, 990, 1020, 1050 (16.0s-17.5s)

**Archivos Modificados**:
- `src/core/cpp/MMU.hpp`: Añadido contador `palette_write_log_count_`.
- `src/core/cpp/MMU.cpp`: Inicialización de paletas CGB + logs de writes.
- `src/viboy.py`: Simulación de input más agresiva.

**Tests y Verificación**:
```bash
python3 setup.py build_ext --inplace

timeout 30s python3 main.py roms/tetris_dx.gbc > logs/step0412_tetris_dx_palettes.log 2>&1
timeout 45s python3 main.py --simulate-input roms/pkmn.gb > logs/step0412_pkmn_siminput.log 2>&1
timeout 45s python3 main.py --simulate-input roms/Oro.gbc > logs/step0412_oro_siminput.log 2>&1

# Análisis seguro
grep -E "PALETTE-WRITE|PALETTE-INIT|VRAM-REGIONS|SIM-INPUT" logs/step0412_* | head -n 160
```

**Resultados**:

✅ **Logros Conseguidos**:
1. **Paletas CGB inicializadas correctamente**: Los 3 juegos CGB muestran `[MMU-PALETTE-INIT] CGB paletas inicializadas con gradiente gris DMG-equivalente (post-boot stub)`.
2. **Monitoreo de writes a paletas funciona**: Oro.gbc escribe 128 paletas activamente:
   - Bank 2, PC:0x5D15: Writes a todas las 8 paletas BG y OBJ (índice 0x00-0x3F) con valores `0x7FFF` (blanco BGR555).
   - Bank 57, PC:0x0BEC: Writes adicionales con valores `0xFFFF`.
3. **Input simulado funciona**: Las 4 secuencias de START+A se ejecutan correctamente en todos los juegos (frames 60-1050). Logs detectados: `[SIM-INPUT] Frame 60 (1.0s): PRESS START`, etc.
4. **Tetris DX avanza significativamente**:
   - Frame 720: `tiledata_effective=20.9%`, `gameplay_state=YES` (¡hito!).
   - Frame 840-1200: `tiledata_effective=56.6%`, `tilemap_nonzero=98.2%`.
   - La imagen debería verse con contenido real (aunque no se capturaron screenshots).

❌ **Problemas Persistentes**:
1. **Pokémon Red (DMG) sigue bloqueado**: `tiledata_effective=0%` en todos los frames, `gameplay_state=NO`. El input simulado NO desbloquea la carga de tiles. Confirma que el problema NO es de input, sino de **timing/interrupciones** (como ya se diagnosticó en Step 0410/0411).
2. **Oro.gbc (CGB) sigue bloqueado**: `tiledata_effective=0%` en todos los frames (a pesar de escribir paletas activamente), `gameplay_state=NO`. El juego escribe paletas pero no tiles → problema de timing/interrupciones similar a Pokémon Red.

**Evidencia Clave de Logs**:
```
# Oro.gbc - Paletas inicializadas
[MMU-PALETTE-INIT] CGB paletas inicializadas con gradiente gris DMG-equivalente (post-boot stub)

# Oro.gbc - Writes a paletas detectados
[PALETTE-WRITE] PC:0x5D15 Bank:2 | FF68(BCPS) <- 0x80 | Index:0 AutoInc:1
[PALETTE-WRITE] PC:0x5D1B Bank:2 | FF69(BCPD)[0x00] <- 0xFF | Pal:0 Color:0
[PALETTE-WRITE] PC:0x5D1F Bank:2 | FF69(BCPD)[0x01] <- 0x7F | Pal:0 Color:0

# Input simulado ejecutado
[SIM-INPUT] Frame 60 (1.0s): PRESS START
[SIM-INPUT] Frame 90 (1.5s): RELEASE START

# Tetris DX - Progreso significativo
[VRAM-REGIONS] Frame 720 | tiledata_effective=1286/6144 (20.9%) | gameplay_state=YES
[VRAM-REGIONS] Frame 840 | tiledata_effective=3479/6144 (56.6%) | tilemap_nonzero=2012/2048 (98.2%)

# Pokémon Red - Sin progreso
[VRAM-REGIONS] Frame 1200 | tiledata_effective=0/6144 (0.0%) | gameplay_state=NO
```

**Conclusión**: ✅ Objetivo 1 conseguido (paletas CGB ya no blancas). ⚠️ Objetivo 2 parcialmente conseguido (input simulado funciona, pero NO desbloquea progreso en Pokémon - el problema real es timing/IRQ, no input). ✅ Objetivo 3 confirmado (Tetris DX alcanza `tiledata_effective=56.6%`). Próximo Step: enfocarse en el problema raíz de timing/IRQ identificado en Steps 0410/0411.

---

