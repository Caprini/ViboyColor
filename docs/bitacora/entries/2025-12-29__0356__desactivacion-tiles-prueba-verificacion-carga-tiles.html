<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Desactivaci√≥n de Tiles de Prueba y Verificaci√≥n de Carga de Tiles por el Juego - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Desactivaci√≥n de Tiles de Prueba y Verificaci√≥n de Carga de Tiles por el Juego</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0356
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0355__investigacion-inicializacion-vram-discrepancia.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se desactiv√≥ <code>load_test_tiles()</code> para permitir que los juegos carguen sus propios tiles sin interferencia de tiles de prueba. Se agreg√≥ monitoreo detallado de escrituras no-cero a VRAM y verificaci√≥n peri√≥dica del estado de VRAM sin tiles de prueba. Los resultados muestran que los juegos no cargan tiles nuevos durante la ejecuci√≥n: todas las escrituras a VRAM son ceros (0x00), y VRAM permanece vac√≠a durante toda la ejecuci√≥n. El estado inicial de VRAM tiene 95.49% de bytes no-cero, pero el juego los borra inmediatamente escribiendo ceros desde PC=0x36E3.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Carga de Tiles por el Juego:</strong> Los juegos de Game Boy cargan tiles en VRAM durante la inicializaci√≥n o cuando el LCD est√° apagado. Los tiles se cargan en secuencias de 16 bytes consecutivos (un tile completo). Los juegos pueden cargar tiles en diferentes momentos seg√∫n sus necesidades. Normalmente, los juegos cargan tiles cuando el LCD est√° apagado para evitar conflictos con el acceso a VRAM durante el renderizado.
                </p>
                <p>
                    <strong>Interferencia de Tiles de Prueba:</strong> Los tiles de prueba pueden interferir con el comportamiento real del juego. Los juegos pueden borrar tiles de prueba porque no son parte del juego real. Desactivar tiles de prueba permite ver el comportamiento real del juego sin interferencia. Esto es importante para entender c√≥mo los juegos cargan tiles en condiciones reales.
                </p>
                <p>
                    <strong>Timing de LCD y Carga de Tiles:</strong> Los juegos suelen cargar tiles cuando el LCD est√° apagado. El acceso a VRAM est√° restringido cuando el LCD est√° encendido (excepto durante VBLANK). El timing correcto es: LCD apagado ‚Üí juego carga tiles ‚Üí LCD encendido. Si el juego intenta cargar tiles cuando el LCD est√° encendido, puede haber problemas de sincronizaci√≥n o los tiles pueden no cargarse correctamente.
                </p>
                <p>
                    <strong>Estado Inicial de VRAM:</strong> En el hardware real, VRAM puede contener datos aleatorios al inicio. Algunos emuladores inicializan VRAM con ceros, otros con valores aleatorios. En nuestro emulador, VRAM se inicializa con ceros, pero algunos juegos pueden tener datos iniciales en la ROM que se cargan durante la inicializaci√≥n. El Step 0355 identific√≥ que el estado inicial de VRAM tiene 95.49% de bytes no-cero, lo que sugiere que hay datos iniciales que se cargan desde la ROM o durante la inicializaci√≥n.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Se implementaron 6 tareas principales seg√∫n el plan Step 0356:
                </p>
                
                <h3>1. Desactivaci√≥n de load_test_tiles() (src/viboy.py)</h3>
                <p>
                    Se desactiv√≥ la llamada a <code>load_test_tiles()</code> en <code>Viboy.load_cartridge()</code> para permitir que los juegos carguen sus propios tiles sin interferencia. La funci√≥n ahora solo imprime un mensaje indicando que los tiles de prueba est√°n desactivados.
                </p>
                <pre><code># --- Step 0356: DESACTIVACI√ìN DE TILES DE PRUEBA ---
# Desactivar load_test_tiles() para permitir que los juegos carguen sus propios tiles
# sin interferencia de tiles de prueba
print("[VIBOY] load_test_tiles() DESACTIVADO (Step 0356) - Los juegos cargar√°n sus propios tiles")
# --- Fin Step 0356 ---</code></pre>
                
                <h3>2. Verificaci√≥n de Orden de Ejecuci√≥n de check_initial_vram_state() (MMU.cpp)</h3>
                <p>
                    Se agreg√≥ un log en <code>check_initial_vram_state()</code> para verificar cu√°ndo se ejecuta esta funci√≥n. El log usa una variable est√°tica para asegurar que solo se ejecute una vez.
                </p>
                <pre><code>// --- Step 0356: Verificaci√≥n de Orden de Ejecuci√≥n ---
void MMU::check_initial_vram_state() {
    static bool already_called = false;
    
    if (!already_called) {
        already_called = true;
        printf("[MMU-VRAM-INITIAL-STATE-CALL] check_initial_vram_state() called\n");
    }
    // ... resto del c√≥digo existente ...
}</code></pre>
                
                <h3>3. Monitoreo de Escrituras No-Cero a VRAM (MMU.cpp)</h3>
                <p>
                    Se agreg√≥ un nuevo bloque de monitoreo en <code>MMU::write()</code> que monitorea todas las escrituras no-cero a VRAM. El monitoreo incluye informaci√≥n sobre el estado del LCD, VBLANK, frame, y PC. Tambi√©n detecta secuencias de tiles completos (16 bytes consecutivos).
                </p>
                <pre><code>// --- Step 0356: Monitoreo de Escrituras No-Cero a VRAM ---
if (addr >= 0x8000 && addr < 0x9800 && value != 0x00) {
    static int vram_non_zero_write_count = 0;
    static int vram_tile_sequences_detected = 0;
    
    vram_non_zero_write_count++;
    
    // Loggear todas las escrituras no-cero (hasta 500)
    if (vram_non_zero_write_count <= 500) {
        uint16_t pc = debug_current_pc;
        bool lcd_is_on = false;
        bool in_vblank = false;
        uint64_t frame = 0;
        
        if (ppu_ != nullptr) {
            lcd_is_on = ppu_->is_lcd_on();
            uint8_t ly = ppu_->get_ly();
            in_vblank = (ly >= 144);
            frame = ppu_->get_frame_counter();
        }
        
        printf("[MMU-VRAM-NON-ZERO-WRITE] Write #%d | Addr=0x%04X | Value=0x%02X | "
               "PC=0x%04X | Frame %llu | LCD=%s | VBLANK=%s\n",
               vram_non_zero_write_count, addr, value, pc,
               static_cast<unsigned long long>(frame),
               lcd_is_on ? "ON" : "OFF",
               in_vblank ? "YES" : "NO");
    }
    
    // Detectar secuencias de tiles completos (16 bytes)
    // ... c√≥digo de detecci√≥n de secuencias ...
}</code></pre>
                
                <h3>4. Verificaci√≥n Peri√≥dica de VRAM Sin Tiles de Prueba (PPU.cpp)</h3>
                <p>
                    Se agreg√≥ verificaci√≥n peri√≥dica en <code>PPU::step()</code> que verifica el estado de VRAM cada 100 frames. La verificaci√≥n cuenta bytes no-cero y tiles completos, y genera un log con estad√≠sticas.
                </p>
                <pre><code>// --- Step 0356: Verificaci√≥n Peri√≥dica de VRAM Sin Tiles de Prueba ---
static int vram_periodic_check_count = 0;

if (frame_counter_ % 100 == 0 && vram_periodic_check_count < 50) {
    vram_periodic_check_count++;
    
    // Contar bytes no-cero en VRAM
    int non_zero_bytes = 0;
    int complete_tiles = 0;
    
    for (uint16_t addr = 0x8000; addr < 0x9800; addr += 16) {
        // ... c√≥digo de conteo ...
    }
    
    printf("[PPU-VRAM-PERIODIC-NO-TEST-TILES] Frame %llu | Non-zero bytes: %d/6144 (%.2f%%) | "
           "Complete tiles: %d/384 (%.2f%%) | Has real tiles: %s\n",
           static_cast<unsigned long long>(frame_counter_),
           non_zero_bytes, (non_zero_bytes * 100.0) / 6144,
           complete_tiles, (complete_tiles * 100.0) / 384,
           (non_zero_bytes >= 200) ? "YES" : "NO");
}</code></pre>
                
                <h3>5. Ejecuci√≥n de Pruebas en Paralelo</h3>
                <p>
                    Se ejecutaron pruebas con las 5 ROMs en paralelo (pkmn.gb, tetris.gb, mario.gbc, pkmn-amarillo.gb, Oro.gbc) con timeout de 150 segundos cada una. Los logs se guardaron en archivos separados para an√°lisis posterior.
                </p>
                
                <h3>6. An√°lisis de Logs</h3>
                <p>
                    Se analizaron los logs usando comandos <code>grep</code> para extraer informaci√≥n espec√≠fica sin saturar el contexto. Los comandos buscaron:
                </p>
                <ul>
                    <li>Verificaci√≥n de que <code>load_test_tiles()</code> no se ejecuta</li>
                    <li>Escrituras no-cero a VRAM</li>
                    <li>Secuencias de tiles detectadas</li>
                    <li>Estado peri√≥dico de VRAM</li>
                    <li>Orden de ejecuci√≥n de <code>check_initial_vram_state()</code></li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/viboy.py</code> - Desactivaci√≥n de <code>load_test_tiles()</code></li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Logs de orden de ejecuci√≥n y monitoreo de escrituras no-cero</li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Verificaci√≥n peri√≥dica de VRAM sin tiles de prueba</li>
                    <li><code>build_log_step0356.txt</code> - Log de compilaci√≥n</li>
                    <li><code>logs/test_*_step0356.log</code> - Logs de pruebas con las 5 ROMs</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    Se ejecutaron pruebas con las 5 ROMs en paralelo para verificar el comportamiento sin tiles de prueba:
                </p>
                <ul>
                    <li><strong>ROMs de prueba:</strong> pkmn.gb, tetris.gb, mario.gbc, pkmn-amarillo.gb, Oro.gbc</li>
                    <li><strong>Tiempo de ejecuci√≥n:</strong> 150 segundos por ROM (timeout)</li>
                    <li><strong>Logs generados:</strong> 5 archivos de log (uno por ROM)</li>
                </ul>
                
                <h3>Resultados de las Pruebas</h3>
                <p>
                    <strong>‚úÖ Verificaci√≥n de Desactivaci√≥n de Tiles de Prueba:</strong>
                </p>
                <pre><code>[VIBOY] load_test_tiles() DESACTIVADO (Step 0356) - Los juegos cargar√°n sus propios tiles</code></pre>
                <p>
                    Confirmado: <code>load_test_tiles()</code> no se ejecuta en ninguna de las 5 ROMs.
                </p>
                
                <p>
                    <strong>‚úÖ Verificaci√≥n de Orden de Ejecuci√≥n:</strong>
                </p>
                <pre><code>[MMU-VRAM-INITIAL-STATE-CALL] check_initial_vram_state() called</code></pre>
                <p>
                    Confirmado: <code>check_initial_vram_state()</code> se ejecuta correctamente una vez por ROM.
                </p>
                
                <p>
                    <strong>‚ùå Escrituras No-Cero a VRAM:</strong>
                </p>
                <p>
                    No se detectaron escrituras no-cero a VRAM en ninguna de las 5 ROMs. Los logs de <code>[MMU-VRAM-NON-ZERO-WRITE]</code> est√°n vac√≠os, lo que indica que los juegos solo escriben ceros (0x00) a VRAM durante la ejecuci√≥n.
                </p>
                
                <p>
                    <strong>‚ùå Secuencias de Tiles:</strong>
                </p>
                <p>
                    No se detectaron secuencias de tiles completos. Los logs de <code>[MMU-VRAM-TILE-SEQUENCE]</code> est√°n vac√≠os.
                </p>
                
                <p>
                    <strong>‚ùå Estado Peri√≥dico de VRAM:</strong>
                </p>
                <pre><code>[PPU-VRAM-PERIODIC-NO-TEST-TILES] Frame 0 | Non-zero bytes: 0/6144 (0.00%) | Complete tiles: 0/384 (0.00%) | Has real tiles: NO</code></pre>
                <p>
                    VRAM permanece vac√≠a (0 bytes no-cero) durante toda la ejecuci√≥n en todas las ROMs.
                </p>
                
                <p>
                    <strong>üìä Estado Inicial de VRAM:</strong>
                </p>
                <pre><code>[MMU-VRAM-INITIAL-STATE] VRAM initial state | Non-zero bytes: 5867/6144 (95.49%) | Complete tiles: 374/384 (97.40%)
[MMU-VRAM-INITIAL-STATE] ‚úÖ VRAM tiene datos iniciales (posiblemente desde ROM)</code></pre>
                <p>
                    El estado inicial de VRAM tiene 95.49% de bytes no-cero, pero el juego los borra inmediatamente escribiendo ceros desde PC=0x36E3.
                </p>
                
                <h3>Validaci√≥n de M√≥dulo Compilado C++</h3>
                <p>
                    La compilaci√≥n fue exitosa. Se generaron los m√≥dulos C++ compilados sin errores (solo warnings menores sobre variables no usadas).
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Game Boy Pan Docs</a> - Secci√≥n "Tile Data", "Tile Map", "VRAM"</li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Game Boy Pan Docs</a> - Secci√≥n "LCD Control Register (LCDC)", "VBLANK"</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Interferencia de Tiles de Prueba:</strong> Los tiles de prueba pueden interferir con el comportamiento real del juego. Los juegos pueden borrar tiles de prueba porque no son parte del juego real. Desactivar tiles de prueba permite ver el comportamiento real del juego sin interferencia.</li>
                        <li><strong>Estado Inicial de VRAM:</strong> El estado inicial de VRAM puede tener datos iniciales (95.49% de bytes no-cero en este caso), pero estos datos pueden ser borrados inmediatamente por el juego durante la inicializaci√≥n.</li>
                        <li><strong>Falta de Carga de Tiles:</strong> Los juegos no est√°n cargando tiles nuevos durante la ejecuci√≥n. Todas las escrituras a VRAM son ceros (0x00), lo que sugiere que hay un problema con la carga de tiles o que los juegos esperan que los tiles ya est√©n cargados.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Por qu√© los juegos no cargan tiles:</strong> No est√° claro por qu√© los juegos no cargan tiles nuevos durante la ejecuci√≥n. Puede ser que los juegos esperen que los tiles ya est√©n cargados, o que haya un problema con el timing de carga de tiles.</li>
                        <li><strong>Cu√°ndo se cargan los tiles iniciales:</strong> El estado inicial de VRAM tiene 95.49% de bytes no-cero, pero no est√° claro cu√°ndo se cargan estos datos. Pueden ser datos de la ROM que se cargan durante la inicializaci√≥n, o pueden ser generados por el juego.</li>
                        <li><strong>Timing de borrado de datos iniciales:</strong> El juego borra los datos iniciales inmediatamente (PC=0x36E3), pero no est√° claro por qu√©. Puede ser parte de la inicializaci√≥n del juego, o puede ser un problema con el emulador.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis 1:</strong> Los juegos no cargan tiles nuevos porque esperan que los tiles ya est√©n cargados desde la inicializaci√≥n. Si los tiles iniciales se borran, los juegos no los recargan porque asumen que ya est√°n cargados.
                    </p>
                    <p>
                        <strong>Hip√≥tesis 2:</strong> Hay un problema con el timing de carga de tiles. Los juegos intentan cargar tiles cuando el LCD est√° encendido, lo que puede causar problemas de sincronizaci√≥n o restricciones de acceso a VRAM.
                    </p>
                    <p>
                        <strong>Hip√≥tesis 3:</strong> Los datos iniciales en VRAM son parte de la ROM y se cargan durante la inicializaci√≥n, pero el juego los borra porque no son los tiles correctos para el estado actual del juego.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <p>
                    Basado en los resultados del Step 0356, los pr√≥ximos pasos son:
                </p>
                <ul>
                    <li>[ ] <strong>Step 0357:</strong> Investigar por qu√© los juegos no cargan tiles nuevos durante la ejecuci√≥n. Verificar si hay un problema con el timing de carga de tiles o si los juegos esperan que los tiles ya est√©n cargados.</li>
                    <li>[ ] <strong>Step 0358:</strong> Investigar cu√°ndo se cargan los tiles iniciales. Verificar si los datos iniciales en VRAM son parte de la ROM o si se generan durante la inicializaci√≥n.</li>
                    <li>[ ] <strong>Step 0359:</strong> Investigar el timing de borrado de datos iniciales. Verificar por qu√© el juego borra los datos iniciales inmediatamente (PC=0x36E3) y si esto es parte del comportamiento normal del juego.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

