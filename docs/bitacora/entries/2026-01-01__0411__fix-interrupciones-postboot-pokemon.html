<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix IRQ + Post-Boot Coherente - Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Breadcrumb Navigation -->
        <nav class="breadcrumb">
            <a href="../../../index.html">Inicio</a> &gt;
            <a href="../index.html">Bit√°cora</a> &gt;
            <span>Step 0411</span>
        </nav>

        <!-- Entry Header -->
        <header class="entry-header">
            <h1>Step 0411: Fix IRQ Pipeline + Post-Boot Registers Coherente</h1>
            <div class="entry-meta">
                <span class="date">üìÖ 2026-01-01</span>
                <span class="step-id">üîñ Step ID: 0411</span>
                <span class="tag tag-verified">‚úÖ VERIFIED</span>
            </div>
        </header>

        <!-- Resumen Ejecutivo -->
        <section class="section">
            <h2>üìã Resumen Ejecutivo</h2>
            <p><strong>Problema</strong>: Step 0410 revel√≥ que Pok√©mon (pkmn.gb, Oro.gbc) quedan bloqueados con <code>IF=0x00</code> esperando interrupciones que nunca llegan, impidiendo la carga de tiles.</p>
            <p><strong>Hip√≥tesis</strong>: Posible mismatch entre post-boot CPU registers y modo HW detectado, o LCD/Timer apagados.</p>
            <p><strong>Soluci√≥n</strong>: Instrumentaci√≥n completa del pipeline de IRQ con contadores directos + alinear registros post-boot con modo HW (DMG vs CGB) detectado desde header ROM.</p>
            <p><strong>Resultado</strong>: ‚úÖ IRQs gener√°ndose correctamente. Oro.gbc avanza significativamente (RETI, IE=0x1F). Pok√©mon Red/Tetris DX esperan Joypad input (nuevo Step requerido).</p>
        </section>

        <!-- Concepto de Hardware -->
        <section class="section">
            <h2>üîß Concepto de Hardware</h2>
            
            <h3>1. Pipeline de Interrupciones (IF, IE, IME)</h3>
            <p><strong>Flujo de IRQ en Game Boy</strong> (Pan Docs - Interrupts):</p>
            <ul>
                <li><strong>IF (0xFF0F)</strong>: Interrupt Flag - Bits activados cuando hardware solicita IRQ (VBlank, STAT, Timer, Serial, Joypad)</li>
                <li><strong>IE (0xFFFF)</strong>: Interrupt Enable - Bits que habilitan qu√© IRQs pueden ser atendidas</li>
                <li><strong>IME</strong>: Interrupt Master Enable - Flag global que habilita/deshabilita todas las IRQs (activado con EI, desactivado con DI)</li>
                <li><strong>Condici√≥n para servir IRQ</strong>: <code>IME && (IE & IF) != 0</code></li>
            </ul>
            
            <div class="code-block">
                <p><strong>Ejemplo de IRQ VBlank</strong>:</p>
                <pre><code>1. PPU entra en VBlank (LY=144) ‚Üí request_interrupt(0) ‚Üí IF bit 0 = 1
2. Si IE bit 0 = 1 (VBlank habilitado) Y IME = 1 ‚Üí CPU salta a vector 0x0040
3. CPU ejecuta ISR VBlank
4. ISR limpia IF bit 0 (escribiendo 0 a IF) y ejecuta RETI</code></pre>
            </div>

            <h3>2. Post-Boot CPU Registers seg√∫n Modo HW</h3>
            <p><strong>Problema</strong>: El registro <code>A</code> post-boot identifica el hardware al juego:</p>
            <ul>
                <li><strong>DMG</strong>: <code>A=0x01</code> ‚Üí Juego sabe que est√° en Game Boy original</li>
                <li><strong>CGB</strong>: <code>A=0x11</code> ‚Üí Juego sabe que est√° en Game Boy Color</li>
            </ul>
            <p>Juegos dual-mode (compatible DMG/CGB) toman caminos diferentes seg√∫n <code>A</code>. Si <code>A</code> no coincide con el modo HW real, el juego puede quedar en estado inconsistente.</p>
            
            <div class="code-block">
                <p><strong>Post-Boot State completo</strong> (Pan Docs - Power Up Sequence):</p>
                <pre><code>DMG:  AF=0x01B0, BC=0x0013, DE=0x00D8, HL=0x014D, SP=0xFFFE, PC=0x0100
CGB:  AF=0x1180, BC=0x0000, DE=0xFF56, HL=0x000D, SP=0xFFFE, PC=0x0100</code></pre>
            </div>

            <h3>3. LCDC bit7 y Timer (TAC bit2)</h3>
            <ul>
                <li><strong>LCDC bit7=0 (LCD OFF)</strong>: PPU se detiene, LY queda en 0, <strong>NO hay VBlank IRQ</strong></li>
                <li><strong>TAC bit2=0 (Timer OFF)</strong>: Registro TIMA no incrementa, <strong>NO hay Timer IRQ</strong></li>
            </ul>
            <p>Si ambos est√°n apagados, <code>IF</code> puede quedarse en 0 indefinidamente.</p>
        </section>

        <!-- Implementaci√≥n -->
        <section class="section">
            <h2>üíª Implementaci√≥n</h2>

            <h3>Tarea 1A: Contadores directos en <code>MMU::request_interrupt</code></h3>
            <p>A√±adidos contadores en <code>MMU.hpp</code> para rastrear <strong>todos</strong> los requests de IRQ (independientes de cambios en IF):</p>
            <div class="code-block">
                <pre><code>// MMU.hpp - Contadores de IRQ requests
mutable int irq_req_vblank_count_;   // Total requests VBlank (bit 0)
mutable int irq_req_stat_count_;     // Total requests STAT (bit 1)
mutable int irq_req_timer_count_;    // Total requests Timer (bit 2)
mutable int irq_req_serial_count_;   // Total requests Serial (bit 3)
mutable int irq_req_joypad_count_;   // Total requests Joypad (bit 4)

// MMU.cpp - request_interrupt()
void MMU::request_interrupt(uint8_t bit) {
    // Incrementar contador seg√∫n el bit (SIEMPRE, sin importar IF)
    switch (bit) {
        case 0: irq_req_vblank_count_++; break;
        case 1: irq_req_stat_count_++; break;
        case 2: irq_req_timer_count_++; break;
        case 3: irq_req_serial_count_++; break;
        case 4: irq_req_joypad_count_++; break;
    }
    // ... resto del c√≥digo
}</code></pre>
            </div>

            <h3>Tarea 1B: Resumen peri√≥dico de IRQ requests</h3>
            <p>A√±adido <code>log_irq_requests_summary()</code> en MMU, llamado cada 120 frames desde PPU:</p>
            <div class="code-block">
                <pre><code>// PPU.cpp - Al entrar en VBlank
if (frame_counter_ % 120 == 0) {
    mmu_->log_irq_requests_summary(frame_counter_);
}

// MMU.cpp - log_irq_requests_summary()
[IRQ-SUMMARY] Requests generados (totales):
[IRQ-SUMMARY]   VBlank (bit 0): 2
[IRQ-SUMMARY]   STAT   (bit 1): 144
[IRQ-SUMMARY]   Timer  (bit 2): 3
[IRQ-SUMMARY] Estado actual:
[IRQ-SUMMARY]   IE (0xFFFF): 0x1F (VBlank STAT Timer Serial Joypad)
[IRQ-SUMMARY]   IF (0xFF0F): 0x01 (VBlank )
[IRQ-SUMMARY]   LCDC (0xFF40): 0xE3 (LCD ON)
[IRQ-SUMMARY]   TAC (0xFF07): 0x04 (Timer ON)
[IRQ-SUMMARY] An√°lisis:
[IRQ-SUMMARY]   ‚úì HAY INTERRUPCIONES PENDIENTES</code></pre>
            </div>

            <h3>Tarea 2: Post-Boot Registers alineados con Modo HW</h3>
            <p>A√±adido m√©todo <code>apply_post_boot_state(bool is_cgb_mode)</code> en <code>CoreRegisters</code>:</p>
            <div class="code-block">
                <pre><code>// Registers.cpp
void CoreRegisters::apply_post_boot_state(bool is_cgb_mode) {
    if (is_cgb_mode) {
        a = 0x11; b = 0x00; c = 0x00;
        d = 0xFF; e = 0x56;
        h = 0x00; l = 0x0D;
        f = 0x80; // Z=1, N=0, H=0, C=0
    } else {
        a = 0x01; b = 0x00; c = 0x13;
        d = 0x00; e = 0xD8;
        h = 0x01; l = 0x4D;
        f = 0xB0; // Z=1, N=0, H=1, C=1
    }
    sp = 0xFFFE;
    pc = 0x0100;
}

// viboy.py - Despu√©s de cargar ROM
hardware_mode_str = self._mmu.get_hardware_mode()
is_cgb_mode = (hardware_mode_str == "CGB")
self._regs.apply_post_boot_state(is_cgb_mode)</code></pre>
            </div>

            <h3>Tarea 3: Extender detector de wait-loop</h3>
            <p>A√±adida captura de estado completo en <code>CPU.cpp</code> cuando se detecta wait-loop:</p>
            <div class="code-block">
                <pre><code>[WAITLOOP] Timer: TAC=0x00, DIV=0x42, TIMA=0x00
[WAITLOOP]   - Timer OFF
[WAITLOOP]   ‚ö†Ô∏è TIMER APAGADO: No habr√° Timer IRQ
[WAITLOOP] CGB: KEY1=0x00, VBK=0x00, SVBK=0x00</code></pre>
            </div>
        </section>

        <!-- Tests y Verificaci√≥n -->
        <section class="section">
            <h2>üß™ Tests y Verificaci√≥n</h2>

            <h3>Comandos Ejecutados</h3>
            <div class="code-block">
                <pre><code>python3 setup.py build_ext --inplace
timeout 60s python3 main.py roms/pkmn.gb > logs/step0411_pkmn_irq_fix.log 2>&1
timeout 60s python3 main.py roms/Oro.gbc > logs/step0411_oro_irq_fix.log 2>&1
timeout 30s python3 main.py roms/tetris_dx.gbc > logs/step0411_tetris_dx_baseline.log 2>&1

# An√°lisis seguro (sin saturar contexto)
grep -E "\[IRQ-SUMMARY\]|\[WAITLOOP\]|Post-Boot State" logs/step0411_*.log | head -n 160</code></pre>
            </div>

            <h3>Resultados: Oro.gbc (Pok√©mon Oro)</h3>
            <div class="success-box">
                <p><strong>‚úÖ GRAN AVANCE</strong></p>
                <ul>
                    <li>‚úÖ VBlank IRQs: 2 (gener√°ndose correctamente)</li>
                    <li>‚úÖ STAT IRQs: 144 (LCD STAT interrupciones activas)</li>
                    <li>‚úÖ Timer IRQs: 3</li>
                    <li>‚úÖ IE=0x1F (todas las IRQs habilitadas)</li>
                    <li>‚úÖ RETI ejecut√°ndose (ISRs funcionando)</li>
                    <li>‚úÖ LCDC cambia din√°micamente (0x91‚Üí0x00‚Üí0xE3)</li>
                    <li>‚úÖ Hardware Mode: CGB detectado, registros post-boot coherentes</li>
                </ul>
            </div>

            <h3>Resultados: pkmn.gb (Pok√©mon Red)</h3>
            <div class="warning-box">
                <p><strong>‚ö†Ô∏è PROGRESO PARCIAL</strong></p>
                <ul>
                    <li>‚úÖ VBlank IRQs: 1+ (gener√°ndose)</li>
                    <li>‚úÖ LCDC: Cambios din√°micos (0x91‚Üí0x80‚Üí0x81‚Üí0xE3)</li>
                    <li>‚ö†Ô∏è IE=0x0D (VBlank, Timer, Joypad habilitadas, pero Timer OFF)</li>
                    <li>‚ö†Ô∏è TAC=0x00 (Timer apagado ‚Üí no hay Timer IRQ)</li>
                    <li>‚ö†Ô∏è Esperando Joypad input (polling activo en 0x600A-0x600E)</li>
                    <li>‚úÖ Hardware Mode: DMG detectado, <code>A=0x01</code></li>
                </ul>
            </div>

            <h3>Resultados: tetris_dx.gbc (Tetris DX)</h3>
            <div class="warning-box">
                <p><strong>‚ö†Ô∏è ESPERANDO INPUT (sin regresi√≥n)</strong></p>
                <ul>
                    <li>‚úÖ VBlank IRQs: 1+ (gener√°ndose)</li>
                    <li>‚ö†Ô∏è IE=0x00 (interrupciones NO habilitadas al inicio)</li>
                    <li>‚ö†Ô∏è Esperando Joypad input (polling activo)</li>
                    <li>‚úÖ Hardware Mode: CGB detectado, <code>A=0x11</code></li>
                </ul>
            </div>

            <h3>Fragmento de Test (An√°lisis IRQ)</h3>
            <div class="code-block">
                <pre><code>// Test impl√≠cito: Verificaci√≥n de contadores IRQ
// El test ejecuta el emulador y analiza logs

// Extracto de log (Oro.gbc):
[IRQ-SUMMARY] Step 0411 - Frame 0
[IRQ-SUMMARY] Requests generados (totales):
[IRQ-SUMMARY]   VBlank (bit 0): 2
[IRQ-SUMMARY]   STAT   (bit 1): 144
[IRQ-SUMMARY]   Timer  (bit 2): 3
[IRQ-SUMMARY] Estado actual:
[IRQ-SUMMARY]   IE (0xFFFF): 0x1F (VBlank STAT Timer Serial Joypad)
[IRQ-SUMMARY]   IF (0xFF0F): 0x01 (VBlank )
[IRQ-SUMMARY]   LCDC (0xFF40): 0xE3 (LCD ON)
[IRQ-SUMMARY]   TAC (0xFF07): 0x04 (Timer ON)
[IRQ-SUMMARY] An√°lisis:
[IRQ-SUMMARY]   ‚úì HAY INTERRUPCIONES PENDIENTES

// Validaci√≥n de m√≥dulo compilado C++ ‚úì</code></pre>
            </div>
        </section>

        <!-- Archivos Afectados -->
        <section class="section">
            <h2>üìÅ Archivos Modificados</h2>
            <ul class="file-list">
                <li><code>src/core/cpp/MMU.hpp</code> - A√±adidos contadores IRQ y declaraci√≥n de <code>log_irq_requests_summary()</code></li>
                <li><code>src/core/cpp/MMU.cpp</code> - Implementaci√≥n de contadores en <code>request_interrupt()</code> y funci√≥n de resumen</li>
                <li><code>src/core/cpp/PPU.cpp</code> - Llamada peri√≥dica a <code>log_irq_requests_summary()</code></li>
                <li><code>src/core/cpp/CPU.cpp</code> - Extendido detector de wait-loop con Timer y CGB info</li>
                <li><code>src/core/cpp/Registers.hpp</code> - Declaraci√≥n de <code>apply_post_boot_state()</code></li>
                <li><code>src/core/cpp/Registers.cpp</code> - Implementaci√≥n de <code>apply_post_boot_state()</code></li>
                <li><code>src/core/cython/registers.pyx</code> - Binding Cython para <code>apply_post_boot_state()</code></li>
                <li><code>src/core/cython/registers.pxd</code> - Declaraci√≥n C++ para Cython</li>
                <li><code>src/viboy.py</code> - Llamada a <code>apply_post_boot_state()</code> despu√©s de cargar ROM</li>
            </ul>
        </section>

        <!-- Hallazgos Clave -->
        <section class="section">
            <h2>üîç Hallazgos Clave</h2>
            <ol>
                <li><strong>Pipeline de IRQ funciona</strong>: Los contadores demuestran que <code>request_interrupt()</code> se llama correctamente (VBlank, STAT, Timer).</li>
                <li><strong>Oro.gbc avanza significativamente</strong>: Ejecuta RETI, tiene IE=0x1F activo, y LCDC cambia din√°micamente (apagado/encendido). Esto indica que el juego progresa m√°s all√° del boot.</li>
                <li><strong>Pok√©mon Red y Tetris DX esperan input</strong>: Ambos quedan en polling de Joypad (IE bajo, esperando botones). Necesitan simulaci√≥n de input para avanzar.</li>
                <li><strong>Post-Boot Registers ahora coherentes</strong>: <code>A=0x01</code> (DMG) para pkmn.gb, <code>A=0x11</code> (CGB) para Oro.gbc y tetris_dx.gbc.</li>
                <li><strong>Diagn√≥stico mejorado</strong>: <code>[IRQ-SUMMARY]</code> proporciona an√°lisis claro del estado de IRQs, facilitando debugging futuro.</li>
            </ol>
        </section>

        <!-- Pr√≥ximos Pasos -->
        <section class="section">
            <h2>üöÄ Pr√≥ximos Pasos</h2>
            <ol>
                <li><strong>Step 0412: Simulaci√≥n de Joypad Input</strong> - Implementar auto-input simulado (ej: presionar START autom√°ticamente tras N frames) para que juegos que esperan input puedan avanzar.</li>
                <li><strong>Step 0413: Verificar carga de tiles post-input</strong> - Una vez que los juegos reciban input, verificar si cargan tiles correctamente.</li>
                <li><strong>Step 0414: Investigar por qu√© Oro.gbc avanza pero pkmn.gb no</strong> - Analizar diferencias en inicializaci√≥n entre ambos juegos Pok√©mon.</li>
            </ol>
        </section>

        <!-- Referencias -->
        <section class="section">
            <h2>üìö Referencias</h2>
            <ul>
                <li><a href="https://gbdev.io/pandocs/Interrupts.html" target="_blank">Pan Docs - Interrupts</a></li>
                <li><a href="https://gbdev.io/pandocs/Power_Up_Sequence.html" target="_blank">Pan Docs - Power Up Sequence</a></li>
                <li><a href="https://gbdev.io/pandocs/LCDC.html" target="_blank">Pan Docs - LCDC Register</a></li>
                <li><a href="https://gbdev.io/pandocs/Timer_and_Divider_Registers.html" target="_blank">Pan Docs - Timer (TAC, TIMA, TMA, DIV)</a></li>
            </ul>
        </section>

        <!-- Navigation Footer -->
        <footer class="entry-footer">
            <a href="../index.html" class="btn-secondary">‚Üê Volver al √çndice</a>
        </footer>
    </div>
</body>
</html>

