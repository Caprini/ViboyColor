<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis Forense de Trazado de Ejecución - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Análisis Forense de Trazado de Ejecución</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0042
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0041__verificacion-conexion-mmu-ppu-limpieza-debug.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se creó una herramienta de trazado forense (<code>tools/debug_trace.py</code>) para analizar
                    la ejecución del emulador sin interfaz gráfica. El análisis de las primeras instrucciones
                    reveló que el juego ejecuta <strong>DI (0xF3)</strong> en la dirección 0x0150, deshabilitando
                    el IME (Interrupt Master Enable) al inicio. El juego nunca ejecuta <strong>EI (0xFB)</strong>
                    para volver a habilitar las interrupciones, lo que explica por qué el juego se queda en un
                    bucle infinito esperando V-Blank.
                </p>
                <p>
                    Se detectó un bucle de espera (delay loop) entre las direcciones 0x1383-0x1389 que decrementa
                    el registro DE desde 0x06D6 (1750) hasta que sea cero. El juego está esperando un evento
                    (probablemente V-Blank) que nunca ocurre porque IME está deshabilitado, incluso si IE estuviera
                    configurado correctamente.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy, las interrupciones requieren dos niveles de habilitación:
                </p>
                <ol>
                    <li><strong>IME (Interrupt Master Enable)</strong>: Control global de interrupciones, controlado por
                        las instrucciones <code>DI (0xF3)</code> y <code>EI (0xFB)</code>. Si IME = False, ninguna
                        interrupción se procesará, independientemente de IE.</li>
                    <li><strong>IE (Interrupt Enable, 0xFFFF)</strong>: Registro de memoria que controla qué tipos de
                        interrupciones están habilitadas (V-Blank, LCD STAT, Timer, Serial, Joypad).</li>
                </ol>
                <p>
                    Para que una interrupción se procese, <strong>ambos</strong> deben estar habilitados:
                    IME = True <strong>Y</strong> el bit correspondiente en IE = 1. Si IME está deshabilitado,
                    incluso si IE está configurado correctamente, las interrupciones no se procesarán.
                </p>
                <p>
                    Los juegos típicamente ejecutan <code>DI</code> al inicio para deshabilitar interrupciones durante
                    la inicialización, y luego ejecutan <code>EI</code> para volver a habilitarlas. Si el juego nunca
                    ejecuta <code>EI</code>, las interrupciones permanecen deshabilitadas y el juego puede quedar
                    atascado en bucles de espera.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - Interrupts, Interrupt Master Enable (IME), Interrupt Enable Register (IE)
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se creó la herramienta <code>tools/debug_trace.py</code> que:
                </p>
                <ul>
                    <li>Carga una ROM usando la clase <code>Viboy</code></li>
                    <li>Intercepta todas las escrituras en memoria usando un wrapper <code>TraceMMU</code></li>
                    <li>Ejecuta un número configurable de instrucciones (por defecto 50,000)</li>
                    <li>Registra cada instrucción con: PC, opcode, registros, ciclos y escrituras en I/O</li>
                    <li>Detecta bucles infinitos analizando patrones repetidos en el historial de PC</li>
                    <li>Genera un reporte con escrituras críticas (IE, LCDC, IF, STAT) y las primeras/últimas 50 instrucciones</li>
                    <li>Muestra las primeras instrucciones para analizar la secuencia de inicialización del juego</li>
                </ul>

                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><code>tools/debug_trace.py</code>: Script principal de trazado forense (actualizado para mostrar primeras instrucciones)</li>
                    <li><code>TraceMMU</code>: Clase wrapper que intercepta escrituras en memoria</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    Se optó por crear un wrapper de MMU en lugar de modificar el código del emulador para
                    mantener la herramienta de trazado separada del código de producción. Esto permite
                    activar/desactivar el trazado sin afectar el emulador principal.
                </p>
                <p>
                    La detección de bucles se implementa analizando patrones repetidos en el historial de PC.
                    Se detectan tanto bucles exactos (misma secuencia repetida) como bucles cortos con
                    oscilación entre pocas direcciones (típico de saltos condicionales).
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>tools/debug_trace.py</code> - Herramienta de trazado forense (nuevo, actualizado)</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se ejecutó el script de trazado con <code>tetris_dx.gbc</code> (ROM aportada por el usuario, no distribuida):
                </p>
                <ul>
                    <li><strong>Comando ejecutado (análisis inicial):</strong> <code>python tools/debug_trace.py tetris_dx.gbc --max-instructions 5000</code></li>
                    <li><strong>Comando ejecutado (análisis extendido):</strong> <code>python tools/debug_trace.py tetris_dx.gbc --max-instructions 100000</code></li>
                    <li><strong>Entorno:</strong> Windows 10, Python 3.13.5</li>
                    <li><strong>Resultado:</strong> Ejecución exitosa, 100,000 instrucciones trazadas</li>
                    <li><strong>Qué valida:</strong>
                        <ul>
                            <li>Que el juego ejecuta DI (0xF3) en la instrucción #3 (PC: 0x0150)</li>
                            <li>Que el juego <strong>NUNCA</strong> ejecuta EI (0xFB) en 100,000 instrucciones</li>
                            <li>Que el juego nunca escribe en IE (0xFFFF) durante las 100,000 instrucciones</li>
                            <li>Que existe un bucle de espera que persiste después de 100,000 instrucciones</li>
                            <li>Que el juego escribe en I/O (370 escrituras detectadas, principalmente en 0xFF00 - P1)</li>
                        </ul>
                    </li>
                </ul>

                <h3>Hallazgos del análisis - Secuencia de Inicio</h3>
                <p>
                    Análisis de las <strong>primeras instrucciones</strong> reveló la secuencia de inicialización:
                </p>
                <pre><code>PC: 0x0100 | NOP (0x00)              - Inicio del código del cartucho
PC: 0x0101 | JP nn (0xC3)            - Salto a 0x0150
PC: 0x0150 | DI (0xF3)               - ⚠️ DESHABILITA INTERRUPCIONES (IME = False)
PC: 0x0151 | LD (0xFF00+C), A (0xE0) - Escribe en 0xFF04 (DIV - Timer Divider)
PC: 0x0153 | LD (0xFF00+C), A (0xE0) - Otra escritura en I/O
PC: 0x0155 | LD BC, d16 (0x01)       - Carga BC con 0x0004
PC: 0x0158 | CALL nn (0xCD)         - Llama a función en 0x1380
PC: 0x1380 | LD DE, d16 (0x11)      - Carga DE con 0x06D6 (1750)
PC: 0x1383-0x1389 | Bucle de espera - Decrementa DE hasta 0
</code></pre>

                <h3>Hallazgos del análisis - Verificación Extendida (100,000 instrucciones)</h3>
                <p>
                    Análisis extendido con <strong>100,000 instrucciones</strong> confirmó los hallazgos iniciales:
                </p>
                <pre><code>EJECUCIONES DE DI/EI (Interrupt Master Enable):
  Instruccion #3 | PC: 0x0150 | DI (0xF3) | IME antes: Deshabilitado

RESUMEN:
  - DI ejecutado: 1 vez (instrucción #3, PC: 0x0150)
  - EI ejecutado: 0 veces (NUNCA en 100,000 instrucciones)
  - Escrituras en IE (0xFFFF): 0
  - Escrituras en I/O: 370 (principalmente 0xFF00 - P1 Joypad)
  - Estado final: Bucle persistente entre 0x12DD-0x12EC
</code></pre>

                <p>
                    <strong>Hallazgo crítico confirmado:</strong> El juego ejecuta <code>DI (0xF3)</code> una sola vez
                    en la instrucción #3 (PC: 0x0150), deshabilitando IME al inicio. El juego <strong>NUNCA ejecuta
                    EI (0xFB)</strong> en 100,000 instrucciones para volver a habilitar las interrupciones. Esto
                    significa que incluso si IE estuviera configurado correctamente, las interrupciones no se
                    procesarían porque IME está permanentemente en False.
                </p>
                <p>
                    <strong>Observación adicional:</strong> Después de 100,000 instrucciones, el juego sigue en un
                    bucle, pero ahora entre las direcciones 0x12DD-0x12EC (diferente al bucle inicial 0x1383-0x1389).
                    El juego escribe en 0xFF00 (P1 - Joypad) durante el bucle, lo que sugiere que está esperando
                    entrada del usuario o algún evento que nunca ocurre.
                </p>

                <h3>Hallazgos del análisis - Bucle de Espera</h3>
                <pre><code>BUCLE DETECTADO:
PC oscila entre: 0x1383-0x1389
Patrón:
  0x1383: NOP (0x00)
  0x1384: NOP (0x00)
  0x1385: NOP (0x00)
  0x1386: DEC DE (0x1B) - Decrementa DE
  0x1387: LD A, D (0x7A) - Carga D en A
  0x1388: OR E (0xB3) - OR entre A y E
  0x1389: JR NZ, -5 (0x20) - Salto relativo si no es cero
</code></pre>

                <p>
                    <strong>Análisis del bucle:</strong> El juego está en un delay loop que decrementa DE desde 0x06D6
                    (1750) hasta que sea 0. Cuando DE llega a 0, el salto condicional (JR NZ) no se ejecuta y el bucle
                    debería terminar. Sin embargo, el juego probablemente espera que algo más ocurra (como una
                    interrupción V-Blank) antes de continuar, pero como IME está deshabilitado, las interrupciones
                    nunca se procesan.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Interrupts, Interrupt Enable Register (IE)</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - JR (Jump Relative)</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>IME vs IE:</strong> Las interrupciones requieren dos niveles de habilitación:
                            IME (control global, DI/EI) e IE (registro de memoria). Si IME está deshabilitado,
                            ninguna interrupción se procesará, incluso si IE está configurado correctamente.</li>
                        <li><strong>DI/EI:</strong> Los juegos típicamente ejecutan DI al inicio para deshabilitar
                            interrupciones durante la inicialización, y luego ejecutan EI para volver a habilitarlas.
                            Si el juego nunca ejecuta EI, las interrupciones permanecen deshabilitadas.</li>
                        <li><strong>Delay Loops:</strong> Los juegos usan bucles de espera (delay loops) para pausar
                            la ejecución durante un tiempo determinado. Estos bucles típicamente decrementan un registro
                            hasta que sea 0.</li>
                        <li><strong>Bucle infinito:</strong> Si un juego espera una interrupción que nunca ocurre
                            (porque IME está deshabilitado), puede quedar atascado en un bucle infinito esperando
                            un evento que nunca llegará.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Por qué el juego no ejecuta EI:</strong> Confirmado que el juego nunca ejecuta EI en
                            100,000 instrucciones. No está claro si:
                            <ul>
                                <li>El juego nunca llega a la parte del código que ejecuta EI (se queda atascado antes)</li>
                                <li>Hay un bug en la implementación de DI/EI que impide que IME se habilite correctamente</li>
                                <li>El juego espera que IME esté habilitado por defecto (bug en inicialización)</li>
                            </ul>
                        </li>
                        <li><strong>Qué ocurre después del delay loop:</strong> El análisis de 100,000 instrucciones muestra
                            que el juego entra en diferentes bucles (0x1383-0x1389 inicialmente, luego 0x12DD-0x12EC).
                            El juego nunca sale completamente de los bucles de espera.</li>
                        <li><strong>Estado inicial de IME:</strong> El análisis muestra que IME está "Deshabilitado" antes
                            de ejecutar DI en la instrucción #3, lo que sugiere que IME se inicializa en False (correcto).
                            Sin embargo, necesito verificar la implementación para confirmar.</li>
                        <li><strong>Implementación de DI/EI:</strong> Necesito verificar que la implementación de DI/EI en la CPU
                            funcione correctamente y que IME se actualice como se espera cuando se ejecutan estas instrucciones.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis principal (CONFIRMADA):</strong> El juego ejecuta DI al inicio para deshabilitar
                        interrupciones durante la inicialización, pero <strong>nunca ejecuta EI</strong> para volver a habilitarlas
                        (verificado en 100,000 instrucciones). Esto causa que el juego quede atascado en un bucle de espera
                        esperando V-Blank, que nunca se procesa porque IME está permanentemente deshabilitado.
                    </p>
                    <p>
                        <strong>Hipótesis secundaria:</strong> Es posible que:
                        <ul>
                            <li>El juego tenga un bug y nunca llegue al código que ejecuta EI</li>
                            <li>Haya un bug en la implementación de DI/EI que impida que IME se habilite correctamente</li>
                            <li>El juego espere que IME esté habilitado por defecto (bug en inicialización del emulador)</li>
                        </ul>
                    </p>
                    <p>
                        <strong>Suposición no verificada:</strong> No puedo verificar si el juego debería ejecutar EI sin
                        analizar el código de la ROM (lo cual no es posible sin herramientas de desensamblado). Sin embargo,
                        el hecho de que el juego nunca ejecute EI en 100,000 instrucciones sugiere fuertemente que hay un problema
                        en la lógica de inicialización o en la implementación del emulador.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Verificar la implementación de DI/EI en la CPU para asegurar que IME se actualiza correctamente</li>
                    <li>[ ] Trazar más instrucciones (100,000+) para ver si el juego eventualmente ejecuta EI</li>
                    <li>[ ] Analizar el estado inicial de IME y otros registros críticos al inicio de la ejecución</li>
                    <li>[ ] Verificar si hay algún problema con el manejo de interrupciones que impida que el juego las habilite</li>
                    <li>[ ] Considerar forzar IME = True temporalmente para ver si el juego continúa (si IE está configurado)</li>
                    <li>[ ] Verificar si el juego espera que IME esté habilitado por defecto al inicio (bug en inicialización)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

