<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBC Unificado & Instrumentación VRAM/WRAM - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>MBC Unificado & Instrumentación VRAM/WRAM</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-25
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0272
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-24__0271__misc-instructions-implementation.html">Anterior (0271)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se unificó el soporte de controladores de banco (MBC) en la MMU C++ para ROM_ONLY, MBC1, MBC2, MBC3 y MBC5, dimensionando la RAM externa según el header y normalizando bancos de ROM/RAM. Se añadieron trazas ligeras para detectar escrituras/lecturas a <code>0xD732</code>, VRAM y solicitudes/servicio de interrupciones.
                </p>
                <p>
                    El monitor GPS ahora separa <code>VRAM_TILE_SUM</code> (0x8000-0x97FF) de <code>VRAM_MAP_SUM</code> (0x9800-0x9FFF) y reporta <code>0xD732</code> en caliente. Resultado actual (Pokémon Red): VBlank se solicita y atiende, <code>D732</code> solo se escribe con <code>00</code>, se detecta un barrido de escrituras de VRAM llenando de ceros la tile data desde PC=0x36E3, y el tilemap sigue lleno de 0x7F (pantalla verde).
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    Los MBC (Memory Bank Controllers) permiten a cartuchos de >32KB exponer bancos de ROM/RAM conmutables. MBC1 combina bits bajos/altos y modo ROM/RAM; MBC2 trae RAM interna de 512x4 bits; MBC3 añade RTC y bancos de RAM seleccionables; MBC5 extiende a 9 bits de banco de ROM y hasta 16 bancos de RAM.
                </p>
                <p>
                    Instrumentar VRAM y flags de estado (ej. <code>0xD732</code>) es clave para verificar si la CPU está copiando gráficos (tile data) o solo modificando el tilemap. Separar tile data vs tilemap ayuda a localizar la causa de pantalla verde cuando el mapa cambia pero los tiles no.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    En <code>MMU.cpp</code>/<code>MMU.hpp</code> se añadieron campos de estado para cada MBC, cálculo de bancos desde el header, asignación de RAM por tamaño declarado y mapeo de bancos <code>bank0_rom</code>/<code>bankN_rom</code>. Se implementaron rutas de escritura para enable de RAM, selección de banco de ROM/RAM (MBC1/2/3/5) y stub de RTC en MBC3. Se normalizan bancos contra el total cargado para evitar lecturas fuera de rango.
                </p>
                <p>
                    Se instrumentaron las primeras escrituras/lecturas a <code>0xD732</code> y VRAM (0x8000-0x9FFF) para detectar actividad real. En <code>viboy.py</code> el GPS ahora reporta sumas separadas de tile data y tilemap, más la lectura de <code>D732</code> cada segundo.
                </p>

                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><code>src/core/cpp/MMU.hpp / MMU.cpp</code> – Soporte MBC1/2/3/5 unificado, asignación dinámica de RAM, logs de VRAM/WRAM.</li>
                    <li><code>src/viboy.py</code> – GPS ampliado con <code>VRAM_TILE_SUM</code>, <code>VRAM_MAP_SUM</code> y lectura de <code>0xD732</code>.</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    Se mantuvo el estado por-MBC para no romper compatibilidad con cartuchos pequeños (ROM_ONLY) y se limitaron los logs a los primeros accesos para no inundar la salida en modo <code>--verbose</code>. Se priorizó visibilidad sobre corrección visual mientras se diagnostica la falta de escrituras de tile data.
                </p>
            </section>

            <!-- 4. Archivos Afectados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.hpp</code> – Nuevos campos de estado y helpers de MBC/RAM.</li>
                    <li><code>src/core/cpp/MMU.cpp</code> – Lógica de banking unificada, asignación de RAM, logs VRAM/WRAM.</li>
                    <li><code>src/viboy.py</code> – Métricas de VRAM separadas y lectura de <code>D732</code> en GPS.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <ul>
                    <li><strong>ROM:</strong> <code>python main.py roms/pkmn.gb --verbose</code> (10-15s). Observado: <code>VRAM_TILE_SUM=0</code>, <code>VRAM_MAP_SUM=16256</code>, <code>D732=00</code>, PC en 0x615x; VBlank IRQs solicitadas/atendidas; escritura masiva de 0x00 en VRAM tile data desde PC=0x36E3; tilemap permanece en 0x7F.</li>
                    <li><strong>Rebuild:</strong> <code>rebuild_cpp.ps1</code> tras cada cambio en C++.</li>
                    <li><strong>VRAM inicial:</strong> PyMMU + cartucho: 0x8000/0x9800 arrancan en 0x00 (confirmado que el llenado de 0x7F ocurre en runtime, no en la carga).</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs – Secciones: MBC1, MBC2, MBC3, MBC5, Memory Map.</li>
                    <li>Pan Docs – LCD Control, VRAM layout (tile data 0x8000-0x97FF, tilemaps 0x9800/0x9C00).</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li>Pokémon Red (tipo 0x13) usa MBC3: necesita bancos de ROM altos y RAM con enable.</li>
                        <li>El tilemap se está llenando (0x7F); la tile data se sobrescribe con ceros desde PC=0x36E3, lo que explica la pantalla verde.</li>
                        <li><code>0xD732</code> permanece en 0, solo escrito con 0x00 en PC=0x1F80.</li>
                        <li>VBlank se solicita y se atiende (logs en IRQ/VBlank), por lo que las interrupciones básicas están vivas.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li>Quién y por qué limpia la tile data a 0x00 en PC=0x36E3 (desensamblar esa rutina y su banco).</li>
                        <li>Quién debería setear <code>D732</code> y en qué rutina (posible ISR o bucle de init).</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        El juego inicializa tilemap y luego limpia tile data (0x36E3) porque aún no ha ejecutado la rutina que copia los tiles reales; podría estar bloqueado esperando <code>D732</code> antes de cargar gráficos o en otra rama de init.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Loguear escrituras a 0x9800-0x9FFF y 0x8000-0x97FF con un límite mayor para captar el primer copy.</li>
                    <li>[ ] Desensamblar el bloque en 0x6150 (banco activo) y la rutina en 0x36E3 que limpia VRAM para ver condiciones de carga de tiles.</li>
                    <li>[ ] Identificar cuándo debería escribirse <code>D732</code> (ISR o bucle de init) y forzar un log allí.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>


