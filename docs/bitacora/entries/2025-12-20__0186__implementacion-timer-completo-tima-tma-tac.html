<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Coraz√≥n del Tiempo: Implementaci√≥n del Timer Completo (TIMA, TMA, TAC) - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>El Coraz√≥n del Tiempo: Implementaci√≥n del Timer Completo (TIMA, TMA, TAC)</h1>
            <!-- Entrada 0186 - El Coraz√≥n del Tiempo: Implementaci√≥n del Timer Completo -->
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0186
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">‚úÖ VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0185__hito-limpieza-primeros-graficos-precision-hardware.html">Anterior (0185)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Tras el √©xito del Step 0185, donde el emulador renderiz√≥ exitosamente el logo de Nintendo, surgi√≥ un diagn√≥stico cr√≠tico: aunque el emulador est√° estable y el registro <code>LY</code> cicla correctamente, la pantalla permanece en blanco porque la CPU nunca llega a la instrucci√≥n que activa el renderizado del fondo. El diagn√≥stico apunt√≥ a que la CPU est√° atrapada en un bucle de retardo de tiempo, esperando una interrupci√≥n del Timer que nuestro n√∫cleo C++ a√∫n no pod√≠a generar.
                </p>
                <p>
                    Este Step implementa el subsistema completo del Timer programable (<code>TIMA</code>, <code>TMA</code>, <code>TAC</code>) en C++, completando la funcionalidad que solo ten√≠a el registro <code>DIV</code>. Con esta implementaci√≥n, el emulador puede ejecutar rutinas de temporizaci√≥n precisas, permitiendo que los juegos completen sus secuencias de arranque y, finalmente, den la orden de dibujar la pantalla de t√≠tulo.
                </p>
                <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin: 1rem 0;">
                    <strong>üîç Diagn√≥stico Definitivo:</strong> La paradoja de la precisi√≥n. Nuestra PPU, ahora precisa, ve que el Bit 0 del <code>LCDC</code> es 0 y, obedientemente, se niega a dibujar la capa de fondo. El problema no es nuestro emulador; es que el juego nunca llega a la instrucci√≥n que cambia <code>LCDC</code> de <code>0x80</code> a <code>0x91</code> porque est√° esperando una interrupci√≥n del Timer que a√∫n no pod√≠amos generar.
                </div>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: El Temporizador Programable</h2>
                <p>
                    Adem√°s del registro <code>DIV</code> (Divider, 0xFF04), la Game Boy tiene un temporizador configurable por el juego, controlado por 3 registros:
                </p>
                <ul>
                    <li>
                        <strong><code>TAC</code> (Timer Control - 0xFF07):</strong>
                        <ul>
                            <li><strong>Bit 2:</strong> Timer Enable (1 = ON, 0 = OFF).</li>
                            <li><strong>Bits 1-0:</strong> Input Clock Select. Selecciona la frecuencia a la que se incrementa <code>TIMA</code>:
                                <ul>
                                    <li><code>00</code>: 4096 Hz (1024 T-Cycles por incremento)</li>
                                    <li><code>01</code>: 262144 Hz (16 T-Cycles por incremento)</li>
                                    <li><code>10</code>: 65536 Hz (64 T-Cycles por incremento)</li>
                                    <li><code>11</code>: 16384 Hz (256 T-Cycles por incremento)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong><code>TIMA</code> (Timer Counter - 0xFF05):</strong> Es un contador de 8 bits que se incrementa a la frecuencia seleccionada en <code>TAC</code>. Cuando <code>TIMA</code> se desborda (pasa de <code>0xFF</code> a <code>0x00</code>), se recarga autom√°ticamente con el valor de <code>TMA</code> y se solicita una <strong>interrupci√≥n de Timer (Bit 2 del registro <code>IF</code>)</strong>.
                    </li>
                    <li>
                        <strong><code>TMA</code> (Timer Modulo - 0xFF06):</strong> Cuando <code>TIMA</code> se desborda, se recarga autom√°ticamente con el valor de <code>TMA</code>.
                    </li>
                </ul>
                <p>
                    El BIOS y los juegos usan este sistema para crear retardos precisos. Si no se implementa, cualquier juego que configure el Timer y luego use <code>HALT</code> para esperar la interrupci√≥n se quedar√° congelado para siempre.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - Timer and Divider Register, Timer Control, Timer Counter, Timer Modulo.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                
                <h3>1. Expansi√≥n de la Clase Timer en C++</h3>
                <p>
                    Se expandi√≥ la clase <code>Timer</code> existente para incluir los registros <code>TIMA</code>, <code>TMA</code> y <code>TAC</code>, junto con la l√≥gica de desbordamiento e interrupciones.
                </p>
                
                <h4>Modificaciones en <code>Timer.hpp</code>:</h4>
                <ul>
                    <li>Agregado puntero a <code>MMU</code> para solicitar interrupciones cuando <code>TIMA</code> desborda</li>
                    <li>Agregados miembros privados: <code>tima_counter_</code>, <code>tima_</code>, <code>tma_</code>, <code>tac_</code></li>
                    <li>Agregados m√©todos p√∫blicos: <code>read_tima()</code>, <code>write_tima()</code>, <code>read_tma()</code>, <code>write_tma()</code>, <code>read_tac()</code>, <code>write_tac()</code></li>
                    <li>Agregado m√©todo privado: <code>get_tima_threshold()</code> para calcular el n√∫mero de T-Cycles seg√∫n la frecuencia configurada</li>
                    <li>Modificado el constructor para aceptar un puntero a <code>MMU</code></li>
                </ul>

                <h4>Modificaciones en <code>Timer.cpp</code>:</h4>
                <ul>
                    <li>Actualizado el m√©todo <code>step()</code> para manejar el incremento de <code>TIMA</code> seg√∫n la configuraci√≥n de <code>TAC</code></li>
                    <li>Implementada la l√≥gica de desbordamiento: cuando <code>TIMA</code> pasa de <code>0xFF</code> a <code>0x00</code>, se recarga con <code>TMA</code> y se solicita una interrupci√≥n mediante <code>mmu_-&gt;request_interrupt(2)</code></li>
                    <li>Implementado <code>get_tima_threshold()</code> que retorna el n√∫mero de T-Cycles necesario seg√∫n los bits 1-0 de <code>TAC</code></li>
                </ul>

                <h3>2. Integraci√≥n en la MMU</h3>
                <p>
                    Se actualiz√≥ <code>MMU.cpp</code> para manejar las lecturas y escrituras de los registros del Timer:
                </p>
                <ul>
                    <li><code>0xFF05</code> (<code>TIMA</code>): Lectura/escritura mediante <code>Timer::read_tima()</code> / <code>Timer::write_tima()</code></li>
                    <li><code>0xFF06</code> (<code>TMA</code>): Lectura/escritura mediante <code>Timer::read_tma()</code> / <code>Timer::write_tma()</code></li>
                    <li><code>0xFF07</code> (<code>TAC</code>): Lectura/escritura mediante <code>Timer::read_tac()</code> / <code>Timer::write_tac()</code></li>
                </ul>

                <h3>3. Actualizaci√≥n de Wrappers Cython</h3>
                <p>
                    Se actualizaron los wrappers Cython para exponer la nueva funcionalidad:
                </p>
                <ul>
                    <li><code>timer.pxd</code>: Agregadas declaraciones para los nuevos m√©todos y modificado el constructor para aceptar <code>MMU*</code></li>
                    <li><code>timer.pyx</code>: Implementados m√©todos Python para leer/escribir <code>TIMA</code>, <code>TMA</code> y <code>TAC</code>, y modificado el constructor para aceptar un <code>PyMMU</code> opcional</li>
                    <li><code>mmu.pyx</code>: Agregado m√©todo <code>get_cpp_ptr()</code> para mantener consistencia con otros wrappers</li>
                </ul>

                <h3>4. Actualizaci√≥n del Sistema Principal</h3>
                <p>
                    Se actualiz√≥ <code>viboy.py</code> para pasar la instancia de <code>MMU</code> al constructor de <code>PyTimer</code>, permitiendo que el Timer solicite interrupciones correctamente.
                </p>

                <h3>Decisiones de Dise√±o</h3>
                <p>
                    <strong>¬øPor qu√© el Timer necesita un puntero a MMU?</strong> Cuando <code>TIMA</code> desborda, el hardware solicita una interrupci√≥n de Timer escribiendo en el bit 2 del registro <code>IF</code> (0xFF0F). Como la MMU es la due√±a de la memoria y maneja el registro <code>IF</code>, el Timer necesita un puntero a la MMU para poder solicitar interrupciones.
                </p>
                <p>
                    <strong>Manejo de m√∫ltiples incrementos:</strong> El m√©todo <code>step()</code> maneja correctamente casos donde una instrucci√≥n consume muchos T-Cycles, usando un bucle <code>while</code> para procesar m√∫ltiples incrementos de <code>TIMA</code> si es necesario.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/Timer.hpp</code> - Expansi√≥n para incluir TIMA, TMA, TAC</li>
                    <li><code>src/core/cpp/Timer.cpp</code> - Implementaci√≥n de l√≥gica de desbordamiento e interrupciones</li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Manejo de lecturas/escrituras de 0xFF05, 0xFF06, 0xFF07</li>
                    <li><code>src/core/cython/timer.pxd</code> - Declaraciones Cython actualizadas</li>
                    <li><code>src/core/cython/timer.pyx</code> - Wrapper Python actualizado con nuevos m√©todos</li>
                    <li><code>src/core/cython/mmu.pyx</code> - Agregado m√©todo get_cpp_ptr()</li>
                    <li><code>src/viboy.py</code> - Actualizado para pasar MMU al constructor de PyTimer</li>
                    <li><code>tests/test_core_timer.py</code> - Tests completos para TIMA, TMA, TAC</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    <strong>Comando ejecutado:</strong>
                </p>
                <pre><code>python -m pytest tests/test_core_timer.py -v</code></pre>
                <p>
                    <strong>Resultado:</strong> <strong>16 tests pasados</strong> en 0.07s
                </p>
                <p>
                    Los tests validan:
                </p>
                <ol>
                    <li>‚úÖ Lectura/escritura de <code>TIMA</code>, <code>TMA</code> y <code>TAC</code></li>
                    <li>‚úÖ Incremento de <code>TIMA</code> cuando el Timer est√° activado</li>
                    <li>‚úÖ <code>TIMA</code> NO se incrementa cuando el Timer est√° desactivado</li>
                    <li>‚úÖ <code>TIMA</code> se incrementa a las frecuencias correctas (4096Hz, 262144Hz, 65536Hz, 16384Hz)</li>
                    <li>‚úÖ Cuando <code>TIMA</code> desborda, se recarga con el valor de <code>TMA</code></li>
                    <li>‚úÖ Cuando <code>TIMA</code> desborda, se solicita una interrupci√≥n de Timer (bit 2 de IF)</li>
                    <li>‚úÖ Manejo correcto de m√∫ltiples incrementos en un solo <code>step()</code></li>
                </ol>
                <p>
                    <strong>C√≥digo del Test Clave:</strong>
                </p>
                <pre><code>def test_tima_overflow_requests_interrupt(self):
    """Verifica que cuando TIMA desborda, se solicita una interrupci√≥n de Timer."""
    mmu = PyMMU()
    timer = PyTimer(mmu)
    mmu.set_timer(timer)  # Conectar Timer a MMU para interrupciones
    
    # Configurar TIMA cerca del desbordamiento
    timer.write_tima(0xFF)
    timer.write_tac(0x04)  # Timer ON, frecuencia 4096 Hz
    
    # Avanzar 1024 T-Cycles (deber√≠a causar desbordamiento)
    timer.step(1024)
    
    # Verificar que se solicit√≥ una interrupci√≥n de Timer (bit 2 del registro IF)
    if_reg = mmu.read(0xFF0F)
    assert (if_reg & 0x04) != 0, "Se deber√≠a haber solicitado una interrupci√≥n de Timer (bit 2 de IF)"</code></pre>
                <p>
                    <strong>Validaci√≥n Nativa:</strong> Validaci√≥n de m√≥dulo compilado C++ con tests unitarios exhaustivos.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: Timer and Divider Register (0xFF04)</li>
                    <li>Pan Docs: Timer Counter (TIMA - 0xFF05)</li>
                    <li>Pan Docs: Timer Modulo (TMA - 0xFF06)</li>
                    <li>Pan Docs: Timer Control (TAC - 0xFF07)</li>
                    <li>Pan Docs: Interrupts, Interrupt Flag Register (IF - 0xFF0F)</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>El Timer programable:</strong> Adem√°s del DIV (que es un contador continuo), la Game Boy tiene un Timer programable que permite a los juegos crear retardos precisos y generar interrupciones de tiempo.</li>
                        <li><strong>Las frecuencias del Timer:</strong> El Timer puede funcionar a 4 frecuencias diferentes (4096Hz, 262144Hz, 65536Hz, 16384Hz), seleccionadas mediante los bits 1-0 de TAC.</li>
                        <li><strong>El desbordamiento y la recarga:</strong> Cuando TIMA desborda (0xFF ‚Üí 0x00), se recarga autom√°ticamente con el valor de TMA y se solicita una interrupci√≥n de Timer.</li>
                        <li><strong>La importancia para la secuencia de arranque:</strong> El BIOS y los juegos usan el Timer para crear retardos precisos durante la inicializaci√≥n. Sin esta funcionalidad, los juegos se quedar√≠an congelados esperando interrupciones que nunca llegan.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Verificaci√≥n con ROMs reales:</strong> El pr√≥ximo paso ser√° ejecutar el emulador con una ROM real para verificar que el Timer completo permite que los juegos completen sus rutinas de temporizaci√≥n y finalmente dibujen la pantalla de t√≠tulo.</li>
                        <li><strong>Sincronizaci√≥n con HALT:</strong> Verificar que cuando la CPU ejecuta HALT y el Timer genera una interrupci√≥n, la CPU se despierta correctamente y procesa la interrupci√≥n.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        No hay suposiciones cr√≠ticas. La implementaci√≥n est√° basada directamente en Pan Docs, que especifica claramente el comportamiento de cada registro y la relaci√≥n entre TIMA, TMA y TAC.
                    </p>
                </div>
            </section>

            <!-- 8. Resultado Final -->
            <section id="resultado">
                <h2>Resultado Final</h2>
                <p>
                    Despu√©s de esta implementaci√≥n, el emulador ahora tiene:
                </p>
                <ul>
                    <li>‚úÖ <strong>Timer completo funcional:</strong> Todos los registros del Timer (DIV, TIMA, TMA, TAC) est√°n implementados y funcionando correctamente</li>
                    <li>‚úÖ <strong>Interrupciones de Timer:</strong> Cuando TIMA desborda, se solicita correctamente una interrupci√≥n de Timer (bit 2 de IF)</li>
                    <li>‚úÖ <strong>Frecuencias precisas:</strong> El Timer se incrementa a las frecuencias correctas seg√∫n la configuraci√≥n de TAC</li>
                    <li>‚úÖ <strong>Tests exhaustivos:</strong> 16 tests unitarios validan toda la funcionalidad del Timer</li>
                </ul>
                <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem; margin: 1rem 0;">
                    <strong>üéØ Pr√≥ximo Hito Esperado:</strong> Con el Timer completo implementado, el emulador deber√≠a ser capaz de ejecutar las rutinas de temporizaci√≥n de los juegos, permitiendo que completen sus secuencias de arranque y finalmente dibujen la pantalla de t√≠tulo. El diagn√≥stico del Step 0185 apuntaba a que la CPU estaba atrapada esperando una interrupci√≥n del Timer. Ahora que el Timer puede generar esas interrupciones, esperamos ver el logo de Nintendo aparecer en pantalla.
                </div>
            </section>

            <!-- 9. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador con una ROM real para verificar que el Timer completo permite que los juegos completen sus rutinas de temporizaci√≥n</li>
                    <li>[ ] Verificar que las interrupciones de Timer despiertan correctamente a la CPU cuando est√° en estado HALT</li>
                    <li>[ ] Si todo funciona correctamente, deber√≠amos ver finalmente el logo de Nintendo en pantalla</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

