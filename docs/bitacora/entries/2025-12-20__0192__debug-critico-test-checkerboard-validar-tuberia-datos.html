<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Cr√≠tico: El "Test del Checkerboard" para Validar la Tuber√≠a de Datos - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug Cr√≠tico: El "Test del Checkerboard" para Validar la Tuber√≠a de Datos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0192
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîç DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0191__hito-primeros-graficos-limpieza-post-victoria.html">Anterior (0191)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Hemos llegado a un punto cr√≠tico. A pesar de tener un n√∫cleo de emulaci√≥n completamente sincronizado y funcional, la pantalla permanece en blanco. La hip√≥tesis principal es que, aunque la PPU en C++ podr√≠a estar renderizando correctamente en su framebuffer interno, estos datos no est√°n llegando a la capa de Python a trav√©s del puente de Cython (`memoryview`).
                </p>
                <p>
                    Este Step implementa un "Test del Checkerboard": modifica temporalmente `PPU::render_scanline()` para que ignore toda la l√≥gica de emulaci√≥n y dibuje un patr√≥n de tablero de ajedrez directamente en el framebuffer. Esto nos permitir√° validar de forma inequ√≠voca si la tuber√≠a de datos C++ ‚Üí Cython ‚Üí Python est√° funcionando.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Ingenier√≠a: Aislamiento y Prueba de la Tuber√≠a de Datos</h2>
                <p>
                    Cuando un sistema complejo falla, la mejor estrategia de depuraci√≥n es el <strong>aislamiento</strong>. Vamos a aislar la "tuber√≠a" de renderizado del resto del emulador. Si podemos escribir datos en un `std::vector` en C++ y leerlos en un `PixelArray` en Python, entonces la tuber√≠a funciona. Si no, la tuber√≠a est√° rota.
                </p>
                <p>
                    El patr√≥n de checkerboard es ideal porque es:
                </p>
                <ul>
                    <li><strong>Visualmente inconfundible:</strong> Un tablero de ajedrez es imposible de confundir con cualquier otro patr√≥n.</li>
                    <li><strong>F√°cil de generar matem√°ticamente:</strong> No requiere acceso a VRAM, tiles, o cualquier otro componente del emulador.</li>
                    <li><strong>Determinista:</strong> Si la tuber√≠a funciona, veremos el patr√≥n. Si no funciona, veremos pantalla blanca.</li>
                </ul>
                <p>
                    Este test nos dar√° una respuesta binaria y definitiva sobre d√≥nde est√° el problema:
                </p>
                <ul>
                    <li><strong>Si vemos el checkerboard:</strong> La tuber√≠a funciona. El problema est√° en la VRAM (la CPU no est√° copiando los datos del logo).</li>
                    <li><strong>Si la pantalla sigue en blanco:</strong> La tuber√≠a est√° rota. El problema est√° en el wrapper de Cython o en c√≥mo se expone el framebuffer.</li>
                </ul>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Modificamos temporalmente `PPU::render_scanline()` para reemplazar toda la l√≥gica de renderizado con un generador de patr√≥n checkerboard simple.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code>: M√©todo <code>render_scanline()</code> reemplazado con l√≥gica de checkerboard</li>
                </ul>

                <h3>L√≥gica del Checkerboard</h3>
                <p>
                    El patr√≥n se genera l√≠nea por l√≠nea:
                </p>
                <pre><code>// Para cada p√≠xel (x, y) en la l√≠nea actual:
bool is_dark = ((ly_ / 8) % 2) == ((x / 8) % 2);
uint8_t color_index = is_dark ? 3 : 0;
framebuffer_[line_start_index + x] = color_index;</code></pre>
                <p>
                    Esta l√≥gica divide la pantalla en bloques de 8x8 p√≠xeles. Si tanto la fila como la columna del bloque son pares o impares, el bloque es oscuro (color 3). Si uno es par y el otro impar, el bloque es claro (color 0).
                </p>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>Ignorar toda la l√≥gica de la PPU:</strong> No leemos LCDC, VRAM, tiles, o cualquier otro registro. Esto elimina todas las variables posibles excepto la tuber√≠a de datos.</li>
                    <li><strong>Usar colores 0 y 3:</strong> Color 0 (blanco) y color 3 (negro) son los extremos de la paleta, lo que hace el patr√≥n m√°s visible.</li>
                    <li><strong>Patr√≥n de 8x8:</strong> Coincide con el tama√±o de los tiles del Game Boy, lo que hace el patr√≥n m√°s reconocible para desarrolladores familiarizados con el hardware.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - M√©todo <code>render_scanline()</code> reemplazado con test del checkerboard</li>
                    <li><code>docs/bitacora/entries/2025-12-20__0192__debug-critico-test-checkerboard-validar-tuberia-datos.html</code> - Nueva entrada de bit√°cora</li>
                    <li><code>docs/bitacora/index.html</code> - Actualizado con la nueva entrada</li>
                    <li><code>INFORME_FASE_2.md</code> - Actualizado con el Step 0192</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    Este test es puramente visual. No requiere tests unitarios, ya que estamos validando la integraci√≥n completa del sistema.
                </p>
                
                <h3>Proceso de Verificaci√≥n</h3>
                <ol>
                    <li><strong>Recompilar el m√≥dulo C++:</strong>
                        <pre><code>.\rebuild_cpp.ps1</code></pre>
                    </li>
                    <li><strong>Ejecutar el emulador:</strong>
                        <pre><code>python main.py roms/tetris.gb</code></pre>
                    </li>
                    <li><strong>Observar la ventana de Pygame:</strong> La ventana deber√≠a mostrar uno de dos resultados posibles.</li>
                </ol>

                <h3>Resultados Posibles</h3>
                
                <h4>Resultado 1: Vemos un Tablero de Ajedrez</h4>
                <p>
                    <strong>Significado:</strong> ¬°La tuber√≠a de datos funciona! C++ est√° escribiendo, Cython est√° exponiendo, y Python est√° leyendo y dibujando.
                </p>
                <p>
                    <strong>Diagn√≥stico:</strong> El problema, entonces, es 100% que la <strong>VRAM est√° realmente vac√≠a</strong>. La CPU, por alguna raz√≥n que a√∫n no entendemos, no est√° copiando los datos del logo.
                </p>
                <p>
                    <strong>Siguiente Paso:</strong> Volver√≠amos a instrumentar la CPU para entender por qu√© su camino de ejecuci√≥n no llega a la rutina de copia de DMA/VRAM.
                </p>

                <h4>Resultado 2: La Pantalla Sigue en Blanco</h4>
                <p>
                    <strong>Significado:</strong> ¬°La tuber√≠a de datos est√° rota! La PPU C++ est√° generando el patr√≥n, pero este nunca llega a la pantalla.
                </p>
                <p>
                    <strong>Diagn√≥stico:</strong> El problema est√° en nuestro wrapper de Cython (<code>ppu.pyx</code>), espec√≠ficamente en c√≥mo exponemos el puntero del framebuffer y lo convertimos en un <code>memoryview</code>.
                </p>
                <p>
                    <strong>Siguiente Paso:</strong> Depurar√≠amos la interfaz de Cython, verificando:
                </p>
                <ul>
                    <li>Los punteros del framebuffer</li>
                    <li>Los tipos de datos del memoryview</li>
                    <li>El ciclo de vida del memoryview (si se est√° invalidando entre frames)</li>
                    <li>La sincronizaci√≥n entre la escritura en C++ y la lectura en Python</li>
                </ul>

                <h3>Validaci√≥n de m√≥dulo compilado C++</h3>
                <p>
                    El emulador utiliza el m√≥dulo C++ compilado (<code>viboy_core</code>), que contiene la implementaci√≥n modificada de <code>PPU::render_scanline()</code> con el test del checkerboard.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Documentaci√≥n de Cython: <a href="https://cython.readthedocs.io/">Memoryviews y Zero-Copy</a></li>
                    <li>Principios de depuraci√≥n de sistemas complejos: Aislamiento y pruebas de integraci√≥n</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Aislamiento de componentes:</strong> Cuando un sistema complejo falla, la mejor estrategia es aislar cada componente y probarlo individualmente.</li>
                        <li><strong>Validaci√≥n de la tuber√≠a de datos:</strong> En un sistema h√≠brido Python/C++, es cr√≠tico validar que los datos fluyen correctamente a trav√©s de las capas (C++ ‚Üí Cython ‚Üí Python).</li>
                        <li><strong>Patrones de depuraci√≥n:</strong> Un patr√≥n visual simple y determinista (como un checkerboard) es m√°s valioso para depuraci√≥n que un patr√≥n complejo que podr√≠a fallar por m√∫ltiples razones.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Estado de la tuber√≠a de datos:</strong> ¬øEl framebuffer de C++ est√° llegando correctamente a Python a trav√©s del memoryview de Cython?</li>
                        <li><strong>Si la tuber√≠a funciona:</strong> ¬øPor qu√© la CPU no est√° copiando los datos del logo a la VRAM?</li>
                        <li><strong>Si la tuber√≠a est√° rota:</strong> ¬øD√≥nde exactamente se rompe la conexi√≥n? ¬øEn el puntero, en el memoryview, o en la sincronizaci√≥n?</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis principal:</strong> El problema est√° en la tuber√≠a de datos entre C++ y Python. Aunque la PPU podr√≠a estar renderizando correctamente en su framebuffer interno, estos datos no est√°n llegando a la capa de Python.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> Si el test del checkerboard funciona, entonces sabemos que la tuber√≠a est√° bien y el problema est√° en la emulaci√≥n de la CPU/VRAM. Si no funciona, entonces sabemos que el problema est√° en el wrapper de Cython.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador con el test del checkerboard</li>
                    <li>[ ] Observar el resultado visual (checkerboard o pantalla blanca)</li>
                    <li>[ ] <strong>Si vemos checkerboard:</strong> Instrumentar la CPU para entender por qu√© no copia datos a VRAM</li>
                    <li>[ ] <strong>Si vemos pantalla blanca:</strong> Depurar el wrapper de Cython y el memoryview del framebuffer</li>
                    <li>[ ] Restaurar la l√≥gica original de <code>render_scanline()</code> una vez identificado el problema</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

