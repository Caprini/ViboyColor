<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perfilado de Rendimiento y Optimización: Eliminación de Logging y Fast-Path MMU - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Perfilado de Rendimiento y Optimización: Eliminación de Logging y Fast-Path MMU</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0082
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0081__configuracion-icono-aplicacion.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El emulador funcionaba correctamente pero con un rendimiento pobre (8-14 FPS) que lo hacía injugable.
                    Se creó un script de perfilado usando <code>cProfile</code> que identificó que el 42% del tiempo de ejecución
                    se gastaba en llamadas a <code>logger.debug()</code> aunque el nivel fuera CRITICAL. Se aplicaron optimizaciones
                    quirúrgicas: eliminación completa de logging en rutas críticas (hot paths), optimización del orden de verificación
                    en <code>MMU.read_byte()</code> (fast path para ROM primero), y uso de <code>__slots__</code> en la clase MMU.
                    Resultado: mejora del 30% en rendimiento, de 7.5 FPS a 9.7 FPS en modo headless, con 30% más ciclos ejecutados
                    en el mismo tiempo.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Profiling y Optimización de Rendimiento en Emuladores</strong>: Un emulador debe ejecutar millones de
                    instrucciones por segundo (la Game Boy funciona a 4.19 MHz). Cada operación que añade overhead innecesario,
                    por pequeña que sea, se multiplica millones de veces y puede causar problemas de rendimiento graves.
                </p>
                <p>
                    <strong>Hot Paths (Rutas Críticas)</strong>: Son las funciones que se ejecutan millones de veces por segundo:
                    <code>MMU.read_byte()</code> (acceso a memoria), <code>CPU.step()</code> (ejecución de instrucciones),
                    <code>CPU.fetch_byte()</code> (lectura de opcodes), y <code>PPU.step()</code> (avance del motor de gráficos).
                    Cualquier overhead en estas funciones tiene un impacto exponencial.
                </p>
                <p>
                    <strong>Overhead de Logging</strong>: Aunque el logger esté configurado en nivel CRITICAL, Python aún debe:
                    1) Preparar la llamada a <code>logger.debug()</code>, 2) Evaluar los argumentos (f-strings crean strings nuevos),
                    3) Llamar a la función, 4) Verificar el nivel internamente, 5) Descartar el resultado. Hacer esto 2.8 millones
                    de veces por segundo consume recursos significativos.
                </p>
                <p>
                    <strong>Fast Path Optimization</strong>: En <code>MMU.read_byte()</code>, el acceso más frecuente es leer ROM
                    (fetch de instrucciones desde 0x0000-0x7FFF). Reordenar los <code>if/elif</code> para verificar ROM primero
                    reduce el número promedio de comparaciones por acceso, mejorando el rendimiento.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se creó un script de perfilado (<code>tools/profile_viboy.py</code>) que ejecuta el emulador en modo headless
                    durante 10 segundos y analiza el tiempo consumido por cada función usando <code>cProfile</code> y <code>pstats</code>.
                </p>
                
                <h3>Resultados del Perfilado Inicial</h3>
                <p>
                    El perfilado reveló que el 42% del tiempo total se gastaba en logging:
                </p>
                <ul>
                    <li><code>logging.debug()</code>: 1,314,522 llamadas → 1.797 segundos</li>
                    <li><code>logging.isEnabledFor()</code>: 1,314,522 llamadas → 1.411 segundos</li>
                    <li><code>logging._is_disabled()</code>: 1,314,522 llamadas → 1.016 segundos</li>
                    <li><strong>Total: ~4.2 segundos de 10 segundos (42%)</strong></li>
                </ul>
                <p>
                    El rendimiento inicial era de <strong>7.5 FPS teóricos</strong> (131,585 M-Cycles/segundo),
                    muy por debajo del objetivo de 60 FPS.
                </p>

                <h3>Optimizaciones Aplicadas</h3>
                
                <h4>1. Eliminación de Logging en Hot Paths</h4>
                <ul>
                    <li><strong>MMU</strong>: Desactivado logging a nivel CRITICAL en <code>src/memory/mmu.py</code></li>
                    <li><strong>CPU</strong>: Desactivado logging a nivel CRITICAL en <code>src/cpu/core.py</code></li>
                    <li><strong>Comentadas llamadas críticas</strong> en <code>CPU.step()</code>, <code>CPU.handle_interrupts()</code>,
                        y funciones de stack (<code>_push_byte</code>, <code>_pop_byte</code>, <code>_push_word</code>, <code>_pop_word</code>)</li>
                    <li><strong>Comentadas llamadas en handlers dinámicos</strong> dentro de <code>_init_ld_handler_lazy()</code></li>
                </ul>

                <h4>2. Optimización Fast-Path en MMU.read_byte()</h4>
                <ul>
                    <li><strong>Reordenado if/elif</strong> para verificar ROM primero (<code>addr <= 0x7FFF</code>)</li>
                    <li><strong>Agrupado acceso a WRAM/HRAM</strong> (0xC000-0xFFFF) con verificaciones de I/O específicas</li>
                    <li><strong>VRAM al final</strong> (0x8000-0xFEFF) como menos frecuente</li>
                    <li>Reducción del número promedio de comparaciones por acceso de memoria</li>
                </ul>

                <h4>3. Optimización con __slots__</h4>
                <ul>
                    <li>Añadido <code>__slots__ = ['_memory', '_cartridge', '_ppu', '_joypad', '_timer', 'vram_write_count']</code>
                        a la clase <code>MMU</code></li>
                    <li>Reduce el overhead de acceso a atributos al eliminar el diccionario de instancia</li>
                    <li>Mejora el uso de memoria y la velocidad de acceso</li>
                </ul>

                <h3>Resultados Finales</h3>
                <p>
                    Después de las optimizaciones:
                </p>
                <ul>
                    <li><strong>FPS teórico</strong>: 7.5 → 9.7 FPS (<strong>29% mejora</strong>)</li>
                    <li><strong>M-Cycles ejecutados</strong>: 1,315,852 → 1,710,334 (<strong>30% más ciclos</strong> en el mismo tiempo)</li>
                    <li><strong>Tiempo en logging</strong>: 4.2s → 1.9s (<strong>55% reducción</strong>)</li>
                    <li><strong>T-Cycles/segundo</strong>: 526,340 → 684,133 (<strong>30% mejora</strong>)</li>
                </ul>
                <p>
                    Nota: Aún quedan ~529k llamadas a <code>logger.debug()</code> activas, pero el tiempo consumido se redujo
                    significativamente al desactivar el logger a nivel CRITICAL. Para eliminarlas completamente sería necesario
                    comentar todas las llamadas o usar verificaciones condicionales, pero añadirían overhead.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>tools/profile_viboy.py</code> (nuevo) - Script de perfilado usando cProfile y pstats</li>
                    <li><code>src/memory/mmu.py</code> (modificado) - Añadido __slots__, optimizado read_byte() con fast path, desactivado logging</li>
                    <li><code>src/cpu/core.py</code> (modificado) - Desactivado logging a nivel CRITICAL, comentadas llamadas críticas</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se utilizó perfilado científico con <code>cProfile</code> para identificar y verificar las optimizaciones:
                </p>
                
                <h3>Perfilado Inicial (Antes de Optimizaciones)</h3>
                <p><strong>Comando ejecutado:</strong></p>
                <pre><code>python tools/profile_viboy.py</code></pre>
                <p><strong>Entorno:</strong> Windows / Python 3.13.5</p>
                <p><strong>Resultado:</strong></p>
                <ul>
                    <li>FPS teórico: <strong>7.5 FPS</strong></li>
                    <li>M-Cycles ejecutados: 1,315,852</li>
                    <li>Tiempo en logging: ~4.2 segundos (42% del tiempo total)</li>
                    <li>Top función: <code>MMU.read_byte()</code> con 2,844,148 llamadas (1.282s)</li>
                </ul>
                
                <h3>Perfilado Final (Después de Optimizaciones)</h3>
                <p><strong>Comando ejecutado:</strong></p>
                <pre><code>python tools/profile_viboy.py</code></pre>
                <p><strong>Entorno:</strong> Windows / Python 3.13.5</p>
                <p><strong>Resultado:</strong></p>
                <ul>
                    <li>FPS teórico: <strong>9.7 FPS</strong> (29% mejora)</li>
                    <li>M-Cycles ejecutados: 1,710,334 (30% más ciclos)</li>
                    <li>Tiempo en logging: ~1.9 segundos (19% del tiempo total, 55% reducción)</li>
                    <li>Top función: <code>MMU.read_byte()</code> con 3,695,025 llamadas (1.152s) - más eficiente</li>
                </ul>
                
                <h3>Qué Valida el Perfilado</h3>
                <ul>
                    <li><strong>Identificación de cuellos de botella</strong>: El perfilado muestra exactamente qué funciones consumen más tiempo</li>
                    <li><strong>Medición de mejoras</strong>: Permite cuantificar el impacto de cada optimización</li>
                    <li><strong>Verificación de eficiencia</strong>: Confirma que las optimizaciones realmente mejoran el rendimiento</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li><strong>Python cProfile Documentation</strong>: <a href="https://docs.python.org/3/library/profile.html">https://docs.python.org/3/library/profile.html</a></li>
                    <li><strong>Python __slots__</strong>: Optimización de memoria y acceso a atributos en clases</li>
                    <li><strong>Clean Code Principles</strong>: Optimización de hot paths en código de alto rendimiento</li>
                </ul>
                <p>
                    <em>Nota: La optimización se basa en principios generales de profiling y optimización de código Python,
                    aplicados específicamente a las necesidades de un emulador de Game Boy.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Profiling científico</strong>: Usar herramientas como <code>cProfile</code> es esencial antes de optimizar.
                            Optimizar sin datos es "dar palos de ciego".</li>
                        <li><strong>Impacto exponencial de overhead</strong>: Un overhead pequeño (como una llamada a logging) se multiplica
                            millones de veces en un emulador, causando problemas graves de rendimiento.</li>
                        <li><strong>Fast paths</strong>: Reordenar verificaciones para poner lo más frecuente primero puede tener un impacto
                            significativo cuando se ejecuta millones de veces.</li>
                        <li><strong>Logging en producción</strong>: El logging debe desactivarse completamente en código de alto rendimiento,
                            no solo configurarse a nivel alto. Las verificaciones internas de nivel tienen overhead.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Rendimiento en tiempo real con renderizado</strong>: El perfilado se hizo en modo headless.
                            Falta verificar el FPS real con renderizado gráfico activo.</li>
                        <li><strong>Eliminación completa de logging</strong>: Aún quedan ~529k llamadas a <code>logger.debug()</code> activas.
                            Sería interesante medir el impacto de eliminarlas completamente (comentándolas todas).</li>
                        <li><strong>Otras optimizaciones posibles</strong>: El perfilado muestra que <code>MMU.read_byte()</code> sigue siendo
                            la función más llamada. Podrían explorarse optimizaciones adicionales como cacheo o lookup tables.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        Se asume que el orden de verificación en <code>MMU.read_byte()</code> (ROM primero) es óptimo basándose en
                        el hecho de que el fetch de instrucciones es la operación más frecuente. Sin embargo, esto podría variar
                        según el juego o la fase de ejecución. Un perfilado más detallado por fase podría revelar patrones diferentes.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Verificar rendimiento en tiempo real con renderizado gráfico activo</li>
                    <li>[ ] Probar el emulador con diferentes ROMs para validar que las optimizaciones no introducen bugs</li>
                    <li>[ ] Explorar optimizaciones adicionales en <code>MMU.read_byte()</code> si el rendimiento aún no es suficiente</li>
                    <li>[ ] Considerar eliminar completamente las llamadas a <code>logger.debug()</code> restantes si es necesario</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

