<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arquitectura de Precisión y Soporte CGB Básico (v0.0.1) - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Arquitectura de Precisión y Soporte CGB Básico (v0.0.1)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0087
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0086__tile-caching-optimizacion-renderizado.html">Anterior</a></li>
                    <li><a href="2025-12-18__0088__arquitectura-scanlines-rendimiento.html">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se realizó una revisión integral de la arquitectura del emulador para la versión 0.0.1, eliminando
                    el batching de ciclos que causaba desincronización entre CPU, Timer y PPU. Se implementó soporte
                    CGB básico (VRAM banking, paletas de color, speed switch) y se corrigió el boot state con valores
                    exactos de hardware CGB. El bucle principal ahora ejecuta instrucciones ciclo a ciclo con
                    sincronización perfecta, manteniendo 60 FPS gracias al Tile Caching implementado previamente.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Precisión de Timing en Emulación:</strong> La Game Boy funciona a 4.19 MHz, ejecutando
                    millones de instrucciones por segundo. Cada componente (CPU, Timer, PPU) debe avanzar de forma
                    sincronizada. El Timer (registro DIV) se usa como fuente de aleatoriedad (RNG) en muchos juegos.
                    Si el Timer no se actualiza con precisión ciclo a ciclo, el juego puede leer el mismo valor
                    múltiples veces, generando piezas "basura" o colisiones fantasmas que provocan Game Over aleatorio.
                </p>
                <p>
                    <strong>Batching vs Precisión:</strong> Agrupar múltiples instrucciones (batching) reduce llamadas
                    a función y mejora el rendimiento, pero rompe la causalidad del sistema. Si ejecutamos 128 ciclos
                    de CPU antes de actualizar el Timer, el juego puede leer DIV varias veces con el mismo valor,
                    causando comportamientos erróneos. La solución es ejecutar instrucciones una a una, actualizando
                    periféricos inmediatamente después de cada instrucción.
                </p>
                <p>
                    <strong>Game Boy Color (CGB):</strong> La CGB añade características avanzadas sobre la DMG:
                    VRAM Banking (2 bancos de 8KB), paletas de color RGB555 (8 paletas de 4 colores para fondo y sprites),
                    y speed switch (velocidad doble). Los juegos Dual Mode (CGB/DMG) detectan el hardware leyendo el
                    registro A al inicio: A=0x01 (DMG), A=0x11 (CGB). Si detectan CGB, intentan usar estas características.
                    Sin soporte básico, el juego puede bloquearse esperando hardware que no existe.
                </p>
                <p>
                    <strong>Boot State:</strong> La Boot ROM deja los registros con valores específicos al saltar
                    al código del cartucho (PC=0x0100). Estos valores afectan el RNG inicial y el comportamiento del
                    juego. Los valores exactos son críticos para compatibilidad.
                </p>
                <p>
                    Fuente: Pan Docs - System Clock, Timing, CGB Registers, Boot ROM, Post-Boot State
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementaron tres cambios principales para estabilizar la arquitectura:
                </p>
                
                <h3>1. Soporte CGB Básico en MMU</h3>
                <ul>
                    <li><strong>VRAM Banking (0xFF4F):</strong> Implementado sistema de 2 bancos de VRAM (8KB cada uno).
                        El bit 0 de 0xFF4F selecciona el banco activo. Las lecturas/escrituras en 0x8000-0x9FFF usan
                        el banco seleccionado. Banco 0 se mapea a memoria principal para compatibilidad DMG.</li>
                    <li><strong>Paletas CGB (0xFF68-0xFF6B):</strong> Implementado sistema de paletas RGB555 con
                        auto-incremento. BCPS/BCPD para paleta de fondo (8 paletas * 4 colores * 2 bytes = 64 bytes).
                        OCPS/OCPD para paleta de sprites (mismo tamaño). El bit 7 de BCPS/OCPS activa auto-incremento.</li>
                    <li><strong>Speed Switch (0xFF4D):</strong> Implementado registro básico que guarda el estado de
                        velocidad (bit 0: 0=normal, 1=doble). El cambio real requiere una secuencia especial no
                        implementada aún, pero el registro permite que el juego escriba sin bloquearse.</li>
                </ul>

                <h3>2. Boot State CGB Exacto</h3>
                <ul>
                    <li><strong>Valores exactos:</strong> AF=0x1180 (A=0x11 indica CGB, F=0x80 con Z flag activo),
                        BC=0x0000, DE=0xFF56, HL=0x000D, SP=0xFFFE, PC=0x0100.</li>
                    <li><strong>Compatibilidad:</strong> Estos valores permiten que juegos Dual Mode detecten CGB
                        y usen características avanzadas sin bloquearse.</li>
                </ul>

                <h3>3. Bucle Principal de Precisión</h3>
                <ul>
                    <li><strong>Eliminado batching:</strong> El método <code>run()</code> ahora ejecuta instrucciones
                        una a una usando <code>tick()</code>, que actualiza PPU y Timer inmediatamente después de cada
                        instrucción.</li>
                    <li><strong>Sincronización perfecta:</strong> CPU, Timer y PPU avanzan juntos con los ciclos exactos
                        de cada instrucción, garantizando que DIV se actualice correctamente y el RNG funcione.</li>
                    <li><strong>Input polling frecuente:</strong> Los eventos de pygame se procesan cada vez que hay
                        frame listo, reduciendo input lag.</li>
                    <li><strong>Rendimiento:</strong> A pesar de más llamadas a función, el Tile Caching mantiene
                        60 FPS estables.</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    <strong>1. VRAM Banking:</strong> Se usa un array de 2 bytearrays para los bancos. El banco 0 se
                    mapea también a memoria principal para compatibilidad DMG. El banco 1 solo existe en el array
                    secundario. Esto permite que juegos DMG funcionen sin cambios y juegos CGB puedan usar el banco
                    adicional.
                </p>
                <p>
                    <strong>2. Paletas CGB:</strong> Se almacenan como bytearrays de 64 bytes cada una. Aunque el
                    renderer aún no usa estas paletas (renderiza en B/N), el juego puede escribir en ellas sin
                    bloquearse. En el futuro, el renderer podrá leer estas paletas para renderizar en color.
                </p>
                <p>
                    <strong>3. Precisión sobre velocidad:</strong> Se priorizó la precisión de timing sobre la velocidad
                    bruta. El Tile Caching compensa el overhead de más llamadas a función, permitiendo mantener 60 FPS
                    con precisión ciclo a ciclo.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/memory/mmu.py</code> - Soporte CGB: añadidas constantes IO_VBK, IO_KEY1, IO_BCPS, IO_BCPD, IO_OCPS, IO_OCPD. Implementado VRAM banking con 2 bancos, paletas CGB con auto-incremento, y speed switch. Modificado read_byte() y write_byte() para manejar estos registros y VRAM banking.</li>
                    <li><code>src/viboy.py</code> - Boot state CGB: modificado _initialize_post_boot_state() para usar valores exactos CGB (AF=0x1180, BC=0x0000, DE=0xFF56, HL=0x000D). Bucle principal: reescrito run() eliminando batching, ejecutando instrucciones ciclo a ciclo con tick() para sincronización perfecta.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Validación de precisión:</strong>
                </p>
                <ul>
                    <li><strong>Comando ejecutado:</strong> <code>python main.py tetris.gb</code></li>
                    <li><strong>Entorno:</strong> Windows / Python 3.10+</li>
                    <li><strong>Resultado:</strong> Tetris funciona correctamente sin Game Over aleatorio. Las piezas
                        giran y caen correctamente, el RNG funciona (piezas aparecen aleatoriamente), y los controles
                        responden sin lag.</li>
                    <li><strong>Qué valida:</strong> La sincronización perfecta entre CPU y Timer garantiza que DIV
                        se actualiza correctamente, permitiendo que el RNG funcione. El input polling frecuente
                        reduce el lag de controles.</li>
                </ul>
                <p>
                    <strong>Validación de soporte CGB:</strong>
                </p>
                <ul>
                    <li><strong>Comando ejecutado:</strong> <code>python main.py pkmn.gb</code></li>
                    <li><strong>Entorno:</strong> Windows / Python 3.10+</li>
                    <li><strong>Resultado:</strong> Pokémon Red pasa del logo y no se bloquea esperando registros CGB.
                        El juego detecta CGB (A=0x11) y puede escribir en registros CGB sin errores.</li>
                    <li><strong>Qué valida:</strong> El boot state CGB correcto y los registros CGB implementados
                        permiten que juegos Dual Mode funcionen sin bloquearse.</li>
                </ul>
                <p>
                    <strong>Validación de rendimiento:</strong>
                </p>
                <ul>
                    <li><strong>FPS:</strong> 60 FPS estables con precisión ciclo a ciclo (Tile Caching compensa el
                        overhead de más llamadas a función).</li>
                    <li><strong>Jugabilidad:</strong> Tetris es completamente jugable sin problemas de timing o RNG.</li>
                </ul>
                <p>
                    <strong>ROMs de test:</strong>
                </p>
                <ul>
                    <li><strong>Tetris (ROM aportada por el usuario, no distribuida):</strong> Verificado que funciona
                        correctamente sin Game Over aleatorio, RNG funciona, controles responden sin lag.</li>
                    <li><strong>Pokémon Red (ROM aportada por el usuario, no distribuida):</strong> Verificado que
                        pasa del logo y no se bloquea esperando registros CGB.</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">https://gbdev.io/pandocs/</a> - System Clock, Timing, CGB Registers, VRAM Banking, Color Palettes, Boot ROM, Post-Boot State</li>
                    <li>Pan Docs - CGB Registers: VRAM Banking (0xFF4F), Speed Switch (0xFF4D), Background Color Palette (0xFF68-0xFF69), Object Color Palette (0xFF6A-0xFF6B)</li>
                    <li>Pan Docs - Boot ROM: Valores exactos de registros post-boot para CGB (AF=0x1180, BC=0x0000, DE=0xFF56, HL=0x000D)</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Precisión de Timing:</strong> La sincronización ciclo a ciclo es crítica para
                            juegos que usan DIV como RNG. El batching rompe esta sincronización, causando comportamientos
                            erróneos. La solución es ejecutar instrucciones una a una, actualizando periféricos inmediatamente.</li>
                        <li><strong>CGB Básico:</strong> Los juegos Dual Mode detectan CGB leyendo A=0x11. Necesitan
                            poder escribir en registros CGB sin bloquearse, aunque el renderer aún no use estas
                            características. Implementar stubs funcionales es suficiente para compatibilidad básica.</li>
                        <li><strong>Boot State:</strong> Los valores exactos de registros al inicio afectan el RNG
                            y el comportamiento del juego. Usar valores CGB exactos permite compatibilidad máxima con
                            juegos Dual Mode.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Speed Switch:</strong> El cambio real de velocidad requiere una secuencia especial
                            no implementada aún. Por ahora, solo se guarda el valor. Pendiente de implementar la
                            lógica completa de cambio de velocidad.</li>
                        <li><strong>Renderizado en Color:</strong> Las paletas CGB están implementadas pero el renderer
                            aún no las usa. Pendiente de implementar renderizado RGB555 usando estas paletas.</li>
                        <li><strong>VRAM Banking Completo:</strong> El banco 1 de VRAM está implementado pero el renderer
                            solo lee del banco 0. Pendiente de implementar renderizado desde el banco seleccionado.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Rendimiento con precisión ciclo a ciclo:</strong> Se asumió que el Tile Caching compensaría
                        el overhead de más llamadas a función. Esto se validó exitosamente: 60 FPS se mantienen estables.
                    </p>
                    <p>
                        <strong>Compatibilidad CGB:</strong> Se asumió que implementar stubs funcionales para registros CGB
                        sería suficiente para que juegos Dual Mode no se bloqueen. Esto se validó exitosamente: Pokémon Red
                        pasa del logo sin bloquearse.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Implementar renderizado en color usando paletas CGB (RGB555)</li>
                    <li>[ ] Implementar renderizado desde VRAM Bank 1 cuando esté seleccionado</li>
                    <li>[ ] Implementar lógica completa de Speed Switch (cambio de velocidad doble)</li>
                    <li>[ ] Validar con más ROMs CGB para asegurar compatibilidad</li>
                    <li>[ ] Optimizar rendimiento si es necesario (profiling adicional)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

