<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Instrumentar Default Case para Capturar Opcodes Desconocidos - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Instrumentar Default Case para Capturar Opcodes Desconocidos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0168
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0167__fix-propiedades-cython-tests-interrupciones.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se modific贸 el caso <code>default</code> en el m茅todo <code>CPU::step()</code> para implementar una estrategia "fail-fast" que termina la ejecuci贸n inmediatamente cuando se encuentra un opcode no implementado, en lugar de devolver 0 ciclos y causar un deadlock silencioso. Esto permite identificar r谩pidamente qu茅 opcodes faltan implementar al mostrar un mensaje de error fatal con el opcode y el PC exactos donde ocurre el problema.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: Depuraci贸n "Fail-Fast"</h2>
                <p>
                    En el desarrollo de emuladores, es una pr谩ctica est谩ndar hacer que el n煤cleo falle de manera ruidosa y temprana cuando encuentra una condici贸n inesperada, como un opcode desconocido. En lugar de permitir que el emulador contin煤e en un estado indefinido (como nuestro deadlock de <code>LY=0</code>), lo forzamos a detenerse inmediatamente, mostr谩ndonos la causa exacta del problema.
                </p>
                <p>
                    La estrategia "fail-fast" acelera dr谩sticamente el ciclo de depuraci贸n porque:
                </p>
                <ul>
                    <li><strong>Identificaci贸n Inmediata:</strong> El programa termina en el momento exacto en que encuentra el problema, no despu茅s de ejecutar miles de instrucciones en un estado corrupto.</li>
                    <li><strong>Informaci贸n Precisa:</strong> Reporta el opcode exacto y la direcci贸n de memoria (PC) donde ocurre el fallo, permitiendo una investigaci贸n directa y eficiente.</li>
                    <li><strong>Evita Estados Indefinidos:</strong> Previene que el emulador entre en bucles infinitos o estados corruptos que son dif铆ciles de depurar retrospectivamente.</li>
                </ul>
                <p>
                    En nuestro caso espec铆fico, el deadlock de <code>LY=0</code> persist铆a porque <code>cpu.step()</code> estaba devolviendo 0 ciclos repetidamente cuando encontraba un opcode no implementado. Al cambiar a fail-fast, el emulador se detendr谩 inmediatamente y nos mostrar谩 qu茅 opcode falta, permiti茅ndonos implementarlo y continuar con la emulaci贸n.
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se modific贸 el caso <code>default</code> en el m茅todo <code>CPU::step()</code> en <code>src/core/cpp/CPU.cpp</code> para que, en lugar de imprimir un warning y devolver 0 ciclos, imprima un mensaje fatal y termine la ejecuci贸n con <code>exit(1)</code>.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code>: Modificado el caso <code>default</code> del switch de opcodes para implementar fail-fast.</li>
                </ul>

                <h3>Cambios realizados</h3>
                <p>
                    El c贸digo anterior solo imprim铆a un warning y devolv铆a 0 ciclos:
                </p>
                <pre><code>default:
    printf("[CPU WARN] Opcode no implementado: 0x%02X en PC: 0x%04X. Devolviendo 0 ciclos.\n", opcode, current_pc);
    return 0;
</code></pre>
                <p>
                    El nuevo c贸digo implementa fail-fast:
                </p>
                <pre><code>default:
    // --- Instrumentaci贸n del Step 0168 ---
    // Fail-fast: Si encontramos un opcode desconocido, lo reportamos
    // y terminamos la ejecuci贸n inmediatamente. Esto es mucho mejor que
    // devolver 0 ciclos y causar un deadlock silencioso.
    printf("[CPU FATAL] Unimplemented opcode: 0x%02X at PC: 0x%04X\n", opcode, current_pc);
    exit(1); // Termina el programa con un c贸digo de error.
    return 0; // No se alcanzar谩, pero mantiene la l贸gica del compilador.
</code></pre>

                <h3>Decisiones de dise帽o</h3>
                <p>
                    Se decidi贸 usar <code>exit(1)</code> en lugar de lanzar una excepci贸n C++ porque:
                </p>
                <ul>
                    <li><strong>Simplicidad:</strong> En esta fase de desarrollo, queremos un fallo inmediato y visible, no manejo de excepciones complejo.</li>
                    <li><strong>Claridad:</strong> El mensaje de error se imprime directamente en la consola, facilitando la depuraci贸n.</li>
                    <li><strong>Eficiencia:</strong> No hay overhead de manejo de excepciones en el c贸digo cr铆tico de ejecuci贸n.</li>
                </ul>
                <p>
                    En el futuro, cuando el n煤cleo est茅 m谩s completo, podr铆amos considerar cambiar esto a un sistema de logging m谩s sofisticado o excepciones, pero para identificar opcodes faltantes durante el desarrollo, fail-fast es la estrategia 贸ptima.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Modificado el caso <code>default</code> para implementar fail-fast</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    Esta modificaci贸n no requiere tests unitarios espec铆ficos porque es una herramienta de depuraci贸n que se activar谩 cuando se ejecute el emulador con una ROM real. La verificaci贸n se realiza ejecutando el emulador:
                </p>
                <pre><code>python main.py roms/tetris.gb</code></pre>
                <p>
                    <strong>Resultado esperado:</strong> El emulador debe terminar inmediatamente (sin mostrar el bucle de heartbeat) y mostrar un mensaje de error fatal en la consola con el formato:
                </p>
                <pre><code>[CPU FATAL] Unimplemented opcode: 0xXX at PC: 0xXXXX</code></pre>
                <p>
                    Este mensaje identificar谩 exactamente qu茅 opcode falta implementar y en qu茅 direcci贸n de memoria se encuentra, permitiendo una correcci贸n r谩pida y precisa.
                </p>
                <p>
                    <strong>Validaci贸n de m贸dulo compilado C++:</strong> El m贸dulo debe recompilarse exitosamente. El archivo <code>cstdlib</code> ya estaba incluido en el archivo, por lo que no se necesitan includes adicionales.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pr谩ctica de desarrollo de software: Estrategia "Fail-Fast" para depuraci贸n temprana</li>
                    <li>Pan Docs: CPU Instruction Set - Referencia para implementar opcodes faltantes una vez identificados</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Fail-Fast en Emulaci贸n:</strong> Es mejor hacer que el emulador falle inmediatamente con informaci贸n precisa que permitir que contin煤e en un estado indefinido, especialmente durante el desarrollo.</li>
                        <li><strong>Deadlock Silencioso:</strong> Devolver 0 ciclos cuando se encuentra un opcode desconocido puede causar que el tiempo emulado no avance, creando un deadlock dif铆cil de depurar. Fail-fast evita este problema completamente.</li>
                        <li><strong>Instrumentaci贸n de Debug:</strong> Agregar c贸digo espec铆fico de depuraci贸n (como mensajes de error fatal) en puntos cr铆ticos del c贸digo ayuda a identificar problemas r谩pidamente.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li>Qu茅 opcode espec铆fico est谩 causando el deadlock - esto se determinar谩 cuando se ejecute el emulador con la nueva instrumentaci贸n.</li>
                        <li>Si hay m煤ltiples opcodes faltantes o solo uno que bloquea la ejecuci贸n temprana.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis principal:</strong> Hay al menos un opcode no implementado que se ejecuta durante la inicializaci贸n de la ROM (antes de llegar a <code>PC=0x0300</code>), causando que <code>cpu.step()</code> devuelva 0 ciclos y el emulador entre en deadlock.
                    </p>
                    <p>
                        <strong>Suposici贸n:</strong> Una vez identificado el opcode faltante, implementarlo deber铆a permitir que la emulaci贸n avance hasta el siguiente opcode faltante (si existe) o hasta que se complete la inicializaci贸n y comience el renderizado.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m贸dulo C++ con la nueva instrumentaci贸n</li>
                    <li>[ ] Ejecutar el emulador con una ROM para identificar el opcode faltante</li>
                    <li>[ ] Implementar el opcode identificado seg煤n Pan Docs</li>
                    <li>[ ] Repetir el proceso hasta que la emulaci贸n avance correctamente</li>
                    <li>[ ] Una vez que el emulador avance, considerar cambiar de fail-fast a un sistema de logging m谩s sofisticado para producci贸n</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

