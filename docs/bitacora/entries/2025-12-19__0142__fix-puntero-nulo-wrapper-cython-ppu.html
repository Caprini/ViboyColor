<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix: Corregir Creación de PPU en Wrapper Cython para Resolver Puntero Nulo - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Fix: Corregir Creación de PPU en Wrapper Cython para Resolver Puntero Nulo</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0142
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">✅ VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0141__debug-verificacion-puntero-nulo-ppu.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El diagnóstico del Step 0141 reveló que el <code>Segmentation Fault</code> ocurría <strong>antes</strong> de que se ejecutara cualquier código dentro de <code>render_scanline()</code>, lo que confirmó que el problema estaba en el wrapper de Cython: el puntero al objeto PPU de C++ era nulo (<code>nullptr</code>). Se corrigió el constructor <code>__cinit__</code> de <code>PyPPU</code> en <code>ppu.pyx</code> añadiendo logs de diagnóstico, verificaciones robustas y manejo de errores explícito para asegurar que la instancia de PPU en C++ se crea correctamente.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En un emulador híbrido Python/C++, la creación de objetos C++ desde Python requiere un "wrapper" de Cython que actúa como puente entre ambos mundos. El wrapper de Cython mantiene un puntero C++ crudo (<code>cdef PPU* _ppu</code>) que apunta a la instancia real del objeto en memoria C++.
                </p>
                <p>
                    Cuando Python llama a un método del wrapper (ej: <code>ppu.step()</code>), Cython traduce la llamada a una invocación directa del método C++ (ej: <code>self._ppu.step()</code>). Si el puntero <code>_ppu</code> es <code>NULL</code> (nulo), intentar llamar a un método en un puntero nulo causa un <code>Segmentation Fault</code> inmediato, <strong>antes</strong> de que cualquier código dentro del método C++ pueda ejecutarse.
                </p>
                <p>
                    El constructor de Cython (<code>__cinit__</code>) es responsable de crear la instancia C++ usando <code>new PPU(...)</code> y asignar el puntero resultante a <code>self._ppu</code>. Si este proceso falla silenciosamente o no se ejecuta correctamente, el puntero queda en <code>NULL</code> y todas las llamadas posteriores fallarán con un crash.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se corrigió el constructor <code>__cinit__</code> de <code>PyPPU</code> en <code>src/core/cython/ppu.pyx</code> para asegurar la creación correcta de la instancia C++ y añadir capas de seguridad que prevengan futuros crashes silenciosos.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>src/core/cython/ppu.pyx</strong>: Constructor <code>__cinit__</code> mejorado con logs de diagnóstico y verificaciones robustas</li>
                    <li><strong>src/core/cython/ppu.pyx</strong>: Destructor <code>__dealloc__</code> mejorado con logs y asignación explícita de <code>NULL</code></li>
                </ul>

                <h3>Cambios aplicados</h3>
                <p>
                    <strong>1. Constructor <code>__cinit__</code> mejorado:</strong>
                </p>
                <ul>
                    <li>Añadidos logs de diagnóstico con <code>print()</code> para rastrear la creación del objeto</li>
                    <li>Verificación explícita de que <code>mmu_wrapper</code> no sea <code>None</code></li>
                    <li>Extracción explícita del puntero C++ crudo desde el wrapper de MMU: <code>cdef mmu.MMU* mmu_ptr = (&lt;PyMMU&gt;mmu_wrapper)._mmu</code></li>
                    <li>Verificación de que el puntero de MMU no sea nulo antes de crear la PPU</li>
                    <li>Verificación explícita después de <code>new PPU(mmu_ptr)</code> para asegurar que la asignación fue exitosa</li>
                    <li>Lanzamiento de excepciones descriptivas (<code>ValueError</code>, <code>MemoryError</code>) si algo falla</li>
                </ul>

                <p>
                    <strong>2. Destructor <code>__dealloc__</code> mejorado:</strong>
                </p>
                <ul>
                    <li>Añadidos logs de diagnóstico para rastrear la liberación del objeto</li>
                    <li>Asignación explícita de <code>NULL</code> después de liberar el objeto para evitar punteros colgantes</li>
                </ul>

                <h3>Código clave</h3>
                <pre><code>def __cinit__(self, PyMMU mmu_wrapper):
    print("[PyPPU __cinit__] Creando instancia de PPU en C++...")
    
    # Verificar que mmu_wrapper no sea None
    if mmu_wrapper is None:
        raise ValueError("PyPPU: mmu_wrapper no puede ser None")
    
    # Extrae el puntero C++ crudo desde el wrapper de la MMU
    cdef mmu.MMU* mmu_ptr = (&lt;PyMMU&gt;mmu_wrapper)._mmu
    
    # Comprobación de seguridad: Asegurarse de que el puntero de la MMU no es nulo
    if mmu_ptr == NULL:
        raise ValueError("Se intentó crear PyPPU con un wrapper de MMU inválido (puntero nulo).")
    
    # --- LÍNEA CRÍTICA ---
    # Crea la instancia de PPU en C++ y asigna el puntero
    self._ppu = new ppu.PPU(mmu_ptr)
    
    # Comprobación de seguridad: Asegurarse de que la creación fue exitosa
    if self._ppu == NULL:
        raise MemoryError("Falló la asignación de memoria para la PPU en C++.")
    
    print("[PyPPU __cinit__] Instancia de PPU en C++ creada exitosamente.")</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cython/ppu.pyx</code> - Constructor y destructor mejorados con logs y verificaciones robustas</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Validación del diagnóstico (Step 0141):</strong>
                </p>
                <ul>
                    <li>El hecho de que el mensaje <code>printf</code> del Step 0141 nunca se ejecutara confirmó que el crash ocurría en la llamada al método mismo, no dentro de él.</li>
                    <li>Esto indicó definitivamente que el puntero <code>self._ppu</code> en el wrapper de Cython era nulo.</li>
                </ul>
                <p>
                    <strong>Próxima verificación (pendiente de recompilación):</strong>
                </p>
                <ul>
                    <li>Recompilar el módulo C++: <code>.\rebuild_cpp.ps1</code></li>
                    <li>Ejecutar el emulador: <code>python main.py roms/tetris.gb</code></li>
                    <li>Verificar que los logs de diagnóstico aparecen: <code>[PyPPU __cinit__] Creando instancia de PPU en C++...</code></li>
                    <li>Verificar que el <code>Segmentation Fault</code> ha desaparecido</li>
                    <li>Verificar que el renderizado funciona correctamente</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Cython Documentation: <a href="https://cython.readthedocs.io/">https://cython.readthedocs.io/</a> - Gestión de memoria y punteros en Cython</li>
                    <li>Cython Best Practices: Constructores y destructores con objetos C++</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Punteros nulos en Cython:</strong> Cuando un puntero C++ en un wrapper de Cython es nulo, cualquier intento de llamar a un método en ese puntero causa un <code>Segmentation Fault</code> inmediato, antes de que el código dentro del método pueda ejecutarse.</li>
                        <li><strong>Diagnóstico mediante ausencia de logs:</strong> Si un <code>printf</code> al inicio de un método nunca se ejecuta, significa que el crash ocurre en la invocación del método mismo, no dentro de él.</li>
                        <li><strong>Constructor de Cython:</strong> El método <code>__cinit__</code> es crítico para la creación correcta de objetos C++. Debe verificar explícitamente que <code>new</code> fue exitoso y que el puntero resultante no es nulo.</li>
                        <li><strong>Gestión de memoria:</strong> Es buena práctica asignar explícitamente <code>NULL</code> a un puntero después de liberarlo con <code>delete</code> para evitar punteros colgantes.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Verificación de ejecución:</strong> Confirmar que después de recompilar, el emulador ejecuta sin <code>Segmentation Fault</code> y que los logs de diagnóstico aparecen correctamente.</li>
                        <li><strong>Renderizado funcional:</strong> Verificar que el renderizado de la PPU funciona correctamente ahora que el puntero es válido.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis principal:</strong> El problema estaba en el constructor de Cython, donde la creación del objeto C++ no se estaba verificando correctamente. Con las verificaciones añadidas, el problema debería estar resuelto.
                    </p>
                    <p>
                        <strong>Suposición:</strong> El código anterior del constructor ya tenía la línea <code>self._ppu = new ppu.PPU(mmu._mmu)</code>, pero posiblemente había un problema sutil en cómo se accedía al puntero de MMU o en el orden de las operaciones. Las verificaciones explícitas añadidas deberían prevenir cualquier problema similar en el futuro.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el módulo C++ con <code>.\rebuild_cpp.ps1</code></li>
                    <li>[ ] Ejecutar el emulador y verificar que los logs de diagnóstico aparecen</li>
                    <li>[ ] Confirmar que el <code>Segmentation Fault</code> ha desaparecido</li>
                    <li>[ ] Verificar que el renderizado funciona correctamente</li>
                    <li>[ ] Si todo funciona, eliminar los logs de diagnóstico de producción (mantener solo en modo debug)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>
