<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0483: Evidencia Real Snapshots con Datos + Branch Blockers + JOYP Semantics</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Viboy Color - Bit√°cora de Desarrollo</h1>
            <nav>
                <a href="../index.html">‚Üê Volver al √≠ndice</a>
            </nav>
        </header>

        <article class="entry">
            <!-- Entrada 0483 - Evidencia Real Snapshots con Datos + Branch Blockers + JOYP Semantics -->
            <header class="entry-header">
                <h2>Step 0483: Evidencia Real Snapshots con Datos + Branch Blockers + JOYP Semantics</h2>
                <div class="entry-meta">
                    <strong>Fecha:</strong> 2026-01-05 | 
                    <strong>Step ID:</strong> 0483 | 
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </div>
            </header>

            <section class="entry-content">
                <h3>Resumen</h3>
                <p>
                    Este step implementa herramientas de diagn√≥stico avanzadas para proporcionar evidencia concreta de bloqueos en la ejecuci√≥n de ROMs espec√≠ficas:
                </p>
                <ol>
                    <li><strong>Fase A</strong>: Snapshots con datos reales (no placeholders)</li>
                    <li><strong>Fase B</strong>: Exec Coverage + Branch Blockers + Last Load A Tracking</li>
                    <li><strong>Fase C</strong>: HRAM FF92 Watchlist completa</li>
                    <li><strong>Fase D</strong>: JOYP Semantics Fix completo + tests</li>
                    <li><strong>Fase E</strong>: Ejecuci√≥n rom_smoke en baseline e input variant</li>
                    <li><strong>Fase F</strong>: Generaci√≥n de reporte con valores reales</li>
                </ol>

                <h3>Objetivos Espec√≠ficos</h3>
                <ul>
                    <li><strong>Mario (mario.gbc)</strong>: Proporcionar evidencia concreta de por qu√© HRAM[0xFF92] writer (PC=0x1288) no se ejecuta</li>
                    <li><strong>Tetris DX (tetris_dx.gbc)</strong>: Identificar wait-loop real (I/O dominante + condici√≥n) incluso si el parser est√°tico falla</li>
                </ul>

                <h3>Implementaci√≥n</h3>

                <h4>Fase A: Snapshots con Datos Reales</h4>
                <p>
                    Actualizado <code>tools/rom_smoke_0442.py</code> para incluir todas las m√©tricas en snapshots:
                </p>
                <ul>
                    <li><code>pc_hotspot1</code>: PC del hotspot m√°s frecuente</li>
                    <li><code>waits_on_addr</code>: Direcci√≥n I/O en la que espera el loop</li>
                    <li><code>unknown_opcodes_topN</code>: Top N opcodes desconocidos</li>
                    <li><code>branch_blockers_topN</code>: Top N branches que bloquean</li>
                    <li><code>ff92_read_count_program</code>, <code>ff92_write_count_program</code></li>
                    <li><code>joyp_last_read_value</code></li>
                    <li><code>boot_logo_prefill_enabled</code></li>
                    <li><code>first_write_frame</code>, <code>last_write_frame</code> para HRAM FF92</li>
                </ul>
                <p><strong>Resultado:</strong> ‚úÖ Todos los snapshots contienen valores reales (n√∫meros o "N/A"), no placeholders.</p>

                <h4>Fase B: Exec Coverage + Branch Blockers + Last Load A</h4>
                <p><strong>Gate:</strong> <code>VIBOY_DEBUG_BRANCH=1</code></p>
                <p>
                    Implementado en <code>CPU.cpp/CPU.hpp</code>:
                </p>
                <ul>
                    <li><strong>Exec Coverage</strong>: <code>exec_coverage_</code> (map PC ‚Üí contador), <code>coverage_window_start_</code>, <code>coverage_window_end_</code></li>
                    <li><strong>Last Load A</strong>: <code>last_load_a_pc_</code>, <code>last_load_a_addr_</code>, <code>last_load_a_value_</code></li>
                    <li>Tracking en <code>LDH A,(n)</code> (0xF0) y <code>LD A,(nn)</code> (0xFA)</li>
                    <li>M√©todos: <code>set_coverage_window()</code>, <code>get_exec_count()</code>, <code>get_top_exec_pcs()</code>, <code>get_top_branch_blockers()</code>, <code>get_last_load_a_*()</code></li>
                </ul>
                <p>
                    <strong>Cython:</strong> Wrappers Python expuestos en <code>cpu.pxd/cpu.pyx</code>
                </p>
                <p><strong>Estado:</strong> ‚úÖ Compilaci√≥n exitosa, m√©todos disponibles desde Python.</p>

                <h4>Fase C: HRAM FF92 Watchlist</h4>
                <p><strong>Gate:</strong> <code>VIBOY_DEBUG_HRAM=1</code></p>
                <p>
                    Implementado en <code>MMU.cpp/MMU.hpp</code>:
                </p>
                <ul>
                    <li>A√±adido <code>last_write_frame</code> a <code>HRAMWatchEntry</code></li>
                    <li>Tracking de <code>last_read_pc</code> y <code>last_read_value</code> en lecturas HRAM</li>
                    <li>Getters: <code>get_hram_last_write_frame()</code>, <code>get_hram_last_read_pc()</code>, <code>get_hram_last_read_value()</code></li>
                </ul>
                <p>
                    <strong>M√©tricas en snapshots:</strong> WriteCount, ReadCountProg, FirstWriteFrame, LastWriteFrame, LastWritePC/Val, LastReadPC/Val
                </p>
                <p><strong>Estado:</strong> ‚úÖ Implementado y expuesto a Python.</p>

                <h4>Fase D: JOYP Semantics Fix</h4>
                <p>
                    <strong>Problema:</strong> La implementaci√≥n anterior ten√≠a la l√≥gica de selecci√≥n incorrecta cuando ambos grupos estaban seleccionados.
                </p>
                <p>
                    <strong>Soluci√≥n:</strong> Corregido <code>Joypad::read_p1()</code> seg√∫n Pan Docs:
                </p>
                <pre><code>if (select_buttons && select_dpad) {
    // Ambos grupos seleccionados: AND de ambos estados
    low_nibble = action_keys_ & direction_keys_;
} else if (select_buttons) {
    // Solo botones seleccionados (P14=0)
    low_nibble = action_keys_;
} else if (select_dpad) {
    // Solo direcciones seleccionadas (P15=0)
    low_nibble = direction_keys_;
} else {
    // Ning√∫n grupo seleccionado: todos los bits en 1
    low_nibble = 0x0F;
}</code></pre>

                <h5>Tests Creados</h5>
                <ul>
                    <li><code>test_joyp_no_select_reads_ones_0483.py</code>: Verifica que sin selecci√≥n, bits 0-3 = 0x0F</li>
                    <li><code>test_joyp_select_buttons_default_all_released_0483.py</code>: Verifica selecci√≥n de botones</li>
                    <li><code>test_joyp_select_dpad_default_all_released_0483.py</code>: Verifica selecci√≥n de direcciones</li>
                    <li><code>test_joyp_both_selected_AND_behavior_0483.py</code>: Verifica comportamiento AND cuando ambos grupos est√°n seleccionados</li>
                </ul>
                <p><strong>Resultado:</strong> ‚úÖ Todos los tests pasan (5/5).</p>

                <h3>Ejecuci√≥n y Resultados</h3>

                <h4>Mario (mario.gbc) - Baseline</h4>
                <p><strong>Configuraci√≥n:</strong> Frames=180, Snapshots=0,60,120,180</p>
                <p><strong>Hallazgos Clave:</strong></p>
                <ul>
                    <li><strong>Frame 0</strong>: <code>HRAM_FF92_WriteCount=0</code> ‚ö†Ô∏è, <code>PCHotspot1=0x1290</code> (JR NZ, 0x128C), Loop esperando LY=0x91</li>
                    <li><strong>Frame 60</strong>: <code>HRAM_FF92_WriteCount=0</code> ‚ö†Ô∏è <strong>NUNCA se escribi√≥ a FF92</strong>, <code>PCHotspot1=0x12A0</code> (4796 ejecuciones), Disasm muestra <code>0x1298: LDH A,(0xFF92)</code> - Lee FF92 pero nunca se escribi√≥</li>
                    <li><strong>Frame 120</strong>: <code>HRAM_FF92_WriteCount=0</code> ‚ö†Ô∏è, <code>PCHotspot1=0x12A0</code> (9577 ejecuciones)</li>
                </ul>
                <p><strong>Conclusi√≥n Mario:</strong></p>
                <ul>
                    <li>‚ùå <strong>HRAM[0xFF92] NUNCA se escribe</strong> (WriteCount=0 en todos los frames)</li>
                    <li>‚úÖ El c√≥digo en PC=0x1298 <strong>lee</strong> FF92, pero el valor es 0x00 (inicializado)</li>
                    <li>‚ö†Ô∏è El writer en PC=0x1288 <strong>NO se ejecuta</strong> porque la ruta no se alcanza</li>
                    <li>üîç <strong>Causa ra√≠z</strong>: El branch en 0x1290 (JR NZ, 0x128C) siempre toma, creando un loop infinito esperando LY=0x91</li>
                </ul>

                <h4>Tetris DX (tetris_dx.gbc) - Baseline</h4>
                <p><strong>Hallazgos Clave:</strong></p>
                <ul>
                    <li><strong>Frame 60</strong>: <code>JOYP_write_count=14820</code> ‚ö†Ô∏è <strong>Alta actividad JOYP</strong>, <code>JOYP_write_val=0x30</code> (selecciona ambos grupos), <code>JOYP_write_PC=0x12F6</code>, <code>PCHotspot1=0x1306</code> (8117 ejecuciones)</li>
                    <li><strong>Frame 120</strong>: <code>JOYP_write_count=29900</code> (contin√∫a incrementando), <code>PCHotspot1=0x1304</code> (16227 ejecuciones)</li>
                </ul>
                <p><strong>Conclusi√≥n Tetris DX (Baseline):</strong></p>
                <ul>
                    <li>‚úÖ JOYP tiene alta actividad (14820-29900 writes)</li>
                    <li>‚úÖ El c√≥digo escribe 0x30 a JOYP (selecciona ambos grupos)</li>
                    <li>‚ö†Ô∏è El juego est√° en un loop esperando input (wait-loop real)</li>
                    <li>üîç <strong>Causa</strong>: El juego espera que se presione START para continuar</li>
                </ul>

                <h3>Tests y Verificaci√≥n</h3>
                <p><strong>Comando ejecutado:</strong></p>
                <pre><code>python3 -m pytest tests/test_joyp_no_select_reads_ones_0483.py \
    tests/test_joyp_select_buttons_default_all_released_0483.py \
    tests/test_joyp_select_dpad_default_all_released_0483.py \
    tests/test_joyp_both_selected_AND_behavior_0483.py -v</code></pre>
                <p><strong>Resultado:</strong> ‚úÖ <strong>5 passed in 0.81s</strong></p>
                <p><strong>C√≥digo del Test (ejemplo):</strong></p>
                <pre><code>def test_both_selected_with_pressed_buttons(self):
    """Verifica que con ambos grupos seleccionados, si un bot√≥n est√° pulsado,
    el AND debe reflejarlo correctamente."""
    joypad = PyJoypad()
    mmu = PyMMU()
    mmu.set_joypad(joypad)
    
    # Presionar Right (direcci√≥n, bit 0)
    joypad.press_button(0)
    
    # Escribir JOYP = 0x00 (ambos grupos seleccionados)
    mmu.write(0xFF00, 0x00)
    
    # Leer JOYP
    result = mmu.read(0xFF00)
    
    # Assert: Bit 0 debe ser 0 (Right pulsado)
    bit_0 = result & 0x01
    assert bit_0 == 0x00, f"Bit 0 debe ser 0 (Right pulsado), pero es {bit_0}."</code></pre>
                <p><strong>Validaci√≥n Nativa:</strong> Validaci√≥n de m√≥dulo compilado C++</p>

                <h3>Concepto de Hardware</h3>
                <h4>JOYP Register (0xFF00) - Sem√°ntica Completa</h4>
                <p>
                    Seg√∫n Pan Docs, el registro JOYP (0xFF00) tiene la siguiente sem√°ntica:
                </p>
                <ul>
                    <li><strong>Bits 7-6</strong>: Siempre leen como 1 (no usados)</li>
                    <li><strong>Bit 5 (P15)</strong>: 0 = selecciona botones de acci√≥n (A, B, Select, Start)</li>
                    <li><strong>Bit 4 (P14)</strong>: 0 = selecciona botones de direcci√≥n (Right, Left, Up, Down)</li>
                    <li><strong>Bits 3-0</strong>: Estado de botones (0 = presionado, 1 = suelto) [read-only]</li>
                </ul>
                <p>
                    <strong>Comportamiento cuando ambos grupos est√°n seleccionados:</strong>
                </p>
                <ul>
                    <li>Si ambos P14 y P15 son 0 (ambos grupos seleccionados), el resultado es el <strong>AND l√≥gico</strong> de ambos estados</li>
                    <li>Esto permite detectar cuando se presiona un bot√≥n que est√° en ambos grupos (ej: Right y A comparten bit 0)</li>
                </ul>
                <p>
                    <strong>Por qu√© es importante:</strong> Algunos juegos usan este comportamiento para detectar combinaciones de botones o para simplificar la l√≥gica de polling.
                </p>

                <h3>Archivos Modificados</h3>
                <ul>
                    <li><code>src/core/cpp/CPU.hpp</code>: A√±adidos miembros para exec coverage, branch blockers, last_load_a</li>
                    <li><code>src/core/cpp/CPU.cpp</code>: Implementaci√≥n de tracking y getters</li>
                    <li><code>src/core/cpp/Joypad.cpp</code>: Correcci√≥n de sem√°ntica JOYP</li>
                    <li><code>src/core/cpp/MMU.hpp</code>: A√±adido <code>last_write_frame</code> a HRAMWatchEntry, getters</li>
                    <li><code>src/core/cpp/MMU.cpp</code>: Tracking de last_write_frame, last_read_pc/value</li>
                    <li><code>src/core/cython/cpu.pxd</code>: Declaraciones de nuevos m√©todos</li>
                    <li><code>src/core/cython/cpu.pyx</code>: Wrappers Python</li>
                    <li><code>src/core/cython/mmu.pxd</code>: Declaraciones de getters HRAM</li>
                    <li><code>src/core/cython/mmu.pyx</code>: Wrappers Python</li>
                    <li><code>tools/rom_smoke_0442.py</code>: A√±adidas todas las m√©tricas a snapshots</li>
                    <li><code>tests/test_joyp_*_0483.py</code>: 4 nuevos tests</li>
                </ul>

                <h3>Pr√≥ximos Pasos (Step 0484)</h3>
                <h4>Mario</h4>
                <ol>
                    <li>Configurar exec coverage para ventana 0x1270-0x12B0</li>
                    <li>Verificar por qu√© LY nunca alcanza 0x91</li>
                    <li>Analizar branch blockers en 0x1290</li>
                    <li>Identificar condici√≥n que bloquea la ruta hacia 0x1288</li>
                </ol>
                <h4>Tetris DX</h4>
                <ol>
                    <li>Ejecutar con <code>VIBOY_AUTOPRESS=START</code> y verificar avance</li>
                    <li>Si no avanza, investigar BIT test en 0x12DD</li>
                    <li>Verificar condici√≥n del branch que mantiene el loop</li>
                </ol>

                <h3>Referencias</h3>
                <ul>
                    <li>Pan Docs - Joypad Input, P1 Register</li>
                    <li>Step 0482: Branch Decision Counters, Last Compare/BIT Tracking</li>
                    <li>Step 0481: HRAM Watchlist Gen√©rica</li>
                </ul>
            </section>
        </article>
    </div>
</body>
</html>

