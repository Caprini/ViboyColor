<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Implementaci贸n de Trazado de CPU "Disparado" (Triggered) - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Implementaci贸n de Trazado de CPU "Disparado" (Triggered)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0157
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0156__debug-extension-final-traza-cpu-2000.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El an谩lisis de la traza de 2000 instrucciones (Step 0156) demostr贸 que el m茅todo de trazado de longitud fija es ineficiente para superar las largas rutinas de inicializaci贸n de la ROM. Se implement贸 un sistema de trazado "disparado" (triggered) que se activa autom谩ticamente cuando el Program Counter (PC) supera una direcci贸n espec铆fica (0x0300), evitando as铆 registrar miles de instrucciones de bucles de inicializaci贸n y permitiendo capturar directamente el c贸digo cr铆tico que se ejecuta despu茅s.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    Las rutinas de inicializaci贸n de las ROMs de Game Boy pueden ejecutar miles de instrucciones en bucles de limpieza de memoria antes de llegar al c贸digo principal del juego. El trazado de todas estas instrucciones es ineficiente y genera logs masivos que dificultan el an谩lisis.
                </p>
                <p>
                    Una estrategia m谩s eficiente es usar <strong>trazado condicional</strong> o <strong>trazado disparado</strong>: en lugar de registrar las primeras N instrucciones desde el inicio, el sistema espera hasta que el Program Counter alcance una direcci贸n espec铆fica (el "trigger") y solo entonces comienza a registrar. Esto permite:
                </p>
                <ul>
                    <li><strong>Evitar ruido:</strong> No se registran miles de instrucciones de bucles de inicializaci贸n.</li>
                    <li><strong>Enfoque dirigido:</strong> Se captura directamente el c贸digo cr铆tico que se ejecuta despu茅s de la inicializaci贸n.</li>
                    <li><strong>Eficiencia:</strong> Se reduce dr谩sticamente el tama帽o de los logs y el tiempo de an谩lisis.</li>
                </ul>
                <p>
                    Bas谩ndonos en el an谩lisis previo, sabemos que los bucles de inicializaci贸n de Tetris terminan alrededor de la direcci贸n <code>0x0297-0x0298</code>. Establecer el trigger en <code>0x0300</code> garantiza que capturaremos el c贸digo que se ejecuta inmediatamente despu茅s de que todos los bucles hayan finalizado.
                </p>
                <p>
                    <strong>Fuente:</strong> T茅cnica de depuraci贸n est谩ndar en emulaci贸n - Conditional Breakpoints / Triggered Tracing
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se reemplaz贸 el sistema de trazado de longitud fija por un sistema de trazado disparado basado en el Program Counter. El sistema ahora incluye:
                </p>
                <ul>
                    <li><strong>Direcci贸n de activaci贸n (trigger):</strong> <code>DEBUG_TRIGGER_PC = 0x0300</code></li>
                    <li><strong>Bandera de activaci贸n:</strong> <code>debug_trace_activated</code> que se activa cuando el PC supera el trigger</li>
                    <li><strong>Contador post-activaci贸n:</strong> Registra hasta 100 instrucciones despu茅s de la activaci贸n</li>
                </ul>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>CPU.cpp:</strong> Reemplazo completo de la l贸gica de trazado con sistema disparado.</li>
                </ul>

                <h3>Cambios realizados</h3>
                <p>
                    <strong>Variables est谩ticas actualizadas:</strong>
                </p>
                <pre><code>// Variables est谩ticas para logging de diagn贸stico con sistema "disparado" (triggered)
static const uint16_t DEBUG_TRIGGER_PC = 0x0300; // Direcci贸n de activaci贸n del trazado
static bool debug_trace_activated = false;      // Bandera de activaci贸n
static int debug_instruction_counter = 0;       // Contador post-activaci贸n
static const int DEBUG_INSTRUCTION_LIMIT = 100; // L铆mite post-activaci贸n (reducido porque ahora es dirigido)</code></pre>

                <p>
                    <strong>Constructor actualizado:</strong>
                </p>
                <pre><code>CPU::CPU(MMU* mmu, CoreRegisters* registers)
    : mmu_(mmu), regs_(registers), cycles_(0), ime_(false), halted_(false), ime_scheduled_(false) {
    // ...
    // Resetear contador y bandera de debug al crear nueva instancia
    debug_trace_activated = false;
    debug_instruction_counter = 0;
}</code></pre>

                <p>
                    <strong>L贸gica de trazado en step():</strong>
                </p>
                <pre><code>// --- NUEVA LGICA DE TRAZADO DISPARADO (TRIGGERED) ---
// 1. Comprobar si debemos activar la traza cuando el PC supera el trigger
if (!debug_trace_activated && current_pc >= DEBUG_TRIGGER_PC) {
    printf("--- [CPU TRACE TRIGGERED at PC: 0x%04X] ---\n", current_pc);
    debug_trace_activated = true;
}

// 2. Si la traza est谩 activa, registrar hasta el l铆mite
if (debug_trace_activated && debug_instruction_counter < DEBUG_INSTRUCTION_LIMIT) {
    printf("[CPU TRACE %d] PC: 0x%04X | Opcode: 0x%02X\n",
           debug_instruction_counter, current_pc, opcode);
    debug_instruction_counter++;
}
// --- FIN DE LA NUEVA LGICA DE TRAZADO DISPARADO ---</code></pre>

                <h3>Decisiones de dise帽o</h3>
                <ul>
                    <li><strong>Direcci贸n de trigger (0x0300):</strong> Elegida bas谩ndose en el an谩lisis previo que mostr贸 que los bucles terminan alrededor de 0x0297-0x0298. 0x0300 proporciona un margen de seguridad.</li>
                    <li><strong>L铆mite reducido (100 instrucciones):</strong> Como ahora el trazado es dirigido y captura c贸digo cr铆tico, 100 instrucciones deber铆an ser suficientes para identificar el siguiente opcode faltante.</li>
                    <li><strong>Bandera est谩tica:</strong> Se usa una bandera est谩tica para mantener el estado entre llamadas a <code>step()</code>, permitiendo que el sistema se active una sola vez y luego registre las siguientes instrucciones.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Reemplazo completo del sistema de trazado con l贸gica disparada basada en PC.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    La verificaci贸n se realizar谩 mediante ejecuci贸n del emulador con una ROM de prueba:
                </p>
                <ul>
                    <li><strong>Comando de compilaci贸n:</strong> <code>.\rebuild_cpp.ps1</code></li>
                    <li><strong>Comando de ejecuci贸n:</strong> <code>python main.py roms/tetris.gb</code></li>
                    <li><strong>Resultado esperado:</strong> 
                        <ul>
                            <li>La consola deber铆a permanecer en silencio durante los bucles de inicializaci贸n.</li>
                            <li>Cuando el PC alcance 0x0300, deber铆a aparecer: <code>--- [CPU TRACE TRIGGERED at PC: 0x0300] ---</code></li>
                            <li>A continuaci贸n, deber铆an aparecer las 100 instrucciones cr铆ticas que se ejecutan despu茅s.</li>
                        </ul>
                    </li>
                    <li><strong>Validaci贸n:</strong> La nueva traza deber铆a ser radicalmente diferente a la anterior, sin mostrar ninguna instrucci贸n del bucle 0x0293-0x0295, y capturando directamente el c贸digo de la siguiente fase de inicializaci贸n.</li>
                </ul>
                <p>
                    <em>Nota: La validaci贸n completa requiere ejecutar el emulador y analizar la salida de la consola. Este paso documenta la implementaci贸n del sistema de trazado disparado.</em>
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>T茅cnica de depuraci贸n est谩ndar: Conditional Breakpoints / Triggered Tracing</li>
                    <li>An谩lisis previo de trazas (Steps 0155 y 0156) que identificaron la ubicaci贸n de los bucles de inicializaci贸n</li>
                </ul>
                <p>
                    <em>Nota: Esta es una t茅cnica de depuraci贸n est谩ndar en emulaci贸n, no espec铆fica del hardware Game Boy.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Trazado condicional:</strong> El trazado de todas las instrucciones desde el inicio es ineficiente cuando hay rutinas de inicializaci贸n largas. El trazado condicional permite enfocarse en el c贸digo cr铆tico.</li>
                        <li><strong>Estrategia de depuraci贸n:</strong> En lugar de usar "fuerza bruta" (aumentar el l铆mite indefinidamente), es mejor usar una estrategia dirigida que capture solo lo relevante.</li>
                        <li><strong>An谩lisis de trazas previas:</strong> El an谩lisis de las trazas anteriores nos permiti贸 identificar d贸nde terminan los bucles de inicializaci贸n, lo que nos permiti贸 elegir una direcci贸n de trigger apropiada.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Efectividad del trigger:</strong> Necesitamos verificar que 0x0300 es una direcci贸n apropiada y que captura el c贸digo cr铆tico sin perder informaci贸n importante.</li>
                        <li><strong>L铆mite de 100 instrucciones:</strong> Necesitamos confirmar que 100 instrucciones son suficientes para identificar el siguiente opcode faltante.</li>
                        <li><strong>An谩lisis de la nueva traza:</strong> Una vez ejecutado el emulador, necesitamos analizar la nueva traza para identificar el siguiente opcode que debemos implementar.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis principal:</strong> El c贸digo que se ejecuta despu茅s de 0x0300 contendr谩 el siguiente opcode faltante que necesitamos implementar para que el juego contin煤e. Esta hip贸tesis se basa en el an谩lisis previo que mostr贸 que los bucles de inicializaci贸n terminan alrededor de 0x0297-0x0298.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m贸dulo C++ con <code>.\rebuild_cpp.ps1</code></li>
                    <li>[ ] Ejecutar el emulador con <code>python main.py roms/tetris.gb</code></li>
                    <li>[ ] Analizar la nueva traza dirigida para identificar el siguiente opcode faltante</li>
                    <li>[ ] Implementar el opcode identificado si es necesario</li>
                    <li>[ ] Verificar que el juego puede continuar m谩s all谩 de la inicializaci贸n</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

