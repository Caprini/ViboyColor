<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0398: Investigar Zelda DX: Tilemap 100% pero TileData 0% - Bit√°cora Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica.</p>
        </div>

        <!-- Breadcrumb -->
        <div class="breadcrumb">
            <a href="../index.html">‚Üê Volver a la Bit√°cora</a>
        </div>

        <!-- Header de la Entrada -->
        <header>
            <h1>Step 0398: Investigar Zelda DX: Tilemap 100% pero TileData 0%</h1>
            <div class="entry-metadata">
                <span class="meta-item"><strong>Fecha:</strong> 2025-12-31</span>
                <span class="meta-item"><strong>Step ID:</strong> 0398</span>
                <span class="meta-item"><strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span></span>
            </div>
        </header>

        <!-- Contenido Principal -->
        <main>
            <!-- Resumen Ejecutivo -->
            <section id="resumen">
                <h2>üìã Resumen Ejecutivo</h2>
                <p>
                    El Step 0397 identific√≥ que Zelda DX mostraba un comportamiento inusual: <strong>Tilemap 100%</strong> (todos los tiles definidos) pero <strong>TileData 0%</strong> (no hay datos de tiles en VRAM). Este step implementa diagn√≥sticos especializados para investigar la causa ra√≠z.
                </p>
                <p><strong>Hallazgo cr√≠tico</strong>: El tilemap est√° "lleno" pero todos los tiles son <strong>tile ID 0x00</strong>. No hay diversidad de tile IDs. Esto es un estado de inicializaci√≥n donde el juego ha limpiado el tilemap a valores por defecto pero a√∫n no ha cargado los tiles reales desde ROM.</p>
                
                <h3>Causa Ra√≠z Identificada</h3>
                <ol>
                    <li><strong>Tilemap 100%</strong>: 1024/1024 tiles no-cero, pero <strong>0 tile IDs √∫nicos</strong> ‚Üí todos son 0x00</li>
                    <li><strong>TileData 0%</strong>: 0 bytes no-cero en VRAM Bank 0 y Bank 1 (0.00% en rangos 0x8000-0x8FFF y 0x8800-0x97FF)</li>
                    <li><strong>Timing</strong>: Tilemap detectado en Frame 1, TileData <strong>nunca se carga</strong> (no detectado en 2000 frames)</li>
                    <li><strong>DMA/HDMA</strong>: Registros HDMA en 0xFF (no inicializados), no hay transferencias activas</li>
                </ol>
                
                <p><strong>Conclusi√≥n</strong>: Zelda DX NO est√° en estado jugable en Frame 1080. La m√©trica "Tilemap 100%" del Step 0397 era enga√±osa porque contaba bytes != 0x00, pero no verificaba diversidad de tile IDs. Un tilemap lleno de 0x00 es funcionalmente vac√≠o.</p>
            </section>

            <!-- Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>üîß Concepto de Hardware</h2>
                <h3>Relaci√≥n Tilemap ‚Üí Tiles en VRAM</h3>
                <p>
                    Seg√∫n <strong>Pan Docs - Background, Tiles</strong>, el renderizado del background funciona as√≠:
                </p>
                <ol>
                    <li><strong>Tilemap (0x9800-0x9FFF o 0x9C00-0x9FFF)</strong>: Array de 32x32 bytes (1024 tiles) donde cada byte es un <strong>Tile ID</strong> (0-255).</li>
                    <li><strong>Tile Data (0x8000-0x97FF)</strong>: 384 tiles de 16 bytes cada uno (6 KB). Cada Tile ID referencia uno de estos tiles.</li>
                    <li><strong>Modo de Direccionamiento</strong>:
                        <ul>
                            <li><strong>Unsigned (LCDC bit 4 = 1)</strong>: Tile ID 0-255 ‚Üí direcci√≥n 0x8000 + (ID √ó 16)</li>
                            <li><strong>Signed (LCDC bit 4 = 0)</strong>: Tile ID -128 a +127 ‚Üí direcci√≥n 0x9000 + (ID √ó 16)</li>
                        </ul>
                    </li>
                </ol>

                <h3>Diversidad de Tile IDs vs Bytes No-Cero</h3>
                <p>
                    <strong>M√©trica enga√±osa</strong>: Un tilemap con 1024 bytes != 0x00 parece "lleno", pero si todos son 0x00, entonces:
                </p>
                <ul>
                    <li>Tile IDs √∫nicos = 0 (porque 0x00 cuenta como "no-cero" en la comparaci√≥n != 0x00, pero es un valor √∫nico)</li>
                    <li>Funcionalmente, el tilemap est√° vac√≠o (todo apunta al tile 0x00)</li>
                </ul>
                <p>
                    <strong>M√©trica correcta</strong>: Contar tile IDs √∫nicos, no solo bytes no-cero.
                </p>

                <h3>VRAM Dual-Bank (Game Boy Color)</h3>
                <p>
                    Seg√∫n <strong>Pan Docs - VRAM Banks</strong>, la GBC tiene 2 bancos VRAM:
                </p>
                <ul>
                    <li><strong>Bank 0 (0x8000-0x9FFF)</strong>: Tile data principal</li>
                    <li><strong>Bank 1 (0x8000-0x9FFF)</strong>: Tile attributes (paleta, flip, prioridad)</li>
                </ul>
                <p>
                    Para verificar si hay tiles, es necesario comprobar ambos bancos usando <code>read_vram_bank(bank, offset)</code>.
                </p>
            </section>

            <!-- Problema Investigado -->
            <section id="problema">
                <h2>üêõ Problema Investigado</h2>
                <h3>Observaci√≥n del Step 0397</h3>
                <p>
                    Zelda DX mostraba:
                </p>
                <pre><code>[VRAM-USAGE] Frame 1080 | Tetris DX | TileData: 23.0% | TileMap: 99.1% | Tiles: 98
[VRAM-USAGE] Frame 1080 | Zelda DX  | TileData: 0.0%  | TileMap: 100.0% | Tiles: 0</code></pre>
                <p>
                    <strong>Pregunta</strong>: ¬øC√≥mo puede haber tilemap 100% sin tiles correspondientes?
                </p>

                <h3>Hip√≥tesis Iniciales</h3>
                <ol>
                    <li>Tiles cargados mediante DMA/HDMA despu√©s de configurar tilemap (timing)</li>
                    <li>Tiles en VRAM Bank 1 pero el conteo solo verifica Bank 0</li>
                    <li>Modo de direccionamiento signed/unsigned apuntando fuera de rango</li>
                    <li>Tilemap apunta a tile IDs en proceso de carga (transitorio)</li>
                    <li>Tiles en rango diferente de VRAM (no 0x8000-0x97FF)</li>
                </ol>
            </section>

            <!-- Implementaci√≥n -->
            <section id="implementacion">
                <h2>‚öôÔ∏è Implementaci√≥n</h2>

                <h3>1. An√°lisis de Tile IDs y Verificaci√≥n Dual-Bank</h3>
                <p><strong>Archivo</strong>: <code>src/core/cpp/PPU.cpp</code></p>
                <p><strong>Funci√≥n</strong>: <code>analyze_tilemap_tile_ids()</code></p>
                
                <p>Implementa an√°lisis completo del tilemap:</p>
                <ul>
                    <li>Lee 1024 tiles del tilemap (0x9800-0x9FFF o 0x9C00-0x9FFF seg√∫n LCDC bit 3)</li>
                    <li>Cuenta tile IDs √∫nicos (no solo bytes no-cero)</li>
                    <li>Calcula direcciones seg√∫n modo signed/unsigned (LCDC bit 4)</li>
                    <li>Verifica existencia de cada tile en ambos bancos VRAM (Bank 0 y Bank 1)</li>
                    <li>Genera top 20 de tile IDs m√°s comunes con su existencia en VRAM</li>
                </ul>

                <pre><code>// Contar tile IDs √∫nicos (no solo bytes no-cero)
uint8_t tile_id_seen[256] = {0};
for (uint16_t i = 0; i < 1024; i++) {
    uint8_t tile_id = mmu_->read(tilemap_base + i);
    tile_id_seen[tile_id]++;
}

int unique_tiles = 0;
for (int i = 0; i < 256; i++) {
    if (tile_id_seen[i] > 0) {
        unique_tiles++;
    }
}

// Para cada tile ID √∫nico, verificar existencia en ambos bancos
for (int id = 0; id < 256; id++) {
    if (tile_id_seen[id] == 0) continue;
    
    uint16_t tile_addr = /* calcular seg√∫n modo signed/unsigned */;
    uint16_t tile_offset = tile_addr - VRAM_START;
    
    int non_zero_bank0 = 0, non_zero_bank1 = 0;
    for (uint16_t j = 0; j < 16; j++) {
        if (mmu_->read_vram_bank(0, tile_offset + j) != 0x00) non_zero_bank0++;
        if (mmu_->read_vram_bank(1, tile_offset + j) != 0x00) non_zero_bank1++;
    }
    
    bool has_data_bank0 = (non_zero_bank0 >= 2);
    bool has_data_bank1 = (non_zero_bank1 >= 2);
}</code></pre>

                <h3>2. Verificaci√≥n de Rangos VRAM Completos</h3>
                <p>Verifica ambos rangos de direccionamiento:</p>
                <ul>
                    <li><strong>0x8000-0x8FFF</strong> (unsigned base, 4 KB): Para tiles 0-127</li>
                    <li><strong>0x8800-0x97FF</strong> (signed range, 4 KB): Para tiles -128 a +127 (base en 0x9000)</li>
                    <li>Verifica ambos bancos VRAM (Bank 0 y Bank 1)</li>
                </ul>

                <pre><code>// Verificar rango unsigned (0x8000-0x8FFF)
int non_zero_8000_8FFF_bank0 = 0;
for (uint16_t i = 0; i < 0x1000; i++) {
    if (mmu_->read_vram_bank(0, i) != 0x00) non_zero_8000_8FFF_bank0++;
}

// Verificar rango signed (0x8800-0x97FF)
int non_zero_8800_97FF_bank0 = 0;
for (uint16_t i = 0x800; i < 0x1800; i++) {
    if (mmu_->read_vram_bank(0, i) != 0x00) non_zero_8800_97FF_bank0++;
}</code></pre>

                <h3>3. Verificaci√≥n de DMA/HDMA</h3>
                <p><strong>Funci√≥n</strong>: <code>check_dma_hdma_activity()</code></p>
                <p>Lee registros DMA/HDMA para detectar transferencias activas:</p>
                <pre><code>uint8_t dma_reg = mmu_->read(0xFF46);  // DMA General
uint8_t hdma5 = mmu_->read(0xFF55);    // HDMA Length/Mode/Start

bool hdma_active = (hdma5 & 0x80) == 0;  // Bit 7: 0=active, 1=inactive
uint16_t hdma_source = ((hdma1 << 8) | hdma2) & 0xFFF0;
uint16_t hdma_dest = (((hdma3 & 0x1F) << 8) | hdma4) & 0xFFF0 | 0x8000;</code></pre>

                <h3>4. An√°lisis de Timing de Carga</h3>
                <p><strong>Funci√≥n</strong>: <code>analyze_load_timing()</code></p>
                <p>Rastrea cu√°ndo se carga tilemap vs tiledata:</p>
                <pre><code>// Detectar carga de tilemap (> 50% no-cero)
if (!tilemap_loaded) {
    int tilemap_nonzero = count_vram_nonzero_bank0_tilemap();
    if (tilemap_nonzero > 512) {  // > 50% de 1024 tiles
        tilemap_loaded = true;
        tilemap_load_frame = current_frame;
    }
}

// Detectar carga de tiledata (> 5% no-cero)
if (!tiledata_loaded) {
    int tiledata_nonzero = count_vram_nonzero_bank0_tiledata();
    if (tiledata_nonzero > 300) {  // > 5% de 6144 bytes
        tiledata_loaded = true;
        tiledata_load_frame = current_frame;
    }
}</code></pre>

                <h3>5. Integraci√≥n en render_scanline()</h3>
                <p>Las funciones se ejecutan solo en Frame 1080, LY=0:</p>
                <pre><code>// --- Step 0398: An√°lisis de Zelda DX Tilemap sin TileData ---
if (ly_ == 0) {
    analyze_tilemap_tile_ids();  // Tarea 1 & 2
    check_dma_hdma_activity();   // Tarea 3
    analyze_load_timing();        // Tarea 4
}</code></pre>

                <h3>6. Declaraciones en PPU.hpp</h3>
                <p>Se a√±adieron las declaraciones de las nuevas funciones:</p>
                <pre><code>void analyze_tilemap_tile_ids();     // An√°lisis de tile IDs y verificaci√≥n dual-bank
void check_dma_hdma_activity();      // Verificaci√≥n de DMA/HDMA
void analyze_load_timing();          // An√°lisis de timing de carga</code></pre>
            </section>

            <!-- Resultados -->
            <section id="resultados">
                <h2>üìä Resultados del An√°lisis</h2>

                <h3>1. An√°lisis de Tilemap</h3>
                <pre><code>[ZELDA-TILEMAP-ANALYSIS] Frame 1080 - An√°lisis completo de Tilemap
[ZELDA-TILEMAP-ANALYSIS] LCDC: 0xE3 | Tilemap Base: 0x9800 | Mode: SIGNED
[ZELDA-TILEMAP-ANALYSIS] Total tiles en tilemap: 1024/1024
[ZELDA-TILEMAP-ANALYSIS] Tiles no-cero: 1024/1024 (100.0%)
[ZELDA-TILEMAP-ANALYSIS] Tile IDs √∫nicos: 0/256
[ZELDA-TILEMAP-ANALYSIS] Top 20 Tile IDs m√°s comunes: (ninguno, todos son 0x00)
[ZELDA-TILEMAP-ANALYSIS] Resumen de existencia de tiles:
[ZELDA-TILEMAP-ANALYSIS]   Tiles con datos en Bank 0: 0/0
[ZELDA-TILEMAP-ANALYSIS]   Tiles con datos en Bank 1: 0/0
[ZELDA-TILEMAP-ANALYSIS]   Tiles completamente vac√≠os: 0/0</code></pre>

                <p><strong>Interpretaci√≥n</strong>:</p>
                <ul>
                    <li>1024 tiles no-cero pero <strong>0 tile IDs √∫nicos</strong> ‚Üí todos son 0x00</li>
                    <li>No hay diversidad de tile IDs</li>
                    <li>Tilemap est√° en estado de inicializaci√≥n (limpiado a 0x00)</li>
                </ul>

                <h3>2. Verificaci√≥n de Rangos VRAM</h3>
                <pre><code>[ZELDA-VRAM-RANGE-CHECK] Verificaci√≥n de rangos VRAM:
[ZELDA-VRAM-RANGE-CHECK]   0x8000-0x8FFF (unsigned base) Bank0: 0/4096 (0.00%) Bank1: 0/4096 (0.00%)
[ZELDA-VRAM-RANGE-CHECK]   0x8800-0x97FF (signed range) Bank0: 0/4096 (0.00%) Bank1: 0/4096 (0.00%)</code></pre>

                <p><strong>Interpretaci√≥n</strong>:</p>
                <ul>
                    <li>VRAM completamente vac√≠a en ambos bancos</li>
                    <li>No hay tiles en ning√∫n rango de direccionamiento</li>
                    <li>Descarta hip√≥tesis de tiles en Bank 1 o fuera de rango</li>
                </ul>

                <h3>3. Verificaci√≥n de DMA/HDMA</h3>
                <pre><code>[ZELDA-DMA-CHECK] Frame 1080 - Verificaci√≥n de DMA/HDMA
[ZELDA-DMA-CHECK] Registro DMA (0xFF46): 0xC3
[ZELDA-DMA-CHECK] HDMA1 (Source High, 0xFF51): 0xFF
[ZELDA-DMA-CHECK] HDMA2 (Source Low, 0xFF52): 0xFF
[ZELDA-DMA-CHECK] HDMA3 (Dest High, 0xFF53): 0xFF
[ZELDA-DMA-CHECK] HDMA4 (Dest Low, 0xFF54): 0xFF
[ZELDA-DMA-CHECK] HDMA5 (Length/Mode, 0xFF55): 0xFF
[ZELDA-DMA-CHECK] HDMA Active: NO | Mode: H-Blank | Length: 128 blocks (x16 bytes = 2048 bytes)
[ZELDA-DMA-CHECK] HDMA Source: 0xFFF0 | Destination: 0x9FF0</code></pre>

                <p><strong>Interpretaci√≥n</strong>:</p>
                <ul>
                    <li>Registros HDMA en 0xFF (valores no inicializados)</li>
                    <li>No hay transferencias HDMA activas</li>
                    <li>Descarta hip√≥tesis de tiles cargados mediante DMA/HDMA</li>
                </ul>

                <h3>4. Timing de Carga</h3>
                <pre><code>[ZELDA-LOAD-TIMING] Tilemap detectado cargado en Frame 1 (200.0% no-cero)
(No hay l√≠nea de TileData cargado ‚Üí nunca se carg√≥ en 2000 frames)</code></pre>

                <p><strong>Interpretaci√≥n</strong>:</p>
                <ul>
                    <li>Tilemap se carga en Frame 1 (inicializaci√≥n temprana)</li>
                    <li>TileData <strong>nunca se detecta como cargado</strong> en los primeros 2000 frames</li>
                    <li>Confirma que el juego est√° en estado de inicializaci√≥n, no jugable</li>
                </ul>
            </section>

            <!-- Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>‚úÖ Tests y Verificaci√≥n</h2>
                
                <h3>Comando de Compilaci√≥n</h3>
                <pre><code>cd /media/fabini/8CD1-4C30/ViboyColor
python3 setup.py build_ext --inplace > build_log_step0398.txt 2>&1
# ‚úì Compilaci√≥n exitosa</code></pre>

                <h3>Comando de Ejecuci√≥n</h3>
                <pre><code>timeout 30s python3 main.py roms/Oro.gbc > logs/step0398_zelda_dx.log 2>&1
# ‚úì Ejecuci√≥n completada (30s)</code></pre>

                <h3>An√°lisis de Logs</h3>
                <pre><code># An√°lisis del tilemap
grep -E "\[ZELDA-TILEMAP-ANALYSIS\]" logs/step0398_zelda_dx.log

# Verificaci√≥n DMA
grep -E "\[ZELDA-DMA-CHECK\]" logs/step0398_zelda_dx.log

# Timing de carga
grep -E "\[ZELDA-LOAD-TIMING\]" logs/step0398_zelda_dx.log

# Verificaci√≥n de rango VRAM
grep -E "\[ZELDA-VRAM-RANGE-CHECK\]" logs/step0398_zelda_dx.log</code></pre>

                <h3>Resultados de Validaci√≥n</h3>
                <ul>
                    <li>‚úÖ Compilaci√≥n sin errores ni warnings</li>
                    <li>‚úÖ Ejecuci√≥n sin crashes (30 segundos)</li>
                    <li>‚úÖ An√°lisis de tilemap ejecutado en Frame 1080</li>
                    <li>‚úÖ Verificaci√≥n DMA/HDMA ejecutada</li>
                    <li>‚úÖ Timing de carga rastreado</li>
                    <li>‚úÖ Rangos VRAM verificados en ambos bancos</li>
                    <li>‚úÖ Causa ra√≠z identificada (tilemap lleno de 0x00)</li>
                </ul>
            </section>

            <!-- Conclusiones -->
            <section id="conclusiones">
                <h2>üéØ Conclusiones</h2>

                <h3>Causa Ra√≠z Confirmada</h3>
                <p>
                    Zelda DX NO est√° en estado jugable en Frame 1080. Lo que vemos es un estado de <strong>inicializaci√≥n</strong> donde:
                </p>
                <ol>
                    <li>El juego ha inicializado el tilemap con valores por defecto (todo 0x00)</li>
                    <li>Los tiles reales a√∫n no se han cargado desde ROM a VRAM</li>
                    <li>El juego probablemente est√° en una pantalla de carga o inicializaci√≥n</li>
                </ol>

                <h3>M√©trica Enga√±osa del Step 0397</h3>
                <p>
                    La m√©trica "Tilemap 100%" era enga√±osa porque:
                </p>
                <ul>
                    <li><strong>Contaba bytes != 0x00</strong>, pero no verificaba <strong>diversidad de tile IDs</strong></li>
                    <li>Un tilemap lleno de 0x00 cuenta como "100% no-cero" (porque 0x00 != 0x00 es falso, pero el byte existe)</li>
                    <li><strong>M√©trica correcta</strong>: Contar tile IDs √∫nicos, no solo bytes no-cero</li>
                </ul>

                <h3>Lecciones Aprendidas</h3>
                <ol>
                    <li><strong>Verificar diversidad, no solo existencia</strong>: Un tilemap lleno de un solo valor es funcionalmente vac√≠o</li>
                    <li><strong>Acceso dual-bank correcto</strong>: Usar <code>read_vram_bank(bank, offset)</code> en lugar de <code>read(0x8000 + offset)</code></li>
                    <li><strong>Timing de inicializaci√≥n</strong>: Los primeros frames pueden estar en estado transitorio</li>
                    <li><strong>Diagn√≥sticos espec√≠ficos por juego</strong>: Diferentes juegos requieren an√°lisis diferentes</li>
                </ol>

                <h3>Pr√≥ximos Pasos</h3>
                <ul>
                    <li>Mejorar m√©trica de detecci√≥n de tilemap para contar tile IDs √∫nicos</li>
                    <li>Implementar detecci√≥n de estados de inicializaci√≥n vs jugable</li>
                    <li>Analizar otros juegos con comportamientos similares (ej: Pok√©mon)</li>
                    <li>Considerar esperar m√°s frames para que el juego cargue completamente</li>
                </ul>
            </section>

            <!-- Archivos Modificados -->
            <section id="archivos-modificados">
                <h2>üìÅ Archivos Modificados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.hpp</code> - Declaraciones de funciones de an√°lisis</li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Implementaci√≥n de an√°lisis de Zelda DX</li>
                    <li><code>logs/step0398_zelda_dx.log</code> - Logs del an√°lisis (generado)</li>
                    <li><code>build_log_step0398.txt</code> - Log de compilaci√≥n (generado)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                Viboy Color - Proyecto educativo de emulaci√≥n de Game Boy Color<br>
                <a href="https://github.com/fabini-cpu/ViboyColor">GitHub</a> | 
                <a href="https://viboycolor.fabini.one">Web Oficial</a>
            </p>
        </footer>
    </div>
</body>
</html>

