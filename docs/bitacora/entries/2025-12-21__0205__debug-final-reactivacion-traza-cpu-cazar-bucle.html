<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Final: Reactivaci√≥n de la Traza de CPU para Cazar el Bucle - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug Final: Reactivaci√≥n de la Traza de CPU para Cazar el Bucle</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-21
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0205
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîß DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-21__0204__sensor-vram-monitoreo-escrituras-tiempo-real.html">Anterior (0204)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El sensor de VRAM del Step 0204 ha confirmado que la CPU nunca intenta escribir en la memoria de v√≠deo. Esto significa que el emulador est√° atrapado en un bucle l√≥gico de software (un "wait loop") al inicio de la ejecuci√≥n de la ROM, antes de cualquier rutina gr√°fica. Para identificar este bucle, reactivamos el sistema de trazado de la CPU para capturar las primeras 200 instrucciones ejecutadas desde el arranque, revelando el patr√≥n del bucle infinito y permiti√©ndonos entender qu√© condici√≥n de hardware no estamos cumpliendo.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: An√°lisis de Flujo de Control</h2>
                <p>
                    Si la CPU no avanza, es porque est√° ejecutando un salto condicional (<code>JR</code>, <code>JP</code>, <code>CALL</code>, <code>RET</code>) que siempre la lleva de vuelta al mismo punto. Al ver la secuencia de instrucciones, identificaremos el bucle (ej: "Lee registro X, Compara con Y, Salta si no es igual").
                </p>
                <p>
                    Los bucles de espera comunes en el arranque de la Game Boy incluyen:
                </p>
                <ul>
                    <li><strong>Bucle de Joypad:</strong> <code>LD A, (FF00)</code> ‚Üí <code>BIT ...</code> ‚Üí <code>JR ...</code> (Esperando que se suelte un bot√≥n).</li>
                    <li><strong>Bucle de Timer:</strong> <code>LD A, (FF04)</code> ‚Üí <code>CP ...</code> ‚Üí <code>JR ...</code> (Esperando a que el timer avance).</li>
                    <li><strong>Bucle de V-Blank:</strong> <code>LDH A, (44)</code> (Lee LY) ‚Üí <code>CP 90</code> (Compara con 144) ‚Üí <code>JR NZ</code> (Salta si no es VBlank).</li>
                    <li><strong>Bucle de Checksum:</strong> Lectura de memoria y comparaciones matem√°ticas.</li>
                </ul>
                <p>
                    El √∫ltimo patr√≥n que se repita en la traza ser√° nuestro culpable. Al ver la secuencia exacta de instrucciones, podremos identificar qu√© registro o flag est√° comprobando el juego y por qu√© falla.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Implementamos un sistema de trazado simple en <code>CPU::step()</code> que imprime las primeras 200 instrucciones ejecutadas. El trazado captura el estado de la CPU antes de ejecutar cada instrucci√≥n, incluyendo:
                </p>
                <ul>
                    <li>Contador de instrucci√≥n (0-199)</li>
                    <li>Program Counter (PC) actual</li>
                    <li>Opcode que se va a ejecutar</li>
                    <li>Estado de todos los registros principales (AF, BC, DE, HL, SP)</li>
                </ul>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code>: Agregado sistema de trazado con variables est√°ticas para controlar el l√≠mite de instrucciones.</li>
                </ul>

                <h3>C√≥digo implementado</h3>
                <p>
                    El trazado se implementa justo antes del fetch del opcode, para capturar el PC antes de que se modifique:
                </p>
                <pre><code>// --- TRAZA DE CPU (Step 0205) ---
// Variables est√°ticas para el control de la traza
static int debug_trace_counter = 0;
static const int DEBUG_TRACE_LIMIT = 200;

// Imprimir las primeras N instrucciones para identificar el bucle de arranque
if (debug_trace_counter < DEBUG_TRACE_LIMIT) {
    uint8_t opcode_preview = mmu_->read(regs_->pc);
    printf("[CPU TRACE %03d] PC: 0x%04X | Opcode: 0x%02X | AF: 0x%04X | BC: 0x%04X | DE: 0x%04X | HL: 0x%04X | SP: 0x%04X\n", 
           debug_trace_counter, regs_->pc, opcode_preview, regs_->af, regs_->get_bc(), regs_->get_de(), regs_->get_hl(), regs_->sp);
    debug_trace_counter++;
}
// --------------------------------</code></pre>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>L√≠mite de 200 instrucciones:</strong> Suficiente para capturar varios ciclos de un bucle repetitivo sin inundar la consola.</li>
                    <li><strong>Variables est√°ticas:</strong> Permiten mantener el estado del contador entre llamadas a <code>step()</code> sin necesidad de modificar la interfaz de la clase.</li>
                    <li><strong>Lectura previa del opcode:</strong> Leemos el opcode directamente de memoria antes de llamar a <code>fetch_byte()</code> para no modificar el PC antes de imprimir el estado.</li>
                    <li><strong>Inclusi√≥n de todos los registros:</strong> El estado completo de los registros permite identificar qu√© valores est√° comparando el bucle.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Agregado sistema de trazado con <code>#include &lt;cstdio&gt;</code> y variables est√°ticas de control.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    Para verificar el trazado:
                </p>
                <ol>
                    <li><strong>Recompilar el m√≥dulo C++:</strong> Ejecutar <code>.\rebuild_cpp.ps1</code> para compilar los cambios.</li>
                    <li><strong>Ejecutar el emulador:</strong> Ejecutar <code>python main.py roms/tetris.gb &gt; cpu_trace.log</code> para redirigir la salida a un archivo.</li>
                    <li><strong>Analizar la salida:</strong> Buscar patrones repetitivos en el log que indiquen el bucle infinito.</li>
                </ol>
                <p>
                    <strong>Validaci√≥n de m√≥dulo compilado C++:</strong> El trazado se ejecuta dentro del c√≥digo C++ compilado, garantizando que capturamos el flujo de ejecuci√≥n real de la CPU emulada.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set</a></li>
                    <li>Implementaci√≥n basada en conocimiento general de arquitectura LR35902 y t√©cnicas de debugging de emuladores.</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>An√°lisis de flujo de control:</strong> Los bucles infinitos en emulaci√≥n suelen ser causados por saltos condicionales que nunca se cumplen, esperando una condici√≥n de hardware que no se est√° emulando correctamente.</li>
                        <li><strong>Trazado de instrucciones:</strong> Capturar el estado de la CPU antes de cada instrucci√≥n permite identificar patrones repetitivos que revelan bucles de espera.</li>
                        <li><strong>Limitaci√≥n de salida:</strong> Es cr√≠tico limitar la cantidad de trazas para evitar saturar la consola y colgar el terminal, especialmente en bucles infinitos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Patr√≥n del bucle:</strong> Una vez ejecutado el trazado, necesitamos analizar la salida para identificar qu√© instrucciones se repiten y qu√© condici√≥n est√°n esperando.</li>
                        <li><strong>Causa ra√≠z:</strong> Despu√©s de identificar el bucle, necesitamos determinar qu√© componente de hardware no est√° funcionando correctamente (Timer, PPU, Joypad, etc.).</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        Asumimos que el bucle es causado por una condici√≥n de hardware no cumplida, no por un error en la implementaci√≥n de las instrucciones. El trazado nos permitir√° confirmar o refutar esta hip√≥tesis.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador con el trazado activado y analizar la salida.</li>
                    <li>[ ] Identificar el patr√≥n repetitivo en las primeras 200 instrucciones.</li>
                    <li>[ ] Determinar qu√© condici√≥n de hardware est√° esperando el bucle.</li>
                    <li>[ ] Implementar la correcci√≥n del componente de hardware faltante o incorrecto.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

