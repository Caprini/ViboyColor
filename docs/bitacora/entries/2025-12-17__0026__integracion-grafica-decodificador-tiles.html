<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integración Gráfica y Decodificador de Tiles - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Integración Gráfica y Decodificador de Tiles</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-17
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0026
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-17__0025__despachador-interrupciones.html">Anterior</a></li>
                    <li><a href="2025-12-17__0027__completar-inc-dec-8bits.html">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    ¡Hito visual histórico! Se integró Pygame para visualizar gráficos y se implementó el decodificador de tiles en formato 2bpp (2 bits por píxel) de la Game Boy. Ahora el emulador puede "ver" y mostrar el contenido de la VRAM, decodificando los gráficos que la CPU escribe en memoria. La implementación incluye la función <code>decode_tile_line()</code> que convierte dos bytes en 8 píxeles con colores 0-3, y la clase <code>Renderer</code> que inicializa Pygame y proporciona un modo debug para visualizar todos los tiles de la VRAM en una rejilla. El sistema se integra con el bucle principal, renderizando cuando se detecta V-Blank.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    La Game Boy no almacena imágenes completas (bitmaps) en memoria. En su lugar, usa un sistema de <strong>tiles</strong> (baldosas) de 8x8 píxeles que se combinan para formar fondos y sprites.
                </p>
                
                <h3>VRAM (Video RAM)</h3>
                <p>
                    La memoria gráfica se encuentra en el rango <code>0x8000-0x9FFF</code> (8KB = 8192 bytes). Esta área contiene los datos de los tiles y más adelante contendrá también mapas de fondo y sprites.
                </p>

                <h3>Formato 2bpp (2 Bits Per Pixel)</h3>
                <p>
                    Cada tile ocupa <strong>16 bytes</strong> (2 bytes por línea × 8 líneas). El formato 2bpp permite representar 4 colores diferentes por píxel (00, 01, 10, 11).
                </p>
                <p>
                    Para cada línea horizontal de 8 píxeles:
                </p>
                <ul>
                    <li><strong>Byte 1 (LSB)</strong>: Contiene los bits menos significativos (bajos) de cada píxel</li>
                    <li><strong>Byte 2 (MSB)</strong>: Contiene los bits más significativos (altos) de cada píxel</li>
                </ul>
                <p>
                    El color de cada píxel se calcula combinando los bits correspondientes:
                </p>
                <pre><code>color = (MSB << 1) | LSB</code></pre>
                <p>
                    Esto produce valores de 0 a 3:
                </p>
                <ul>
                    <li><strong>Color 0 (0b00)</strong>: LSB=0, MSB=0 → Blanco (transparente en sprites)</li>
                    <li><strong>Color 1 (0b01)</strong>: LSB=1, MSB=0 → Gris claro</li>
                    <li><strong>Color 2 (0b10)</strong>: LSB=0, MSB=1 → Gris oscuro</li>
                    <li><strong>Color 3 (0b11)</strong>: LSB=1, MSB=1 → Negro</li>
                </ul>

                <h3>Ejemplo de Decodificación</h3>
                <p>
                    Para una línea con:
                </p>
                <ul>
                    <li>Byte 1 (LSB): <code>0x3C</code> = <code>00111100</code></li>
                    <li>Byte 2 (MSB): <code>0x7E</code> = <code>01111110</code></li>
                </ul>
                <p>
                    El píxel más a la izquierda (bit 7):
                </p>
                <ul>
                    <li>LSB = bit 7 de Byte 1 = 0</li>
                    <li>MSB = bit 7 de Byte 2 = 0</li>
                    <li>Color = (0 << 1) | 0 = 0</li>
                </ul>
                <p>
                    El segundo píxel (bit 6):
                </p>
                <ul>
                    <li>LSB = bit 6 de Byte 1 = 0</li>
                    <li>MSB = bit 6 de Byte 2 = 1</li>
                    <li>Color = (1 << 1) | 0 = 2</li>
                </ul>

                <p>
                    <strong>Fuente:</strong> Pan Docs - Tile Data, 2bpp Format
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementó un sistema completo de renderizado gráfico usando Pygame, con un modo debug que visualiza todos los tiles de la VRAM.
                </p>
                
                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><strong><code>src/gpu/renderer.py</code></strong>: Nuevo módulo con la clase <code>Renderer</code> y la función helper <code>decode_tile_line()</code></li>
                    <li><strong><code>src/viboy.py</code></strong>: Integración del renderer en el bucle principal, manejo de eventos Pygame, y renderizado en V-Blank</li>
                    <li><strong><code>src/gpu/__init__.py</code></strong>: Exportación condicional de <code>Renderer</code> (solo si pygame está disponible)</li>
                    <li><strong><code>tests/test_gpu_tile_decoder.py</code></strong>: Suite completa de tests TDD para el decodificador 2bpp</li>
                </ul>

                <h3>Función <code>decode_tile_line()</code></h3>
                <p>
                    Decodifica una línea de 8 píxeles a partir de dos bytes:
                </p>
                <ul>
                    <li>Recorre cada bit de izquierda a derecha (bit 7 a bit 0)</li>
                    <li>Extrae el bit bajo del byte1 y el bit alto del byte2</li>
                    <li>Calcula el color como: <code>(bit_high << 1) | bit_low</code></li>
                    <li>Devuelve una lista de 8 enteros (0-3) representando los colores</li>
                </ul>

                <h3>Clase <code>Renderer</code></h3>
                <p>
                    Responsabilidades:
                </p>
                <ul>
                    <li><strong>Inicialización</strong>: Configura Pygame, crea ventana escalada (por defecto 3x, resultando en 480×432 píxeles)</li>
                    <li><strong><code>render_vram_debug()</code></strong>: Decodifica todos los tiles de VRAM y los dibuja en una rejilla de 32×16 tiles</li>
                    <li><strong><code>_draw_tile()</code></strong>: Dibuja un tile individual de 8×8 píxeles usando la paleta de grises</li>
                    <li><strong><code>handle_events()</code></strong>: Maneja eventos de Pygame (especialmente cierre de ventana)</li>
                    <li><strong><code>quit()</code></strong>: Cierra Pygame limpiamente</li>
                </ul>

                <h3>Integración en <code>Viboy</code></h3>
                <p>
                    El renderer se inicializa opcionalmente (si pygame está disponible) tanto en <code>__init__()</code> como en <code>load_cartridge()</code>. En el bucle principal:
                </p>
                <ul>
                    <li>Se manejan eventos de Pygame antes de cada ciclo</li>
                    <li>Se detecta el inicio de V-Blank (LY >= 144) mediante transición de estado</li>
                    <li>Cuando se entra en V-Blank, se llama a <code>render_vram_debug()</code> para actualizar la pantalla</li>
                    <li>En el bloque <code>finally</code>, se cierra el renderer limpiamente</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <ul>
                    <li><strong>Paleta de grises fija</strong>: Por ahora usamos una paleta simple (Blanco, Gris claro, Gris oscuro, Negro) para visualización. Más adelante se implementará la paleta real (BGP, OBP0, OBP1)</li>
                    <li><strong>Modo debug primero</strong>: Implementamos primero <code>render_vram_debug()</code> para verificar que la decodificación funciona. El renderizado completo del juego vendrá después</li>
                    <li><strong>Renderizado en V-Blank</strong>: Renderizamos solo cuando detectamos V-Blank para no saturar el sistema con actualizaciones constantes</li>
                    <li><strong>Importación condicional</strong>: El renderer solo se carga si pygame está disponible, permitiendo que el emulador funcione sin gráficos</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Nuevo módulo con clase Renderer y función decode_tile_line()</li>
                    <li><code>src/gpu/__init__.py</code> - Exportación condicional de Renderer</li>
                    <li><code>src/viboy.py</code> - Integración del renderer, manejo de eventos Pygame, y renderizado en V-Blank</li>
                    <li><code>tests/test_gpu_tile_decoder.py</code> - Nuevo archivo con 6 tests unitarios para decode_tile_line()</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se implementó una suite completa de tests TDD para validar la decodificación 2bpp.
                </p>

                <h3>Tests unitarios</h3>
                <p>
                    <strong>Comando ejecutado:</strong> <code>python3 -m pytest tests/test_gpu_tile_decoder.py -v</code>
                </p>
                <p>
                    <strong>Entorno:</strong> macOS (darwin 21.6.0), Python 3.9.6, pytest 8.4.2
                </p>
                <p>
                    <strong>Resultado:</strong> 6 passed in 0.11s
                </p>
                
                <p>
                    <strong>Qué valida:</strong>
                </p>
                <ul>
                    <li><strong>Decodificación básica</strong>: Verifica que una línea con bytes 0x3C y 0x7E produce los colores correctos [0, 2, 3, 3, 3, 3, 2, 0]</li>
                    <li><strong>Todos los colores</strong>: Valida que podemos obtener los 4 valores posibles (0, 1, 2, 3) usando diferentes combinaciones de bytes</li>
                    <li><strong>Colores específicos</strong>: Tests separados para Color 0 (ambos bytes 0x00), Color 1 (LSB=0xFF, MSB=0x00), Color 3 (ambos bytes 0xFF)</li>
                    <li><strong>Patrones complejos</strong>: Verifica un patrón alternado (0xAA y 0x55) que produce una secuencia [1, 2, 1, 2, 1, 2, 1, 2]</li>
                </ul>

                <h3>Código del test esencial</h3>
                <pre><code>def test_decode_2bpp_line_basic(self) -> None:
    """Test básico: decodificar una línea de tile 2bpp"""
    byte1 = 0x3C  # 00111100 (LSB)
    byte2 = 0x7E  # 01111110 (MSB)
    
    result = decode_tile_line(byte1, byte2)
    
    assert len(result) == 8
    assert result[0] == 0  # Bit 7: LSB=0, MSB=0 -> 0
    assert result[1] == 2  # Bit 6: LSB=0, MSB=1 -> 2
    assert result[2] == 3  # Bit 5: LSB=1, MSB=1 -> 3
    # ... más aserciones</code></pre>

                <p>
                    <strong>Ruta completa:</strong> <code>tests/test_gpu_tile_decoder.py</code>
                </p>
                <p>
                    Estos tests demuestran que la decodificación 2bpp funciona correctamente según la especificación: el byte1 contiene los bits menos significativos, el byte2 contiene los bits más significativos, y el color se calcula como <code>(MSB << 1) | LSB</code>.
                </p>

                <h3>Prueba con ROM de Tetris</h3>
                <p>
                    <strong>ROM:</strong> Tetris DX (ROM aportada por el usuario, no distribuida)</p>
                <p>
                    <strong>Modo de ejecución:</strong> UI (Pygame), escala 3x (480×432 píxeles)</p>
                <p>
                    <strong>Criterio de éxito:</strong> El renderer debería inicializarse correctamente y mostrar la ventana de Pygame cuando se detecte V-Blank.</p>
                <p>
                    <strong>Observación:</strong> 
                </p>
                <ul>
                    <li>Pygame se instaló correctamente (pygame-ce 2.5.6)</li>
                    <li>El renderer se inicializa sin errores: <code>INFO: Renderer inicializado: 480x432 (scale=3)</code></li>
                    <li>El emulador ejecuta 70,118 ciclos antes de detenerse</li>
                    <li>El juego se detiene en el opcode <strong>0x1D (DEC E)</strong> que aún no está implementado</li>
                    <li>La ventana de Pygame no se muestra porque el juego se detiene antes de llegar al primer V-Blank (necesita ejecutar más instrucciones para llegar a LY=144)</li>
                </ul>
                <p>
                    <strong>Resultado:</strong> <code>draft</code> - El renderer funciona correctamente (verificado con test independiente), pero el juego necesita opcodes adicionales (INC/DEC de 8 bits) para avanzar hasta el primer V-Blank y renderizar tiles reales.</p>
                <p>
                    <strong>Notas legales:</strong> La ROM de Tetris DX es aportada por el usuario para pruebas locales, no se distribuye ni se incluye en el repositorio.</p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li><strong>Pan Docs:</strong> Tile Data, 2bpp Format - Especificación del formato de tiles de 8×8 píxeles con 2 bits por píxel</li>
                    <li><strong>Pan Docs:</strong> Video RAM (VRAM) - Ubicación y estructura de la memoria gráfica (0x8000-0x9FFF)</li>
                    <li><strong>Pan Docs:</strong> LCD Timing, V-Blank - Cuándo es seguro actualizar la pantalla</li>
                </ul>
                <p>
                    <em>Nota: La implementación sigue estrictamente la documentación técnica. No se consultó código de otros emuladores.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Formato 2bpp:</strong> Entiendo que cada píxel se codifica con 2 bits, permitiendo 4 colores. Los bits están divididos en dos bytes: byte1 (LSB) y byte2 (MSB), y el color se calcula como <code>(MSB << 1) | LSB</code>.</li>
                        <li><strong>Estructura de tiles:</strong> Cada tile de 8×8 píxeles ocupa exactamente 16 bytes (2 bytes por línea). La VRAM puede almacenar hasta 512 tiles (8192 bytes / 16 bytes por tile).</li>
                        <li><strong>Renderizado en V-Blank:</strong> Es seguro actualizar la pantalla solo durante V-Blank (LY >= 144), porque durante el renderizado de líneas visibles, la PPU está leyendo activamente la VRAM.</li>
                        <li><strong>Paleta de colores:</strong> Los valores 0-3 son índices de color que se mapean a colores reales mediante registros de paleta (BGP, OBP0, OBP1). Por ahora usamos una paleta de grises fija para debug.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Renderizado con juego real:</strong> El renderer está funcional pero no se ha podido verificar con datos reales de Tetris porque el juego se detiene en opcode 0x1D (DEC E) antes de llegar al primer V-Blank. Falta implementar los opcodes INC/DEC de 8 bits faltantes para que el juego pueda avanzar.</li>
                        <li><strong>Paleta real:</strong> Falta implementar la lectura de los registros BGP, OBP0 y OBP1 para mapear correctamente los índices 0-3 a colores reales (que pueden ser diferentes para fondo y sprites).</li>
                        <li><strong>Renderizado completo:</strong> Este paso solo muestra los tiles en una rejilla. Falta implementar el renderizado real de la pantalla usando mapas de fondo (Tile Maps), scroll, ventana, y sprites.</li>
                        <li><strong>OAM (Object Attribute Memory):</strong> Falta entender completamente cómo se organizan los sprites en OAM y cómo se renderizan sobre el fondo.</li>
                        <li><strong>Prioridad y transparencia:</strong> Falta implementar las reglas de prioridad entre fondo y sprites, y cómo el Color 0 es transparente en sprites.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Renderizado en cada V-Blank:</strong> Por ahora renderizamos cada vez que detectamos el inicio de V-Blank. Esto puede ser demasiado frecuente y podría afectar el rendimiento. Más adelante deberíamos considerar renderizar solo cuando el contenido de VRAM cambia significativamente, o limitar la frecuencia de actualización.
                    </p>
                    <p>
                        <strong>Modo debug:</strong> La visualización actual en modo debug muestra todos los tiles en una rejilla, no el renderizado real del juego. Esto es intencional para verificar que la decodificación funciona, pero no muestra cómo se ve realmente el juego.
                    </p>
                    <p>
                        <strong>Opcodes faltantes:</strong> El juego se detiene en DEC E (0x1D) antes de llegar a renderizar. Esto confirma que necesitamos implementar los opcodes INC/DEC de 8 bits restantes (INC D/E/H/L y DEC D/E/H/L) para que los juegos puedan ejecutarse completamente. Estos opcodes siguen el mismo patrón que los ya implementados (DEC B, DEC C, DEC A), por lo que deberían ser rápidos de añadir.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Implementar lectura de registros de paleta (BGP, OBP0, OBP1) para mapear índices de color a colores reales</li>
                    <li>[ ] Implementar renderizado de fondo usando Tile Maps (0x9800-0x9BFF y 0x9C00-0x9FFF)</li>
                    <li>[ ] Implementar scroll del fondo (registros SCX y SCY)</li>
                    <li>[ ] Implementar renderizado de ventana (Window) usando registros WX y WY</li>
                    <li>[ ] Implementar renderizado de sprites desde OAM (0xFE00-0xFE9F)</li>
                    <li>[ ] Implementar prioridades y transparencia (Color 0 es transparente en sprites)</li>
                    <li>[ ] Optimizar el renderizado para que solo actualice cuando sea necesario</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

