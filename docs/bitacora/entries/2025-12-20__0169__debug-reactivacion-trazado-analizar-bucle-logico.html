<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Re-activaci贸n del Trazado para Analizar Bucle L贸gico - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Re-activaci贸n del Trazado para Analizar Bucle L贸gico</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0169
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0168__debug-instrumentar-default-case-opcodes-desconocidos.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El diagn贸stico del Step 0168 confirm贸 que la CPU no est谩 encontrando opcodes desconocidos. El deadlock de <code>LY=0</code> persiste porque la CPU est谩 atrapada en un bucle infinito compuesto por instrucciones <strong>v谩lidas</strong>. Se revirti贸 la estrategia "fail-fast" y se re-activ贸 el sistema de trazado disparado (triggered) con un trigger en <code>0x02A0</code> y un l铆mite de 200 instrucciones para capturar y analizar el bucle l贸gico en el que est谩 atrapada la CPU.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: Depuraci贸n de L贸gica vs. Opcodes</h2>
                <p>
                    Existen dos tipos principales de errores que causan <code>deadlocks</code> en un emulador en desarrollo:
                </p>
                <ol>
                    <li>
                        <strong>Error de Opcode Faltante:</strong> La CPU encuentra una instrucci贸n que no conoce. Nuestra estrategia "fail-fast" del Step 0168 es perfecta para esto, ya que termina la ejecuci贸n inmediatamente y reporta el opcode desconocido.
                    </li>
                    <li>
                        <strong>Error de L贸gica de Bucle:</strong> La CPU ejecuta un bucle (ej: <code>DEC B -> JR NZ</code>) pero la condici贸n de salida nunca se cumple (ej. el flag <code>Z</code> nunca se activa). Esto requiere observar el estado de los registros y flags <em>dentro</em> del bucle para entender por qu茅 la condici贸n nunca se cumple.
                    </li>
                </ol>
                <p>
                    El diagn贸stico del Step 0168 descart贸 el primer tipo de error: el hecho de que el bucle principal de Python siga ejecut谩ndose (mostrando los mensajes <code> Heartbeat</code>) y que nunca veamos el mensaje fatal del <code>default</code> case confirma que <strong>todos los opcodes que la CPU est谩 ejecutando ya est谩n implementados</strong>.
                </p>
                <p>
                    Por lo tanto, el problema es del segundo tipo: un bucle l贸gico infinito. La ROM de Tetris ejecuta varias rutinas de limpieza de memoria en secuencia. Hemos arreglado el bucle <code>DEC B</code> del Step 0165, pero es casi seguro que la ROM ha entrado inmediatamente en otro bucle similar, por ejemplo, uno que usa <code>DEC C</code> o <code>DEC DE</code>.
                </p>
                <p>
                    Para analizar este tipo de error, necesitamos una herramienta de observaci贸n (una traza) en lugar de un detector de minas (fail-fast). El trazado disparado nos permite capturar el patr贸n de opcodes que se ejecutan repetidamente, permiti茅ndonos identificar el bucle y deducir qu茅 condici贸n de salida no se est谩 cumpliendo.
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se modific贸 <code>src/core/cpp/CPU.cpp</code> para revertir el comportamiento "fail-fast" del Step 0168 y re-activar el sistema de trazado disparado con una configuraci贸n optimizada para capturar bucles l贸gicos.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code>: Revertido el caso <code>default</code> del switch para devolver 0 ciclos silenciosamente, y ajustado el sistema de trazado disparado.</li>
                </ul>

                <h3>Cambios realizados</h3>
                <p>
                    <strong>1. Ajuste del Trigger y L铆mite de Trazado:</strong>
                </p>
                <pre><code>// Variables est谩ticas para logging de diagn贸stico con sistema "disparado" (triggered)
// El trigger se activa despu茅s de las rutinas de limpieza de memoria (0x02A0)
// para capturar el c贸digo cr铆tico de configuraci贸n de hardware y bucles l贸gicos
static const uint16_t DEBUG_TRIGGER_PC = 0x02A0; // Direcci贸n de activaci贸n del trazado (despu茅s de limpieza)
static bool debug_trace_activated = false;      // Bandera de activaci贸n
static int debug_instruction_counter = 0;       // Contador post-activaci贸n
static const int DEBUG_INSTRUCTION_LIMIT = 200;  // L铆mite post-activaci贸n (Step 0169: aumentado para capturar bucles)</code></pre>
                <p>
                    El trigger se cambi贸 de <code>0x0300</code> a <code>0x02A0</code> para capturar el c贸digo que se ejecuta justo despu茅s del primer bucle de limpieza conocido. El l铆mite se aument贸 de 100 a 200 instrucciones para capturar bucles completos.
                </p>
                <p>
                    <strong>2. Reversi贸n del Default Case:</strong>
                </p>
                <pre><code>default:
    // --- Step 0169: Revertido a comportamiento silencioso ---
    // El diagn贸stico del Step 0168 confirm贸 que no hay opcodes desconocidos.
    // El deadlock es causado por un bucle l贸gico con instrucciones v谩lidas.
    // Volvemos a devolver 0 ciclos para permitir que el trazado capture el bucle.
    cycles_ += 0;
    return 0;</code></pre>
                <p>
                    Se elimin贸 el <code>exit(1)</code> y se volvi贸 a devolver 0 ciclos silenciosamente. Esto permite que el emulador contin煤e ejecut谩ndose y que el trazado capture el bucle l贸gico.
                </p>
                <p>
                    <strong>3. Eliminaci贸n de Include Innecesario:</strong>
                </p>
                <p>
                    Se elimin贸 el <code>#include &lt;cstdlib&gt;</code> ya que ya no se usa <code>exit()</code>.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Modificado el sistema de trazado disparado (trigger ajustado a 0x02A0, l铆mite aumentado a 200) y revertido el default case a comportamiento silencioso.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    La verificaci贸n se realizar谩 ejecutando el emulador y observando la salida del trazado:
                </p>
                <ul>
                    <li><strong>Comando ejecutado:</strong> <code>python main.py roms/tetris.gb</code></li>
                    <li><strong>Resultado esperado:</strong> El emulador deber铆a ejecutarse en silencio hasta que el PC alcance <code>0x02A0</code>, momento en el que deber铆a aparecer el mensaje <code>--- [CPU TRACE TRIGGERED at PC: 0x02A0] ---</code> seguido de 200 l铆neas de traza mostrando el patr贸n de opcodes del bucle l贸gico.</li>
                    <li><strong>Validaci贸n Nativa:</strong> Validaci贸n de m贸dulo compilado C++ con trazado activado.</li>
                </ul>
                <p>
                    <strong>Nota:</strong> Este Step no incluye tests unitarios porque es una modificaci贸n de depuraci贸n temporal. La validaci贸n se realiza mediante observaci贸n directa de la traza de ejecuci贸n.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Implementaci贸n basada en conocimiento general de t茅cnicas de depuraci贸n de emuladores y an谩lisis de bucles infinitos.</li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set</a> - Para referencia de instrucciones v谩lidas.</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Diferencia entre Error de Opcode y Error de L贸gica:</strong> Un error de opcode se detecta inmediatamente cuando la CPU intenta ejecutar una instrucci贸n desconocida. Un error de l贸gica requiere observar el comportamiento repetitivo de instrucciones v谩lidas para identificar por qu茅 una condici贸n nunca se cumple.</li>
                        <li><strong>Estrategias de Depuraci贸n Complementarias:</strong> "Fail-fast" es excelente para detectar opcodes faltantes, pero in煤til para analizar bucles l贸gicos. El trazado disparado es la herramienta correcta para observar patrones repetitivos de ejecuci贸n.</li>
                        <li><strong>El Diagn贸stico del Step 0168 fue Exitoso:</strong> Aunque no resolvi贸 el deadlock, confirm贸 que no hay opcodes desconocidos, lo cual es informaci贸n valiosa que nos permite enfocar la depuraci贸n en la l贸gica de bucles.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Patr贸n del Bucle:</strong> Necesitamos ejecutar el emulador y analizar la traza para identificar el patr贸n exacto de opcodes que se repite, lo cual nos permitir谩 deducir qu茅 instrucci贸n o condici贸n est谩 causando el bucle infinito.</li>
                        <li><strong>Condici贸n de Salida:</strong> Una vez identificado el bucle, necesitamos analizar por qu茅 la condici贸n de salida (ej. flag <code>Z</code> en <code>JR NZ</code>) nunca se cumple.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis Principal:</strong> El bucle l贸gico es similar al del Step 0165 (un bucle de decremento que nunca termina), pero probablemente usa un registro diferente (ej. <code>DEC C</code> en lugar de <code>DEC B</code>) o una instrucci贸n de 16 bits (ej. <code>DEC DE</code>). La traza nos confirmar谩 o refutar谩 esta hip贸tesis.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y capturar la traza del bucle l贸gico</li>
                    <li>[ ] Analizar el patr贸n de opcodes repetitivos en la traza</li>
                    <li>[ ] Identificar la instrucci贸n o condici贸n que causa el bucle infinito</li>
                    <li>[ ] Implementar la correcci贸n necesaria (probablemente similar a la del Step 0165)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

