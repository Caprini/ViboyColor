<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Instrumentaci칩n Detallada de render_scanline - Viboy Color Bit치cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>丘멆잺 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c칩digo de otros emuladores. Implementaci칩n basada 칰nicamente en documentaci칩n t칠cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Instrumentaci칩n Detallada de render_scanline</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0139
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">游댌 DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0138__fix-bug-renderizado-signed-addressing-expansion-alu.html">Anterior (0138)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se a침adi칩 instrumentaci칩n de depuraci칩n detallada al m칠todo <code>render_scanline()</code> de la PPU en C++ para identificar el origen exacto del <code>Segmentation Fault</code> que ocurre al ejecutar el emulador con la ROM de Tetris. A pesar de que el test unitario para el modo "signed addressing" pasa correctamente, la ejecuci칩n real sigue crasheando, lo que indica que existe otro caso de uso no cubierto por el test que provoca un acceso a memoria inv치lido.
                </p>
                <p>
                    La instrumentaci칩n a침ade logs usando <code>printf</code> para capturar los valores cr칤ticos (l칤nea de escaneo, scroll, direcciones de tilemap, tile IDs, direcciones calculadas) justo antes de intentar leer la memoria de los tiles. Estos logs nos permitir치n identificar exactamente qu칠 valores causan el crash.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy, la PPU renderiza cada l칤nea de escaneo (scanline) accediendo a dos 치reas principales de memoria: el <strong>Tilemap</strong> (en 0x9800-0x9BFF o 0x9C00-0x9FFF) y la <strong>Tile Data</strong> (en 0x8000-0x97FF). El proceso de renderizado para cada p칤xel de la l칤nea implica:
                </p>
                <ol>
                    <li>Calcular la posici칩n en el tilemap usando scroll (SCX, SCY)</li>
                    <li>Leer el Tile ID desde el tilemap</li>
                    <li>Calcular la direcci칩n del tile en VRAM seg칰n el modo de direccionamiento (signed/unsigned)</li>
                    <li>Leer los datos del tile (2 bytes por l칤nea)</li>
                    <li>Decodificar el p칤xel y escribir en el framebuffer</li>
                </ol>
                <p>
                    Si cualquiera de estas direcciones calculadas est치 fuera del rango v치lido de VRAM (0x8000-0x9FFF), el acceso a memoria puede causar un <code>Segmentation Fault</code>. Aunque a침adimos validaciones en el Step 0138, el crash sugiere que hay alg칰n caso espec칤fico que no est치 siendo capturado por estas validaciones o que ocurre antes de llegar a ellas.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - Background, Tile Data, Tile Maps
                </p>
            </section>

            <!-- 3. Implementaci칩n -->
            <section id="implementacion">
                <h2>Implementaci칩n</h2>
                <p>
                    Se a침adi칩 instrumentaci칩n de depuraci칩n usando <code>printf</code> (en lugar de <code>std::cout</code>) porque es m치s seguro para depurar crashes, ya que no depende de buffers que pueden no vaciarse antes de un crash.
                </p>
                
                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code>: A침adidos logs detallados en <code>render_scanline()</code></li>
                </ul>

                <h3>Decisiones de dise침o</h3>
                <ul>
                    <li><strong>Variable est치tica para control de impresi칩n:</strong> Se usa una variable est치tica global <code>debug_printed</code> para imprimir logs solo una vez (durante la primera l칤nea de escaneo) y evitar inundar la consola.</li>
                    <li><strong>Logs selectivos:</strong> Se imprimen los primeros 20 p칤xeles de la primera l칤nea para capturar informaci칩n relevante sin saturar la salida.</li>
                    <li><strong>Logs de advertencia:</strong> Se a침adieron logs especiales cuando se detectan direcciones fuera de rango, ya que estos son casos sospechosos que podr칤an causar el crash.</li>
                    <li><strong>printf en lugar de std::cout:</strong> <code>printf</code> es m치s directo y seguro para depuraci칩n de crashes, ya que escribe directamente al stream sin buffers intermedios.</li>
                </ul>

                <h3>C칩digo a침adido</h3>
                <pre><code>// Al principio del archivo
#include &lt;cstdio&gt;

// Variable est치tica para controlar la impresi칩n
static bool debug_printed = false;

// En render_scanline(), al inicio
if (!debug_printed) {
    printf("[PPU DEBUG] render_scanline(ly=%d) | scx=%d, scy=%d | tile_map_base=0x%04X | signed_addressing=%d\n",
           ly_, scx, scy, tile_map_base, signed_addressing ? 1 : 0);
}

// Dentro del bucle de renderizado, para los primeros 20 p칤xeles
if (!debug_printed && x &lt; 20) {
    printf("  [PIXEL x=%d] map_x=%d, map_y=%d | tile_map_addr=0x%04X, tile_id=%d, tile_addr=0x%04X\n",
           x, map_x, map_y, tile_map_addr, tile_id, tile_addr);
}

// Al final del m칠todo
debug_printed = true;</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - A침adidos logs de depuraci칩n en <code>render_scanline()</code> para capturar valores cr칤ticos antes de acceder a memoria</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci칩n -->
            <section id="tests">
                <h2>Tests y Verificaci칩n</h2>
                <p>
                    <strong>Estado actual:</strong> Esta es una entrada de depuraci칩n. El c칩digo se ha modificado para a침adir instrumentaci칩n, pero a칰n no se ha recompilado ni ejecutado.
                </p>
                <p>
                    <strong>Plan de verificaci칩n:</strong>
                </p>
                <ol>
                    <li><strong>Recompilaci칩n:</strong> Ejecutar <code>.\rebuild_cpp.ps1</code> para recompilar el m칩dulo C++ con los nuevos logs</li>
                    <li><strong>Ejecuci칩n con ROM:</strong> Ejecutar <code>python main.py roms/tetris.gb</code> y capturar la salida de los logs antes del crash</li>
                    <li><strong>An치lisis:</strong> Analizar la 칰ltima l칤nea impresa antes del <code>Segmentation Fault</code> para identificar los valores exactos que causan el problema</li>
                </ol>
                <p>
                    <strong>Resultado esperado:</strong> Los logs deber칤an mostrar los valores de <code>ly</code>, <code>scx</code>, <code>scy</code>, <code>tile_map_addr</code>, <code>tile_id</code>, y <code>tile_addr</code> para los primeros p칤xeles. La 칰ltima l칤nea impresa antes del crash indicar치 qu칠 valores est치n causando el acceso a memoria inv치lido.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Background and Window</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Tile Data</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Tile Maps</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Depuraci칩n de crashes:</strong> Cuando un programa crashea con un Segmentation Fault, la instrumentaci칩n con logs es una herramienta esencial para identificar el punto exacto donde ocurre el problema. Los logs deben capturar los valores de las variables cr칤ticas justo antes de la operaci칩n que causa el crash.</li>
                        <li><strong>printf vs std::cout:</strong> Para depuraci칩n de crashes, <code>printf</code> es preferible porque escribe directamente al stream sin buffers intermedios que pueden no vaciarse antes del crash.</li>
                        <li><strong>Validaci칩n de direcciones:</strong> Aunque a침adimos validaciones en el Step 0138, el crash persiste, lo que sugiere que hay un caso espec칤fico no cubierto o que el crash ocurre en un lugar diferente al esperado.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Valores exactos del crash:</strong> Necesitamos ejecutar el emulador con la instrumentaci칩n para ver los valores exactos que causan el Segmentation Fault.</li>
                        <li><strong>Ubicaci칩n del crash:</strong> Aunque sospechamos que ocurre en <code>render_scanline()</code>, los logs nos confirmar치n si es as칤 o si ocurre en otro lugar (por ejemplo, en la MMU al leer).</li>
                        <li><strong>Casos no cubiertos:</strong> Una vez tengamos los valores del crash, podremos identificar qu칠 casos espec칤ficos no est치n siendo manejados correctamente por nuestras validaciones.</li>
                    </ul>

                    <h3>Hip칩tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip칩tesis principal:</strong> El crash ocurre durante el renderizado de una l칤nea espec칤fica cuando se intenta acceder a una direcci칩n de VRAM fuera de los l칤mites v치lidos (0x8000-0x9FFF). Los logs nos permitir치n confirmar esta hip칩tesis y ver exactamente qu칠 valores causan el problema.
                    </p>
                    <p>
                        <strong>Suposici칩n:</strong> El test unitario pasa porque crea una situaci칩n ideal y predecible, mientras que la ROM real usa combinaciones de valores (tile IDs, scroll, etc.) que exponen bugs en casos l칤mite que no est치n cubiertos por el test.
                    </p>
                </div>
            </section>

            <!-- 8. Pr칩ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr칩ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m칩dulo C++ con los nuevos logs: <code>.\rebuild_cpp.ps1</code></li>
                    <li>[ ] Ejecutar el emulador con Tetris: <code>python main.py roms/tetris.gb</code></li>
                    <li>[ ] Capturar y analizar la salida de los logs antes del crash</li>
                    <li>[ ] Identificar los valores exactos que causan el Segmentation Fault</li>
                    <li>[ ] Corregir el bug identificado en el siguiente step (0140)</li>
                    <li>[ ] Eliminar los logs de depuraci칩n una vez resuelto el problema (para mejorar el rendimiento)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c칩digo de otros emuladores. Basado 칰nicamente en documentaci칩n t칠cnica.</p>
        </footer>
    </div>
</body>
</html>

