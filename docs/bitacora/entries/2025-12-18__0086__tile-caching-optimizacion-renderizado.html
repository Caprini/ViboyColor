<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile Caching: Optimización del Renderizado - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Tile Caching: Optimización del Renderizado</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0086
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0085__calibracion-precision-batch-size.html">Anterior</a></li>
                    <li><a href="2025-12-18__0087__arquitectura-precision-cgb-v0.0.1.html">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementó Tile Caching en el renderer para optimizar drásticamente el rendimiento del renderizado.
                    En lugar de decodificar 23.040 píxeles píxel a píxel en cada frame usando PixelArray, ahora se cachean
                    los 384 tiles únicos de VRAM (0x8000-0x97FF) como superficies pygame de 8x8 píxeles y se renderizan
                    usando blits rápidos. Esto reduce el trabajo de ~1.3 millones de operaciones por segundo a ~360 blits
                    por frame, permitiendo alcanzar 60 FPS estables sin frame skip.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    La Game Boy tiene 8KB de VRAM (0x8000-0x9FFF) que contiene los datos gráficos en formato 2bpp.
                    Los primeros 6KB (0x8000-0x97FF) contienen 384 tiles únicos de 8x8 píxeles, cada uno ocupando 16 bytes
                    (2 bytes por línea de 8 píxeles). El renderizado tradicional decodifica estos tiles píxel a píxel
                    en cada frame, lo que es extremadamente costoso en Python puro.
                </p>
                <p>
                    <strong>Tile Caching</strong> es una técnica estándar en emulación que aprovecha que los tiles
                    raramente cambian durante la ejecución. En lugar de decodificar cada tile en cada frame, se decodifican
                    una sola vez cuando cambian y se guardan como superficies pre-renderizadas. El renderizado entonces
                    solo necesita hacer blits (copias rápidas) de estas superficies, delegando el trabajo pesado a C (SDL).
                </p>
                <p>
                    Fuente: Pan Docs - VRAM Tile Data, Técnicas de optimización en emulación
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementó un sistema completo de Tile Caching con las siguientes componentes:
                </p>
                
                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><strong>Renderer.tile_cache</strong>: Diccionario que mapea tile_id (0-383) a pygame.Surface de 8x8 píxeles</li>
                    <li><strong>Renderer.tile_dirty</strong>: Lista de 384 flags booleanos que indican qué tiles han cambiado</li>
                    <li><strong>Renderer.bg_buffer</strong>: Superficie de 256x256 píxeles para dibujar el tilemap completo</li>
                    <li><strong>Renderer.update_tile_cache()</strong>: Método que decodifica tiles marcados como dirty y los guarda en caché</li>
                    <li><strong>Renderer.mark_tile_dirty()</strong>: Método llamado desde MMU cuando se escribe en VRAM</li>
                    <li><strong>MMU.set_renderer()</strong>: Método para conectar MMU con Renderer para dirty tracking</li>
                    <li><strong>MMU.write_byte()</strong>: Modificado para marcar tiles como dirty cuando se escribe en 0x8000-0x97FF</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    <strong>1. Rango de caché (0x8000-0x97FF):</strong> Solo se cachean los primeros 384 tiles porque
                    son los más usados para Background y Window. Los tiles en 0x9800-0x9FFF (tilemaps) no se cachean
                    porque son índices, no datos gráficos.
                </p>
                <p>
                    <strong>2. Buffer grande (256x256):</strong> Se dibuja el tilemap completo en bg_buffer y luego
                    se recorta la ventana visible (160x144) usando blit con área de recorte. Esto es más eficiente
                    que calcular offsets para cada tile individualmente.
                </p>
                <p>
                    <strong>3. Dirty tracking:</strong> Los tiles se marcan como dirty cuando la MMU detecta escritura
                    en VRAM. Esto evita decodificar tiles que no han cambiado, maximizando el beneficio de la caché.
                </p>
                <p>
                    <strong>4. Fallback para tiles fuera de caché:</strong> Si un tile está fuera del rango cacheado
                    (raro, pero posible con signed addressing), se decodifica directamente como fallback.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Implementación de Tile Caching: caché, dirty flags, update_tile_cache(), mark_tile_dirty(), y reescritura completa de render_frame() para usar blits</li>
                    <li><code>src/memory/mmu.py</code> - Integración de dirty tracking: set_renderer(), y modificación de write_byte() para marcar tiles dirty</li>
                    <li><code>src/viboy.py</code> - Conexión MMU-Renderer: llamadas a set_renderer() después de crear el Renderer, y ajuste de BATCH_SIZE de 64 a 128 T-Cycles</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Validación de rendimiento:</strong>
                </p>
                <ul>
                    <li><strong>FPS antes:</strong> ~20 FPS con Batch=64, Skip=0 (cuello de botella: PixelArray píxel a píxel)</li>
                    <li><strong>FPS después:</strong> 60 FPS estables con Batch=128, Skip=0 (renderizado por blits)</li>
                    <li><strong>Mejora:</strong> ~3x más rápido, eliminando completamente el cuello de botella del renderizado</li>
                </ul>
                <p>
                    <strong>Validación funcional:</strong>
                </p>
                <ul>
                    <li>Los gráficos se renderizan correctamente (sin artefactos visuales)</li>
                    <li>El scroll (SCX/SCY) funciona correctamente con el nuevo sistema de blits</li>
                    <li>La Window se dibuja correctamente encima del Background</li>
                    <li>Los sprites se renderizan correctamente encima del fondo</li>
                    <li>Los tiles se actualizan correctamente cuando cambian en VRAM (dirty tracking)</li>
                </ul>
                <p>
                    <strong>ROMs de test:</strong>
                </p>
                <ul>
                    <li><strong>Tetris (ROM aportada por el usuario, no distribuida):</strong> Verificado que funciona a 60 FPS sin lag, movimiento suave de piezas</li>
                </ul>
                <p>
                    <em>Nota: No se ejecutaron tests unitarios específicos para Tile Caching porque es una optimización
                    de rendimiento que no cambia el comportamiento funcional. La validación se hizo mediante pruebas
                    visuales y medición de FPS.</em>
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">VRAM Tile Data, Background Tile Map</a></li>
                    <li>Técnicas de optimización en emulación: Tile Caching es una técnica estándar mencionada en documentación de emuladores educativos</li>
                </ul>
                <p>
                    <em>Nota: La implementación de Tile Caching es una técnica general de optimización en emulación,
                    no específica del hardware Game Boy. Se implementó basándose en principios generales de optimización
                    de renderizado y conocimiento de cómo funcionan las operaciones blit en SDL/pygame.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Tile Caching:</strong> Es una técnica de optimización que cachea tiles pre-decodificados
                        para evitar decodificar los mismos datos repetidamente. Reduce drásticamente el coste de CPU del renderizado.</li>
                        <li><strong>Blits vs PixelArray:</strong> Los blits (operaciones de copia de superficies) son mucho
                        más rápidos que escribir píxel a píxel porque delegan el trabajo a código C optimizado (SDL).</li>
                        <li><strong>Dirty tracking:</strong> Solo actualizar tiles que han cambiado maximiza el beneficio de
                        la caché. Sin dirty tracking, habría que invalidar toda la caché en cada frame, perdiendo el beneficio.</li>
                        <li><strong>Buffer grande:</strong> Dibujar el tilemap completo (256x256) y recortar es más eficiente
                        que calcular offsets para cada tile individualmente, especialmente con scroll.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Rango óptimo de caché:</strong> Actualmente solo cacheamos 0x8000-0x97FF (384 tiles).
                        Podría ser beneficioso cachear también tiles de sprites si se usan frecuentemente, pero esto
                        requeriría invalidación más compleja.</li>
                        <li><strong>Impacto de paleta:</strong> Actualmente la caché se actualiza cuando cambia la paleta
                        (BGP), pero esto podría optimizarse cacheando tiles sin paleta y aplicando la paleta en el blit.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Suposición verificada:</strong> Asumimos que cachear solo los primeros 384 tiles (0x8000-0x97FF)
                        sería suficiente para la mayoría de juegos. Esto se verificó con Tetris, que funciona perfectamente.
                        Juegos más complejos podrían usar tiles fuera de este rango, pero el fallback de decodificación directa
                        maneja estos casos sin problemas.
                    </p>
                    <p>
                        <strong>Suposición sobre rendimiento:</strong> Asumimos que el cuello de botella era el renderizado
                        píxel a píxel, no la lógica de CPU. Esto se confirmó: con Tile Caching, el emulador alcanza 60 FPS
                        estables, confirmando que el renderizado era el problema.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Optimizar renderizado de sprites usando Tile Caching (actualmente usa PixelArray píxel a píxel)</li>
                    <li>[ ] Considerar cachear tiles con múltiples paletas para evitar re-decodificación cuando cambia BGP</li>
                    <li>[ ] Perfilar el rendimiento con juegos más complejos para identificar posibles cuellos de botella adicionales</li>
                    <li>[ ] Implementar soporte para sprites de 8x16 píxeles (actualmente solo 8x8)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

