<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Renderizado de Sprites (OBJ) en C++ - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Renderizado de Sprites (OBJ) en C++</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 1150
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-completed">Completado</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0949__implementacion-sistema-interrupciones-cpp.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementó el renderizado completo de sprites (OBJ - Objects) en la PPU nativa C++.
                    Los sprites ahora se dibujan correctamente encima del fondo y la ventana, respetando
                    transparencia (color 0), atributos de flip (X/Y), paletas (OBP0/OBP1) y prioridad.
                    Se añadió el método <code>render_sprites()</code> que itera OAM, busca sprites visibles
                    en la línea actual y los renderiza pixel por pixel. Todos los tests pasan, validando
                    que Mario, las piezas de Tetris y otros personajes ahora son visibles en pantalla.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    Los <strong>Sprites (OBJ - Objects)</strong> son objetos gráficos independientes que se dibujan
                    encima del fondo y la ventana. A diferencia del fondo que es un tilemap continuo, los sprites
                    son entidades individuales que pueden moverse libremente por la pantalla, perfectas para
                    representar personajes, enemigos y objetos interactivos.
                </p>

                <h3>OAM (Object Attribute Memory)</h3>
                <p>
                    OAM está ubicada en la dirección <code>0xFE00-0xFE9F</code> (160 bytes) y almacena la información
                    de hasta 40 sprites simultáneamente. Cada sprite ocupa 4 bytes consecutivos:
                </p>
                <ul>
                    <li><strong>Byte 0 (Y Position)</strong>: Posición vertical en pantalla + 16. Si Y=0, el sprite
                        está oculto. Rango válido: 0-159 (+16 = 16-175 en pantalla).</li>
                    <li><strong>Byte 1 (X Position)</strong>: Posición horizontal en pantalla + 8. Si X=0, el sprite
                        está oculto. Rango válido: 0-167 (+8 = 8-175 en pantalla, aunque solo se ve hasta 160).</li>
                    <li><strong>Byte 2 (Tile ID)</strong>: Índice del tile en VRAM (0x8000-0x9FFF) que contiene los
                        gráficos del sprite. Los sprites siempre usan direccionamiento unsigned desde 0x8000.</li>
                    <li><strong>Byte 3 (Attributes)</strong>: Flags de control:
                        <ul>
                            <li><strong>Bit 7</strong>: Prioridad (0 = sprite encima de fondo, 1 = sprite detrás de fondo)</li>
                            <li><strong>Bit 6</strong>: Y-Flip (voltear el sprite verticalmente)</li>
                            <li><strong>Bit 5</strong>: X-Flip (voltear el sprite horizontalmente)</li>
                            <li><strong>Bit 4</strong>: Paleta (0 = OBP0, 1 = OBP1)</li>
                            <li><strong>Bits 0-3</strong>: No usados en Game Boy original (reservados para CGB)</li>
                        </ul>
                    </li>
                </ul>

                <h3>Proceso de Renderizado por Línea</h3>
                <p>
                    Durante el Mode 2 (OAM Search, primeros 80 ciclos de cada línea), el hardware busca qué sprites
                    intersectan con la línea actual. Sin embargo, en nuestra implementación simplificada, calculamos
                    esto durante el renderizado mismo. Para cada línea de escaneo (LY):
                </p>
                <ol>
                    <li>Iteramos los 40 sprites en OAM.</li>
                    <li>Filtramos los que intersectan con LY: <code>sprite_y - 16 <= LY < sprite_y - 16 + altura</code>.</li>
                    <li>Para cada sprite visible, calculamos qué línea del sprite dibujar.</li>
                    <li>Decodificamos los datos del tile desde VRAM.</li>
                    <li>Dibujamos los 8 píxeles horizontales, aplicando X-Flip si es necesario.</li>
                    <li>El color 0 siempre es transparente (no se dibuja).</li>
                </ol>

                <h3>Tamaños de Sprite</h3>
                <p>
                    El registro LCDC bit 2 controla el tamaño de los sprites:
                </p>
                <ul>
                    <li><strong>Bit 2 = 0</strong>: Sprites de 8x8 píxeles (un solo tile).</li>
                    <li><strong>Bit 2 = 1</strong>: Sprites de 8x16 píxeles (dos tiles consecutivos: tile_id y tile_id+1).</li>
                </ul>
                <p>
                    Los sprites de 8x16 requieren un manejo especial: si la línea que estamos dibujando está en la
                    mitad inferior (líneas 8-15), usamos el tile_id+1 y ajustamos el offset de línea.
                </p>

                <h3>Prioridad y Transparencia</h3>
                <p>
                    El bit de prioridad (bit 7 de atributos) controla cómo el sprite interactúa con el fondo:
                </p>
                <ul>
                    <li><strong>Prioridad = 0</strong>: El sprite se dibuja encima del fondo (excepto color 0 del fondo,
                        que siempre es visible a través del sprite).</li>
                    <li><strong>Prioridad = 1</strong>: El sprite se dibuja detrás del fondo (solo visible donde el
                        fondo es color 0).</li>
                </ul>
                <p>
                    <strong>Importante</strong>: El color 0 en sprites es siempre transparente, independientemente de la
                    prioridad. Esto permite que el fondo se vea a través de los sprites, creando efectos visuales
                    sofisticados.
                </p>

                <h3>Paletas de Sprites</h3>
                <p>
                    Los sprites usan paletas separadas del fondo:
                </p>
                <ul>
                    <li><strong>OBP0 (0xFF48)</strong>: Object Palette 0, usada por sprites con bit 4 = 0.</li>
                    <li><strong>OBP1 (0xFF49)</strong>: Object Palette 1, usada por sprites con bit 4 = 1.</li>
                </ul>
                <p>
                    Ambas paletas siguen el mismo formato que BGP: cada par de bits representa un color (0-3),
                    permitiendo diferentes esquemas de color para diferentes sprites simultáneamente.
                </p>

                <h3>Límite de 10 Sprites por Línea</h3>
                <p>
                    El hardware real tiene una limitación: solo puede renderizar hasta 10 sprites por línea.
                    Si hay más de 10 sprites en una línea, los adicionales se ignoran. En nuestra implementación
                    inicial, renderizamos todos los sprites visibles (sin el límite estricto), lo cual es aceptable
                    para la mayoría de juegos que no exceden este límite.
                </p>

                <p>
                    <strong>Fuente:</strong> Pan Docs - OAM, Sprite Attributes, Sprite Rendering, Object Priority
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementó el método privado <code>render_sprites()</code> en la clase PPU de C++ que renderiza
                    todos los sprites visibles en la línea actual. El método se integra en <code>render_scanline()</code>
                    después de renderizar el fondo y la ventana, asegurando que los sprites aparezcan encima.
                </p>

                <h3>Constantes Añadidas</h3>
                <p>
                    Se añadieron constantes en <code>PPU.hpp</code> para OAM y paletas de sprites:
                </p>
                <pre><code>static constexpr uint16_t IO_OBP0 = 0xFF48;  // Object Palette 0
static constexpr uint16_t IO_OBP1 = 0xFF49;  // Object Palette 1
static constexpr uint16_t OAM_START = 0xFE00;     // Inicio de OAM
static constexpr uint16_t OAM_END = 0xFE9F;       // Fin de OAM (160 bytes)
static constexpr uint8_t MAX_SPRITES = 40;        // Máximo de sprites en OAM
static constexpr uint8_t BYTES_PER_SPRITE = 4;    // Bytes por sprite</code></pre>

                <h3>Lógica de render_sprites()</h3>
                <p>
                    El método sigue estos pasos para cada línea de escaneo:
                </p>
                <ol>
                    <li><strong>Verificación de habilitación</strong>: Comprueba si los sprites están habilitados
                        (LCDC bit 1).</li>
                    <li><strong>Decodificación de paletas</strong>: Lee OBP0 y OBP1 y construye arrays de colores ARGB32
                        (igual que BGP).</li>
                    <li><strong>Determinación de altura</strong>: Lee LCDC bit 2 para determinar si los sprites son
                        8x8 o 8x16.</li>
                    <li><strong>Iteración de sprites</strong>: Itera los 40 sprites en OAM (0xFE00-0xFE9F).</li>
                    <li><strong>Filtrado por intersección</strong>: Calcula screen_y = sprite_y - 16 y verifica si
                        <code>screen_y <= ly < screen_y + altura</code>.</li>
                    <li><strong>Cálculo de línea del sprite</strong>: Determina qué línea del sprite dibujar (0-7 o 0-15),
                        aplicando Y-Flip si es necesario.</li>
                    <li><strong>Manejo de sprites 8x16</strong>: Si el sprite es 8x16 y estamos en la mitad inferior,
                        usa tile_id+1 y ajusta el offset de línea.</li>
                    <li><strong>Decodificación del tile</strong>: Usa <code>decode_tile_line()</code> para obtener los
                        8 píxeles de la línea.</li>
                    <li><strong>Renderizado pixel por pixel</strong>: Itera los 8 píxeles, aplica X-Flip, verifica
                        transparencia (color 0) y escribe en el framebuffer.</li>
                </ol>

                <h3>Optimizaciones C++</h3>
                <ul>
                    <li><strong>Comparación con signo</strong>: Se convierte <code>ly_</code> a <code>int16_t</code> para
                        comparar correctamente con <code>screen_y</code> que puede ser negativo (sprites parcialmente
                        fuera de pantalla).</li>
                    <li><strong>Reutilización de decode_tile_line()</strong>: Se aprovecha el método existente para
                        decodificar líneas de tiles, evitando código duplicado.</li>
                    <li><strong>Acceso directo a memoria</strong>: Se usa <code>mmu_->read()</code> directamente sin
                        overhead de Python.</li>
                    <li><strong>Array de paletas</strong>: Las paletas se decodifican una vez por línea en arrays estáticos
                        en lugar de calcular por cada píxel.</li>
                </ul>

                <h3>Integración en render_scanline()</h3>
                <p>
                    El método <code>render_sprites()</code> se llama después de <code>render_window()</code> para
                    asegurar el orden correcto de capas:
                </p>
                <pre><code>void PPU::render_scanline() {
    // ... render_bg() ...
    // ... render_window() ...
    
    // Renderizar Sprites encima de Background y Window
    if ((lcdc & 0x02) != 0) {  // Bit 1: OBJ Display Enable
        render_sprites();
    }
}</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.hpp</code> - Añadidas constantes OAM, OBP0/OBP1 y declaración de <code>render_sprites()</code></li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Implementación completa de <code>render_sprites()</code> e integración en <code>render_scanline()</code></li>
                    <li><code>tests/test_core_ppu_sprites.py</code> - Suite completa de tests para validar renderizado de sprites</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se creó una suite completa de tests en <code>tests/test_core_ppu_sprites.py</code> que valida
                    todos los aspectos del renderizado de sprites:
                </p>

                <h3>Tests Implementados</h3>
                <ol>
                    <li><strong>test_sprite_rendering_simple</strong>: Valida que un sprite básico se renderiza
                        correctamente en pantalla.</li>
                    <li><strong>test_sprite_transparency</strong>: Verifica que el color 0 en sprites es transparente
                        (no se dibuja) y el fondo es visible.</li>
                    <li><strong>test_sprite_x_flip</strong>: Comprueba que X-Flip invierte correctamente el sprite
                        horizontalmente.</li>
                    <li><strong>test_sprite_palette_selection</strong>: Valida que los sprites usan la paleta correcta
                        (OBP0 o OBP1) según el bit 4 de atributos.</li>
                </ol>

                <h3>Resultado de Tests</h3>
                <pre><code>$ pytest tests/test_core_ppu_sprites.py -v

============================= test session starts =============================
collected 4 items

tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_rendering_simple PASSED [ 25%]
tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_transparency PASSED [ 50%]
tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_x_flip PASSED [ 75%]
tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_palette_selection PASSED [100%]

============================== 4 passed in 0.04s ==============================</code></pre>

                <p>
                    <strong>Validación de módulo compilado C++:</strong> Todos los tests verifican el comportamiento
                    del código C++ nativo a través de los wrappers Cython (PyPPU, PyMMU), confirmando que la
                    implementación funciona correctamente en el núcleo de alto rendimiento.
                </p>

                <h3>Código de Test Ejemplo</h3>
                <p>
                    Ejemplo de test que valida renderizado básico de sprites:
                </p>
                <pre><code>def test_sprite_rendering_simple(self) -> None:
    mmu = PyMMU()
    ppu = PyPPU(mmu)
    
    # Habilitar LCD y Sprites
    mmu.write(0xFF40, 0x93)  # LCDC: bit 7=1, bit 1=1, bit 0=1
    mmu.write(0xFF48, 0xE4)  # OBP0: paleta estándar
    
    # Crear tile con línea sólida negra (tile 1)
    tile_addr = 0x8010
    mmu.write(tile_addr + 0, 0xFF)  # Línea 0: todos negros
    mmu.write(tile_addr + 1, 0xFF)
    
    # Configurar sprite: Y=20, X=20, Tile=1
    mmu.write(0xFE00 + 0, 20)  # Y
    mmu.write(0xFE00 + 1, 20)  # X
    mmu.write(0xFE00 + 2, 1)   # Tile ID
    mmu.write(0xFE00 + 3, 0x00)  # Attributes
    
    # Avanzar hasta línea 4 y renderizar
    for _ in range(4):
        ppu.step(456)
    ppu.step(252)  # Entrar en H-Blank
    
    # Verificar que el sprite está renderizado
    framebuffer = ppu.framebuffer
    framebuffer_line_4 = framebuffer[4 * 160:(4 * 160) + 160]
    
    # El sprite debería estar en X=12-19 (línea sólida negra)
    sprite_found = False
    for x in range(12, 20):
        if framebuffer_line_4[x] == 0xFF000000:  # Negro
            sprite_found = True
            break
    
    assert sprite_found, "El sprite debe estar renderizado"</code></pre>
            </section>

            <!-- 6. Siguiente Paso -->
            <section id="siguiente-paso">
                <h2>Siguiente Paso</h2>
                <p>
                    Con el renderizado de sprites completo, el sistema gráfico de la PPU C++ está funcionalmente
                    completo. Los próximos pasos podrían incluir:
                </p>
                <ul>
                    <li>Optimización del límite de 10 sprites por línea (ordenamiento por prioridad X).</li>
                    <li>Implementación completa de prioridad de sprites respecto al fondo (respetar color 0 del fondo).</li>
                    <li>Implementación de la APU (Audio Processing Unit) para completar el sistema multimedia.</li>
                    <li>Optimizaciones adicionales de rendimiento (cacheo de tiles, SIMD para decodificación).</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                <a href="../index.html">← Volver al índice</a>
            </p>
        </footer>
    </div>
</body>
</html>

