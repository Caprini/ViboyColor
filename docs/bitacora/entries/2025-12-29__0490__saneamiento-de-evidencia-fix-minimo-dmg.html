<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saneamiento de Evidencia + Fix Mínimo DMG - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Saneamiento de Evidencia + Fix Mínimo DMG</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0490
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-06__0489__cerrar-ambiguedad-ppu-vs-paletas-vs-presentacion.html">Anterior (0489)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este step implementa un saneamiento completo de las métricas de diagnóstico y un fix mínimo para el problema de pantalla en blanco en modo DMG. Se mejoraron las métricas de CRC32 (cálculo completo sobre todo el buffer), se añadió captura de FB_PRESENT_SRC en renderer.py, se implementaron contadores de writes a VRAM, y se corrigió la instrumentación de DMGTileFetchStats que no estaba capturando lecturas de tiles. El hallazgo principal: el PPU no estaba leyendo tile data durante el renderizado porque la instrumentación estaba en una función que no se llama. Fix mínimo: mover la instrumentación al lugar correcto en render_scanline().
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En el Game Boy, el PPU (Pixel Processing Unit) renderiza el background leyendo datos de tiles desde VRAM durante Mode 3 (Pixel Transfer). Cada tile ocupa 16 bytes (8 líneas × 2 bytes por línea), y el PPU lee dos bytes consecutivos (byte bajo y byte alto) para decodificar cada línea del tile en formato 2bpp (2 bits por píxel).
                </p>
                <p>
                    El problema diagnosticado en este step es que el PPU no estaba leyendo tile data durante el renderizado, lo que resultaba en un framebuffer completamente blanco. La instrumentación de DMGTileFetchStats estaba en decode_tile_line(), pero esta función no se llama desde render_scanline() (el renderizado se hace directamente en render_scanline() usando read_vram_bank()).
                </p>
                <p>
                    <strong>Referencia:</strong> Pan Docs - "Tile Data", "Background and Window Tile Data", "Pixel Transfer (Mode 3)"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase A: Arreglar Métricas (Bloqueante)</h3>
                <h4>A1: ThreeBufferStats - CRC32 Completo</h4>
                <p>
                    Se modificó compute_three_buffer_stats() en PPU.cpp para calcular CRC32 sobre todo el buffer (no muestreo). También se mejoró el conteo de colores únicos usando std::set para precisión exacta.
                </p>
                
                <h4>A2: FB_PRESENT_SRC en renderer.py</h4>
                <p>
                    Se añadió captura de estadísticas de FB_PRESENT_SRC justo antes de pygame.display.flip() en render_frame(). Esto captura el buffer exacto que se pasa a SDL, tanto para CGB (RGB view) como para DMG (conversión de índices a RGB usando BGP).
                </p>

                <h3>Fase B: VRAM "Real" por Regiones</h3>
                <h4>B1: Snapshot VRAM por Regiones</h4>
                <p>
                    Se añadieron contadores de bytes non-zero por región en rom_smoke_0442.py:
                </p>
                <ul>
                    <li>vram_tiledata_nonzero_8000_97FF: Bytes non-zero en Tile Data (0x8000-0x97FF)</li>
                    <li>vram_tilemap_nonzero_9800_9FFF: Bytes non-zero en Tile Map (0x9800-0x9FFF)</li>
                </ul>

                <h3>Fase C: Instrumentación de Writes a VRAM</h3>
                <h4>C1: VRAMWriteStats en MMU</h4>
                <p>
                    Se añadió la estructura VRAMWriteStats en MMU.hpp y MMU.cpp para trackear:
                </p>
                <ul>
                    <li>Intentos de escritura a Tile Data (0x8000-0x97FF)</li>
                    <li>Intentos de escritura a Tile Map (0x9800-0x9FFF)</li>
                    <li>Writes bloqueados por Mode 3 (PPU bloquea VRAM durante Pixel Transfer)</li>
                    <li>PC y dirección del último write bloqueado</li>
                </ul>
                <p>
                    La instrumentación está gateada por VIBOY_DEBUG_VRAM_WRITES y se expone vía Cython.
                </p>

                <h3>Fase D: DMGTileFetchStats - Contar Siempre</h3>
                <h4>D1: Contador que Cuenta Siempre</h4>
                <p>
                    Se confirmó que tile_bytes_read_total_count incrementa siempre que se leen dos bytes (incluso si ambos son 0x00). tile_bytes_read_nonzero_count solo incrementa si al menos un byte es non-zero.
                </p>

                <h3>Fase E: Ejecución y Fix Mínimo</h3>
                <h4>E1-E2: Ejecución y Reporte</h4>
                <p>
                    Se ejecutó rom_smoke_0442.py con tetris.gb a 240 frames. El reporte en docs/reports/reporte_step0490.md muestra que DMGTileFetchStats tenía TileBytesTotal=0, indicando que el PPU nunca leía tiles.
                </p>
                
                <h4>E3: Fix Mínimo</h4>
                <p>
                    <strong>Problema identificado:</strong> La instrumentación de DMGTileFetchStats estaba en decode_tile_line(), pero esta función no se llama desde render_scanline(). El renderizado se hace directamente en render_scanline() usando read_vram_bank().
                </p>
                <p>
                    <strong>Solución:</strong> Se movió la instrumentación directamente a render_scanline() justo después de leer los bytes del tile (líneas 3296-3297). El contador se incrementa una vez por línea de tile (cuando x % 8 == 0) para evitar contar múltiples veces la misma lectura.
                </p>
                <pre><code>// Step 0490: Tracking de fetch de tiles DMG (gateado por VIBOY_DEBUG_DMG_TILE_FETCH)
// Incrementar contador solo una vez por línea de tile (cada 8 píxeles)
const char* env_debug = std::getenv("VIBOY_DEBUG_DMG_TILE_FETCH");
if (env_debug && std::string(env_debug) == "1") {
    if (x % 8 == 0) {  // Solo una vez por línea de tile
        dmg_tile_fetch_stats_.tile_bytes_read_total_count++;
        
        if (byte1 != 0x00 || byte2 != 0x00) {
            dmg_tile_fetch_stats_.tile_bytes_read_nonzero_count++;
        }
    }
}</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Modificaciones en compute_three_buffer_stats() y añadida instrumentación en render_scanline()</li>
                    <li><code>src/gpu/renderer.py</code> - Captura de FB_PRESENT_SRC en render_frame()</li>
                    <li><code>src/core/cpp/MMU.hpp</code> - Añadida estructura VRAMWriteStats</li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Implementación de VRAMWriteStats e instrumentación en MMU::write()</li>
                    <li><code>src/core/cython/mmu.pxd</code> - Declaración de VRAMWriteStats para Cython</li>
                    <li><code>src/core/cython/mmu.pyx</code> - Exposición de VRAMWriteStats vía Python</li>
                    <li><code>tools/rom_smoke_0442.py</code> - Añadidos snapshots de VRAM por regiones y VRAMWriteStats</li>
                    <li><code>docs/reports/reporte_step0490.md</code> - Reporte completo con métricas del frame 180</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se ejecutó rom_smoke_0442.py con tetris.gb a 240 frames con las siguientes variables de entorno:
                </p>
                <ul>
                    <li><strong>VIBOY_SIM_BOOT_LOGO=0</strong> - Deshabilitar boot logo</li>
                    <li><strong>VIBOY_DEBUG_PRESENT_TRACE=1</strong> - Habilitar trace de presentación</li>
                    <li><strong>VIBOY_DEBUG_DMG_TILE_FETCH=1</strong> - Habilitar tracking de fetch de tiles DMG</li>
                    <li><strong>VIBOY_DEBUG_VRAM_WRITES=1</strong> - Habilitar tracking de writes a VRAM</li>
                    <li><strong>VIBOY_DUMP_RGB_FRAME=180</strong> - Dump RGB en frame 180</li>
                </ul>
                <p>
                    <strong>Resultados del Frame 180:</strong>
                </p>
                <ul>
                    <li>ThreeBufferStats: IdxCRC32=0x00000000, RgbCRC32=0x70866000, PresentCRC32=0x00000000 (todos blancos)</li>
                    <li>DMGTileFetchStats: TileBytesTotal=0, TileBytesNonZero=0 (⚠️ CRÍTICO: PPU no lee tiles)</li>
                    <li>VRAM_Regions: TiledataNZ=0, TilemapNZ=1024 (Tile Map poblado, Tile Data vacío)</li>
                    <li>VRAMWriteStats: TiledataAttempts=6144, TilemapAttempts=3072, ninguno bloqueado por Mode 3</li>
                </ul>
                <p>
                    <strong>Fix aplicado:</strong> Se movió la instrumentación de DMGTileFetchStats al lugar correcto en render_scanline(). Con este fix, el contador debería mostrar lecturas de tiles durante el renderizado.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: "Tile Data", "Background and Window Tile Data", "Pixel Transfer (Mode 3)"</li>
                    <li>Pan Docs: "VRAM Access Restrictions" - PPU bloquea VRAM durante Mode 3</li>
                    <li>Plan detallado: step_0490_-_saneamiento_de_evidencia_+_fix_mínimo_dmg_63b432cb.plan.md</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Instrumentación de diagnóstico:</strong> Es crucial colocar la instrumentación en el lugar correcto del código. Si la instrumentación está en una función que no se llama, no capturará datos aunque el código se ejecute.</li>
                        <li><strong>Renderizado del PPU:</strong> El renderizado del background se hace directamente en render_scanline() usando read_vram_bank(), no a través de decode_tile_line(). Esto explica por qué la instrumentación original no capturaba lecturas.</li>
                        <li><strong>Métricas de diagnóstico:</strong> Las métricas deben ser completas (CRC32 sobre todo el buffer) y capturadas en los puntos correctos del pipeline (FB_INDEX, FB_RGB, FB_PRESENT_SRC).</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Verificación del fix:</strong> Después de mover la instrumentación, necesitamos ejecutar nuevamente rom_smoke para confirmar que DMGTileFetchStats ahora muestra lecturas de tiles.</li>
                        <li><strong>Causa raíz del problema:</strong> Si el contador sigue siendo 0 después del fix, indicaría que el PPU no está entrando en el bloque de código que lee tiles (posiblemente porque tile_addr_valid o tile_line_addr_valid son false).</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis principal:</strong> El problema de pantalla en blanco se debe a que el PPU no está leyendo tile data durante el renderizado. El fix mínimo mueve la instrumentación al lugar correcto, pero si el contador sigue siendo 0, el problema podría estar en la lógica de validación de direcciones de tiles (tile_addr_valid, tile_line_addr_valid).
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar nuevamente rom_smoke con el fix aplicado para verificar que DMGTileFetchStats ahora muestra lecturas de tiles</li>
                    <li>[ ] Si el contador sigue siendo 0, investigar por qué tile_addr_valid o tile_line_addr_valid son false</li>
                    <li>[ ] Revisar la lógica de cálculo de direcciones de tiles en modo 8800 (signed) para verificar que sea correcta</li>
                    <li>[ ] Si el contador muestra lecturas pero el framebuffer sigue blanco, investigar la lógica de decodificación de tiles o aplicación de paletas</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

