<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verificación Visual y Análisis de Rendimiento Post-Correcciones - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Verificación Visual y Análisis de Rendimiento Post-Correcciones</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0363
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0362__correccion-framebuffer-vacio-verificacion-visual.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementó un sistema completo de diagnóstico de rendimiento para identificar cuellos de botella en el pipeline de renderizado. 
                    Se agregaron mediciones de tiempo en los puntos críticos: renderizado de scanlines en C++, lectura del framebuffer en Python, 
                    y renderizado final en el renderer. Este sistema permitirá identificar si el problema de FPS bajo (0.1-10.8) se debe a cuellos 
                    de botella en el pipeline de renderizado o a otros factores.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <h3>Rendimiento en Emuladores</h3>
                <p>
                    Un frame debe completarse en aproximadamente 16.67ms para mantener 60 FPS estables. El pipeline de renderizado debe ser eficiente: 
                    C++ genera el framebuffer → Python lee el framebuffer → Python renderiza a la pantalla. Cualquier cuello de botella en este pipeline 
                    (>16ms en cualquier etapa) causará FPS bajo.
                </p>
                <p>
                    Para identificar cuellos de botella, es necesario medir el tiempo que tarda cada etapa del pipeline:
                </p>
                <ul>
                    <li><strong>render_scanline()</strong>: Tiempo que tarda C++ en renderizar una línea completa (esperado: <1ms por línea)</li>
                    <li><strong>get_frame_ready_and_reset()</strong>: Tiempo que tarda C++ en marcar el frame como listo (esperado: <0.1ms)</li>
                    <li><strong>Lectura del framebuffer en Python</strong>: Tiempo que tarda Python en copiar el framebuffer de C++ (esperado: <1ms)</li>
                    <li><strong>Renderizado en Python</strong>: Tiempo que tarda Python en convertir índices a RGB y renderizar a la pantalla (esperado: <10ms)</li>
                </ul>
                <h3>Sincronización en Sistemas Multi-Componente</h3>
                <p>
                    Cuando múltiples componentes (C++ y Python) comparten datos (framebuffer), la sincronización es crítica. El framebuffer debe mantenerse 
                    estable hasta que el componente de lectura termine. Si el framebuffer se modifica durante la lectura, pueden ocurrir gráficos corruptos 
                    o pantallas blancas.
                </p>
                <h3>Doble Buffering (Concepto para Futuras Optimizaciones)</h3>
                <p>
                    El doble buffering usa dos framebuffers: uno para escribir (C++) y otro para leer (Python). Cuando se completa un frame, se intercambian 
                    los buffers. Esto elimina condiciones de carrera pero requiere más memoria. Si el diagnóstico de rendimiento muestra que hay problemas 
                    de sincronización, el doble buffering podría ser una solución.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <h3>Diagnóstico de Rendimiento en C++ (PPU.cpp)</h3>
                <p>
                    Se agregó medición de tiempo usando <code>std::chrono::high_resolution_clock</code> en dos funciones críticas:
                </p>
                <ul>
                    <li><strong>render_scanline()</strong>: Se mide el tiempo total que tarda en renderizar una línea. Se reporta cada 10 ejecuciones para las primeras 100 líneas.</li>
                    <li><strong>get_frame_ready_and_reset()</strong>: Se mide el tiempo que tarda en marcar el frame como listo. Se reporta cada 10 ejecuciones para las primeras 100 llamadas.</li>
                </ul>
                <pre><code>// --- Step 0363: Diagnóstico de Rendimiento ---
// Medir tiempo de render_scanline() para identificar cuellos de botella
static int render_scanline_timing_count = 0;
auto start_time = std::chrono::high_resolution_clock::now();

// ... código de render_scanline() ...

auto end_time = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end_time - start_time);

if (render_scanline_timing_count < 100) {
    render_scanline_timing_count++;
    if (render_scanline_timing_count % 10 == 0) {
        printf("[PPU-PERF] render_scanline() (LY=%d) took %lld microseconds\n", 
               ly_, duration.count());
    }
}</code></pre>
                
                <h3>Diagnóstico de Rendimiento en Python (viboy.py)</h3>
                <p>
                    Se mejoró la medición existente del tiempo de lectura del framebuffer para que reporte cada 60 frames, permitiendo monitorear 
                    el rendimiento durante la ejecución sin saturar los logs.
                </p>
                <pre><code># --- Step 0363: Diagnóstico de Rendimiento en Python ---
# Medir tiempo de lectura del framebuffer y reportar cada 60 frames
if not hasattr(self, '_framebuffer_read_timing_count'):
    self._framebuffer_read_timing_count = 0
self._framebuffer_read_timing_count += 1

if self._framebuffer_read_timing_count % 60 == 0:
    logger.info(f"[Viboy-Perf] Frame {self._framebuffer_read_timing_count} | "
               f"Read: {read_duration:.2f}ms")
    print(f"[Viboy-Perf] Frame {self._framebuffer_read_timing_count} | "
          f"Read: {read_duration:.2f}ms", flush=True)</code></pre>
                
                <h3>Diagnóstico de Rendimiento en Renderer (renderer.py)</h3>
                <p>
                    Se mejoró la medición existente del tiempo de renderizado para que reporte cada 60 frames, permitiendo monitorear el tiempo que 
                    tarda Python en convertir índices a RGB y renderizar a la pantalla.
                </p>
                <pre><code># --- Step 0363: Diagnóstico de Rendimiento en Renderer ---
# Reportar tiempo de renderizado cada 60 frames
if not hasattr(self, '_render_perf_frame_count'):
    self._render_perf_frame_count = 0
self._render_perf_frame_count += 1

if self._render_perf_frame_count % 60 == 0:
    logger.info(f"[Viboy-Perf] Frame {self._render_perf_frame_count} | "
               f"Render: {render_time:.2f}ms")
    print(f"[Viboy-Perf] Frame {self._render_perf_frame_count} | "
          f"Render: {render_time:.2f}ms", flush=True)</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Agregado diagnóstico de rendimiento en render_scanline() y get_frame_ready_and_reset()</li>
                    <li><code>src/viboy.py</code> - Mejorado diagnóstico de rendimiento para reportar cada 60 frames</li>
                    <li><code>src/gpu/renderer.py</code> - Mejorado diagnóstico de rendimiento para reportar cada 60 frames</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se compiló exitosamente el código C++ con las nuevas mediciones de rendimiento. Se ejecutó una prueba rápida con Tetris que confirmó 
                    que el código se ejecuta sin errores, aunque no se generaron métricas de rendimiento porque la prueba solo llegó al Frame 0.
                </p>
                <p>
                    <strong>Comando de compilación:</strong>
                </p>
                <pre><code>python3 setup.py build_ext --inplace</code></pre>
                <p>
                    <strong>Compilación:</strong> ✅ Exitosa (con warnings menores de formato que no afectan la funcionalidad)
                </p>
                <p>
                    <strong>Prueba rápida:</strong> Se ejecutó Tetris durante 30 segundos para verificar que el código funciona. El juego inició correctamente 
                    (Frame 0, VRAM vacía al inicio, comportamiento normal).
                </p>
                <p>
                    <strong>Próximos pasos para verificación completa:</strong> Ejecutar pruebas más largas con las 6 ROMs para generar métricas de rendimiento 
                    completas y analizar si hay cuellos de botella en el pipeline de renderizado.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">https://gbdev.io/pandocs/</a> - Timing y sincronización</li>
                    <li>Documentación C++17: <code>std::chrono</code> para medición de tiempo de alta resolución</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Medición de rendimiento:</strong> Es crítico medir el tiempo en cada etapa del pipeline para identificar cuellos de botella. 
                        Usar <code>std::chrono::high_resolution_clock</code> proporciona precisión de microsegundos en C++.</li>
                        <li><strong>Reporte periódico:</strong> Para no saturar los logs, es mejor reportar métricas de rendimiento periódicamente (cada 60 frames) 
                        en lugar de en cada frame.</li>
                        <li><strong>Pipeline de renderizado:</strong> El pipeline completo es: C++ renderiza → C++ marca frame listo → Python lee → Python renderiza. 
                        Cada etapa debe ser eficiente para mantener 60 FPS.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Métricas reales:</strong> Necesitamos ejecutar pruebas más largas para obtener métricas reales de rendimiento y verificar si hay cuellos 
                        de botella en el pipeline.</li>
                        <li><strong>Problemas visuales:</strong> Si las correcciones del Step 0362 resolvieron los problemas de pantallas blancas, o si persisten problemas visuales.</li>
                        <li><strong>FPS bajo:</strong> Si el FPS bajo (0.1-10.8) se debe a cuellos de botella en el pipeline de renderizado o a otros factores.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis:</strong> El FPS bajo podría deberse a cuellos de botella en el pipeline de renderizado. Si la medición muestra que alguna etapa 
                        tarda más de 16ms, esa sería la causa del problema. Si todas las etapas son rápidas (<16ms), el problema podría estar en otro lugar (sincronización, 
                        esperas innecesarias, etc.).
                    </p>
                </div>
            </section>

            <!-- 8. Análisis de Logs -->
            <section id="analisis-logs">
                <h2>Análisis de Logs de Pruebas</h2>
                <p>
                    Se ejecutaron pruebas completas con las 6 ROMs (60 segundos cada una) y se analizaron los logs generados.
                </p>
                
                <h3>Resultados de Rendimiento</h3>
                <ul>
                    <li><strong>render_scanline()</strong>: 9-56 microsegundos (promedio ~25 μs) - Excelente rendimiento</li>
                    <li><strong>get_frame_ready_and_reset()</strong>: 0 microsegundos - Instantáneo</li>
                    <li><strong>Lectura del framebuffer (Python)</strong>: 0.02-0.05ms (promedio ~0.03ms) - Extremadamente rápido</li>
                    <li><strong>FPS observados</strong>: 51-53 FPS (mejor que los 0.1-10.8 reportados anteriormente)</li>
                </ul>
                
                <h3>Problema Crítico Identificado</h3>
                <p>
                    <strong>Condición de Carrera en el Framebuffer</strong>: Se encontraron múltiples advertencias en todos los logs:
                </p>
                <pre><code>[PPU-FRAMEBUFFER-STABILITY] ⚠️ ADVERTENCIA: Framebuffer cambió mientras Python lo leía!</code></pre>
                <p>
                    <strong>Estadísticas de advertencias por ROM</strong>:
                </p>
                <ul>
                    <li>Mario: 24 advertencias</li>
                    <li>Oro: 35 advertencias</li>
                    <li>PKMN Amarillo: 19 advertencias</li>
                    <li>PKMN: 22 advertencias</li>
                    <li>Tetris: 26 advertencias</li>
                    <li>Zelda DX: 7291 advertencias ⚠️ (MUY ALTO)</li>
                </ul>
                
                <h3>Análisis del Problema</h3>
                <p>
                    El código actual protege contra <strong>limpieza</strong> del framebuffer cuando <code>framebuffer_being_read_</code> está activo, 
                    pero <strong>NO protege contra escritura</strong> de nuevos datos. Esto significa que:
                </p>
                <ol>
                    <li>Python marca el framebuffer como "siendo leído" (<code>framebuffer_being_read_ = true</code>)</li>
                    <li>Mientras Python lee el framebuffer, la PPU continúa renderizando el siguiente frame</li>
                    <li>La PPU escribe nuevos datos al framebuffer mientras Python lo está leyendo</li>
                    <li>Esto causa condiciones de carrera y gráficos corruptos</li>
                </ol>
                
                <p>
                    <strong>Causa raíz</strong>: El flag <code>framebuffer_being_read_</code> solo previene la limpieza del framebuffer, 
                    pero no previene que <code>render_scanline()</code> escriba nuevos datos mientras Python está leyendo.
                </p>
                
                <h3>Frames Vacíos</h3>
                <p>
                    Se encontraron frames completamente vacíos (0 píxeles no-blancos) en varios juegos, especialmente en Oro. 
                    Esto puede ser comportamiento normal del juego (pantallas negras durante transiciones) o un problema de sincronización.
                </p>
                
                <p>
                    <strong>Reporte completo disponible en</strong>: 
                    <code>docs/bitacora/entries/2025-12-29__0363__analisis-logs-reporte.md</code>
                </p>
            </section>

            <!-- 9. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[✅] Ejecutar pruebas visuales completas con las 6 ROMs</li>
                    <li>[✅] Analizar logs generados para confirmar que las correcciones funcionan</li>
                    <li>[✅] Analizar métricas de rendimiento (conclusión: rendimiento excelente, no es el problema)</li>
                    <li>[✅] Identificar problema crítico: condición de carrera en el framebuffer</li>
                    <li>[ ] Implementar doble buffering para eliminar condiciones de carrera (Step 0364)</li>
                    <li>[ ] Investigar por qué Zelda DX tiene tantas advertencias (7291 vs 19-35 en otros juegos)</li>
                    <li>[ ] Verificar si los frames vacíos son comportamiento normal o un problema</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

