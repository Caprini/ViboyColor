<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0458: Fix BG Decode/Render - VRAM Reading Correcto - Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Step 0458: Fix BG Decode/Render - VRAM Reading Correcto</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-03
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0458
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-03__0457__aislar-bug-indices-vs-paleta-conversion-rgb-fix-minimo.html">Anterior (0457)</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    <strong>Objetivo:</strong> Corregir la lectura de VRAM en el PPU. El Step 0457 confirmó que el bug NO es la conversión de paleta, sino el decode/render. El problema era que el PPU estaba leyendo VRAM desde <code>memory_[]</code> en lugar de los bancos VRAM correctos (<code>vram_bank0_</code>/<code>vram_bank1_</code>).
                </p>
                <p>
                    <strong>Hallazgo crítico:</strong> El PPU usaba <code>mmu_->read()</code> para leer VRAM, pero este método lee desde <code>memory_[]</code> que no contiene los datos de VRAM en modo CGB (donde VRAM está en bancos separados). El fix fue crear <code>MMU::read_vram()</code> que lee directamente desde los bancos VRAM correctos.
                </p>
                <p>
                    <strong>Resultado:</strong> ✅ El PPU ahora lee bytes VRAM correctos (0x55, 0x33) y los índices se escriben correctamente al framebuffer (0, 1, 2, 3). El bug de "índices todo 0" está resuelto.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy Color (CGB), VRAM está dividida en 2 bancos de 4KB cada uno (total 8KB):
                </p>
                <ul>
                    <li><strong>VRAM Bank 0:</strong> Tile data y tilemap (0x8000-0x9FFF)</li>
                    <li><strong>VRAM Bank 1:</strong> Tile data alterno y atributos de tilemap (0x8000-0x9FFF, mismo rango de direcciones)</li>
                </ul>
                <p>
                    El registro VBK (0xFF4F) bit 0 selecciona qué banco ve la CPU, pero el PPU puede acceder a ambos bancos simultáneamente durante el renderizado. En modo DMG (Game Boy clásico), solo existe el bank 0.
                </p>
                <p>
                    <strong>Problema identificado:</strong> El PPU estaba usando <code>mmu_->read()</code> que lee desde <code>memory_[]</code>, pero en modo CGB los datos de VRAM están en <code>vram_bank0_</code> y <code>vram_bank1_</code>, no en <code>memory_[]</code>. Esto causaba que el PPU siempre leyera 0x00 o datos incorrectos.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - CGB Registers, VRAM Banks (0xFF4F - VBK)
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase A: Triage Dirigido (Sin Conjeturas)</h3>
                <p>
                    Se añadió instrumentación de debug para verificar:
                </p>
                <ul>
                    <li><strong>A1 - Contadores de BG render:</strong> <code>bg_pixels_written_count_</code>, <code>first_nonzero_color_idx_seen_</code>, <code>first_nonzero_color_idx_value_</code></li>
                    <li><strong>A2 - Captura de bytes VRAM leídos:</strong> <code>last_tile_bytes_read_[2]</code>, <code>last_tile_addr_read_</code>, <code>last_tile_bytes_valid_</code></li>
                </ul>
                <p>
                    <strong>Resultado:</strong> ✅ Instrumentación funcionando. Evidencia: <code>bg_pixels_written=23040</code>, <code>PPU leyó desde addr 0x8000: [0x55, 0x33]</code>
                </p>

                <h3>Fase B: Fix Mínimo - Ruta de Lectura VRAM Correcta</h3>
                <p>
                    Se implementó <code>MMU::read_vram()</code> que lee directamente desde los bancos VRAM:
                </p>
                <pre><code>inline uint8_t read_vram(uint16_t addr) const {
    if (addr < 0x8000 || addr > 0x9FFF) {
        return 0xFF;  // Fuera de rango
    }
    uint16_t offset = addr - 0x8000;
    uint8_t bank = 0;  // Por defecto bank 0 (DMG)
    if (bank == 0) {
        if (offset < vram_bank0_.size()) {
            return vram_bank0_[offset];
        }
    } else if (bank == 1) {
        if (offset < vram_bank1_.size()) {
            return vram_bank1_[offset];
        }
    }
    return 0xFF;
}</code></pre>
                <p>
                    Se modificó el PPU para usar <code>read_vram()</code> en lugar de <code>read()</code> para todos los accesos a VRAM:
                </p>
                <ul>
                    <li><code>decode_tile_line()</code> - Lectura de bytes de tile</li>
                    <li><code>render_bg()</code> - Lectura de tilemap y tile data</li>
                    <li><code>render_window()</code> - Lectura de tilemap y tile data</li>
                </ul>
                <p>
                    <strong>Resultado:</strong> ✅ PPU lee bytes VRAM correctos. Evidencia: <code>[TEST-PPU-VRAM-READ] PPU leyó desde addr 0x8000: [0x55, 0x33]</code>
                </p>

                <h3>Fase C: Validar Addressing</h3>
                <p>
                    Se añadió validación explícita de LCDC en el test para asegurar que el addressing es correcto:
                </p>
                <ul>
                    <li>LCDC bit 7 = LCD ON</li>
                    <li>LCDC bit 0 = BG ON</li>
                    <li>LCDC bit 4 = Tile Data Table (1 = 0x8000, 0 = 0x8800)</li>
                    <li>LCDC bit 3 = BG Tile Map (1 = 0x9C00, 0 = 0x9800)</li>
                </ul>
                <p>
                    <strong>Resultado:</strong> ✅ Addressing validado. Test escribe tile en 0x8000 y tilemap en 0x9800, PPU lee desde las direcciones correctas.
                </p>

                <h3>Fix Adicional: Swap de Framebuffers</h3>
                <p>
                    Se identificó que el test no llamaba a <code>get_frame_ready_and_reset()</code> antes de leer el framebuffer, causando que el swap no se ejecutara. Se añadió la llamada en el test.
                </p>
                <p>
                    <strong>Resultado:</strong> ✅ Swap funcionando. Evidencia: <code>[PPU-SWAP-DETAILED] Front first 20 pixels: 0 1 2 3 0 1 2 3...</code>
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.hpp</code> - Añadido método <code>read_vram()</code></li>
                    <li><code>src/core/cpp/PPU.hpp</code> - Añadidos miembros de debug (bajo <code>#ifdef VIBOY_DEBUG_PPU</code>)</li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Modificado para usar <code>read_vram()</code> y añadida instrumentación de debug</li>
                    <li><code>src/core/cython/ppu.pxd</code> - Añadidas declaraciones de métodos de debug</li>
                    <li><code>src/core/cython/ppu.pyx</code> - Añadidos wrappers: <code>get_bg_render_stats()</code>, <code>get_last_tile_bytes_read_info()</code></li>
                    <li><code>setup.py</code> - Añadido flag <code>-DVIBOY_DEBUG_PPU</code> para compilación</li>
                    <li><code>tests/test_palette_dmg_bgp_0454.py</code> - Añadidas verificaciones A1, A2, C y llamada a <code>get_frame_ready_and_reset()</code></li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Comando ejecutado:</strong> <code>pytest -v tests/test_palette_dmg_bgp_0454.py::test_dmg_bgp_palette_mapping</code>
                </p>
                <p>
                    <strong>Resultado:</strong> ✅ Instrumentación funcionando, índices correctos. El test aún falla en conversión RGB (tema separado).
                </p>
                <p>
                    <strong>Evidencia numérica:</strong>
                </p>
                <pre><code>[TEST-BG-RENDER] bg_pixels_written=23040, nonzero_seen=True, nonzero_value=1
[TEST-PPU-VRAM-READ] PPU leyó desde addr 0x8000: [0x55, 0x33]
[TEST-BGP-SANITY] Índices sample (8 píxeles): [0, 1, 2, 3, 0, 1, 2, 3]
[TEST-BGP-SANITY] Índices únicos: {0, 1, 2, 3}
[PPU-SWAP-DETAILED] Front first 20 pixels: 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3</code></pre>
                <p>
                    <strong>Validación de módulo compilado C++:</strong> ✅ Compilación exitosa con <code>-DVIBOY_DEBUG_PPU</code>, sin errores.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs - CGB Registers, VRAM Banks (0xFF4F - VBK)</li>
                    <li>Pan Docs - Background, Tile Data, Tile Maps</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>VRAM Banking en CGB:</strong> VRAM está en bancos separados (<code>vram_bank0_</code>, <code>vram_bank1_</code>), no en <code>memory_[]</code>. El PPU necesita acceso directo a estos bancos durante el renderizado.</li>
                        <li><strong>Separación de responsabilidades:</strong> <code>MMU::read()</code> es para la CPU y puede tener restricciones de modo PPU. <code>MMU::read_vram()</code> es específico para el PPU y siempre lee desde los bancos VRAM correctos.</li>
                        <li><strong>Swap de framebuffers:</strong> El swap se ejecuta en <code>get_frame_ready_and_reset()</code>. Los tests deben llamar a este método antes de leer el framebuffer para obtener los datos del frame más reciente.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Conversión RGB:</strong> El test aún falla en la conversión RGB (solo 2 colores únicos en lugar de 3+). Esto es un tema separado que requiere investigación adicional.</li>
                    </ul>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Investigar conversión RGB - Por qué solo genera 2 colores únicos en lugar de 4</li>
                    <li>[ ] Verificar aplicación de paleta BGP en <code>convert_framebuffer_to_rgb()</code></li>
                    <li>[ ] Re-ejecutar tests de paleta completos una vez corregida la conversión RGB</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

