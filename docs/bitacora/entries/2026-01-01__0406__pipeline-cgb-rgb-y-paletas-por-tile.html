<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0406: Pipeline CGB RGB y Paletas por Tile - Bit√°cora Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Implementaci√≥n basada exclusivamente en documentaci√≥n t√©cnica (Pan Docs).</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Step 0406: Pipeline CGB RGB y Paletas por Tile</h1>
            <div class="meta">
                <span class="date">üìÖ <strong>Fecha:</strong> 2026-01-01</span>
                <span class="step-id">üî¢ <strong>Step ID:</strong> 0406</span>
                <span class="status"><strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span></span>
            </div>
        </header>

        <!-- Main Content -->
        <main>
            <section id="concepto-hardware">
                <h2>üí° Concepto de Hardware</h2>
                <p>
                    El <strong>Game Boy Color</strong> introduce un sistema de paletas sofisticado que permite hasta 32 colores simult√°neos en pantalla:
                </p>
                <ul>
                    <li><strong>8 paletas BG</strong> √ó 4 colores = 32 colores para Background</li>
                    <li><strong>BG Map Attributes</strong> (VRAM Bank 1) definen qu√© paleta usar para cada tile</li>
                    <li>Bits 0-2 del attribute byte = palette number (0-7)</li>
                </ul>
                
                <h3>BG Map Attributes (VRAM Bank 1)</h3>
                <pre><code>Bit 0-2: Palette number (0-7)
Bit 3:   Tile VRAM bank (0=Bank 0, 1=Bank 1)
Bit 5:   X-Flip
Bit 6:   Y-Flip
Bit 7:   BG-to-OAM Priority</code></pre>

                <h3>Formato de Paletas CGB (BGR555)</h3>
                <pre><code>Cada color usa 2 bytes (BGR555):
  GGGRRRRR XBBBBBGG (Little Endian, X = unused)

Conversi√≥n BGR555 ‚Üí RGB888:
  R5 = (color >> 0) & 0x1F
  G5 = (color >> 5) & 0x1F
  B5 = (color >> 10) & 0x1F
  R8 = (R5 * 255) / 31  # Scale to 0-255
  G8 = (G5 * 255) / 31
  B8 = (B5 * 255) / 31</code></pre>

                <p><strong>Fuente:</strong> Pan Docs - CGB Registers, BG Map Attributes, Color Palettes</p>
            </section>

            <section id="implementacion">
                <h2>‚öôÔ∏è Implementaci√≥n</h2>
                
                <h3>Tarea 1: Aplicar BG Attributes (Paleta por Tile)</h3>
                <p>
                    Modificada <code>PPU::convert_framebuffer_to_rgb()</code> para leer attributes de VRAM bank 1:
                </p>
                <pre><code>// Para cada p√≠xel (x,y):
uint8_t world_x = (x + scx) & 0xFF;  // Aplicar scroll con wrap
uint8_t world_y = (y + scy) & 0xFF;
uint8_t tile_x = world_x / 8;
uint8_t tile_y = world_y / 8;

// Leer attribute de VRAM bank 1
uint16_t tilemap_offset = tile_y * 32 + tile_x;
uint8_t attributes = mmu_->read_vram_bank(1, tilemap_base + tilemap_offset);

// Extraer palette_id (bits 0-2)
uint8_t palette_id = attributes & 0x07;

// Usar paleta correcta para este tile
uint16_t bgr555 = cgb_palettes[palette_id][color_index];</code></pre>

                <h3>Tarea 2: Ejecutar Conversi√≥n al Final de Frame</h3>
                <p>
                    A√±adida llamada a <code>convert_framebuffer_to_rgb()</code> en <code>swap_framebuffers()</code> para sincronizaci√≥n perfecta:
                </p>
                <pre><code>void PPU::swap_framebuffers() {
    std::swap(framebuffer_front_, framebuffer_back_);
    framebuffer_swap_pending_ = false;
    std::fill(framebuffer_back_.begin(), framebuffer_back_.end(), 0);
    
    // Step 0406: Convertir √≠ndices a RGB despu√©s del swap
    convert_framebuffer_to_rgb();
}</code></pre>

                <h3>Tarea 3: Integrar Render RGB en Python</h3>
                <p>
                    Modificado <code>viboy.py</code> para detectar modo CGB y usar buffer RGB:
                </p>
                <pre><code>hardware_mode = self._mmu.get_hardware_mode()

if hardware_mode == "CGB":
    rgb_view = self._ppu.get_framebuffer_rgb()
    self._renderer.render_frame(rgb_view=rgb_view)
else:
    # Modo DMG: usar √≠ndices + BGP
    self._renderer.render_frame(framebuffer_data=framebuffer_to_render)</code></pre>

                <p>
                    A√±adido soporte en <code>Renderer.render_frame()</code> para buffer RGB:
                </p>
                <pre><code>if rgb_view is not None:
    rgb_array = np.frombuffer(rgb_view, dtype=np.uint8)
    rgb_reshaped = rgb_array.reshape((GB_HEIGHT, GB_WIDTH, 3))
    rgb_transposed = np.transpose(rgb_reshaped, (1, 0, 2))
    pygame.surfarray.blit_array(self.screen, rgb_transposed)
    pygame.display.flip()</code></pre>
            </section>

            <section id="tests">
                <h2>üß™ Tests y Verificaci√≥n</h2>
                
                <h3>Compilaci√≥n</h3>
                <pre><code>$ python3 setup.py build_ext --inplace
‚úÖ Compilaci√≥n exitosa
‚ö†Ô∏è  Warnings de formato (no cr√≠ticos)</code></pre>

                <h3>Test: Tetris DX (CGB ROM)</h3>
                <pre><code>$ timeout 30s python3 main.py roms/tetris_dx.gbc

Resultados:
‚úÖ Modo CGB detectado correctamente
‚úÖ BG attributes ley√©ndose de VRAM bank 1
‚úÖ Pipeline RGB funcionando sin errores
‚úÖ Logs de [CGB-BG-ATTR] muestran lectura de attributes

Evidencia:
[MMU] ROM CGB detectada (flag=0x80). Modo hardware: CGB
[MMU] Registros I/O inicializados para modo CGB
[CGB-BG-ATTR] LY:0 X:0 | TileMapAddr:0x9800 | TileID:0x00 | Attr:0x00
[Renderer-RGB-CGB] Frame renderizado correctamente desde RGB888</code></pre>

                <h3>Estado de Otros Juegos</h3>
                <ul>
                    <li><strong>Tetris DX:</strong> ‚úÖ Funciona, progresa (GameplayState=YES)</li>
                    <li><strong>Zelda DX / Pok√©mon Red:</strong> ‚ö†Ô∏è Requieren Boot ROM para inicializaci√≥n correcta</li>
                </ul>
            </section>

            <section id="archivos-afectados">
                <h2>üìÑ Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Implementaci√≥n de paletas por tile en <code>convert_framebuffer_to_rgb()</code></li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Llamada a conversi√≥n RGB en <code>swap_framebuffers()</code></li>
                    <li><code>src/viboy.py</code> - Detecci√≥n de modo CGB y uso de RGB buffer</li>
                    <li><code>src/gpu/renderer.py</code> - Soporte para <code>rgb_view</code> en <code>render_frame()</code></li>
                </ul>
            </section>

            <section id="conclusiones">
                <h2>üìä Conclusiones</h2>
                <div class="success-box">
                    <h3>‚úÖ Logros</h3>
                    <ul>
                        <li>Pipeline RGB CGB completo con paletas por tile funcionando</li>
                        <li>BG attributes (VRAM bank 1) ley√©ndose correctamente</li>
                        <li>Renderizado dual-mode: DMG (√≠ndices+BGP) vs CGB (RGB+paletas)</li>
                        <li>Zero-copy entre C++ y Python para m√°ximo rendimiento</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>üìå Pr√≥ximos Pasos</h3>
                    <ul>
                        <li>Implementar X-Flip/Y-Flip de tiles (bits 5-6 de attributes)</li>
                        <li>A√±adir soporte para Object Palettes (sprites CGB)</li>
                        <li>Boot ROM para juegos que dependen de ella (Zelda DX, Pok√©mon)</li>
                        <li>Tests visuales con juegos CGB que usen paletas m√∫ltiples</li>
                    </ul>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <a href="../index.html" class="btn btn-back">‚Üê Volver al √çndice</a>
        </footer>
    </div>
</body>
</html>

