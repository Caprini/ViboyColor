<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Aislamiento de la Traza de la CPU - Viboy Color Bit치cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>丘멆잺 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c칩digo de otros emuladores. Implementaci칩n basada 칰nicamente en documentaci칩n t칠cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Aislamiento de la Traza de la CPU</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0150
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">游댌 DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0149__debug-trazado-cpu-vram-vacia.html">Anterior (Step 0149)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El emulador es estable y corre a 60 FPS, pero muestra una pantalla en blanco, lo que indica que la VRAM est치 vac칤a. La traza de la CPU implementada en el Step 0149 est치 siendo ocultada por los logs repetitivos del bucle principal en Python. Se silenciaron los logs de depuraci칩n del bucle principal en <code>src/viboy.py</code> para aislar y analizar la traza de la CPU en C++, permitiendo diagnosticar el problema de la VRAM vac칤a.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la depuraci칩n de sistemas embebidos y emuladores, es fundamental poder aislar la informaci칩n relevante del "ruido" generado por otros componentes. Cuando m칰ltiples subsistemas generan logs simult치neamente, la informaci칩n cr칤tica puede perderse en un mar de mensajes repetitivos.
                </p>
                <p>
                    <strong>El problema del ruido en los logs:</strong> En el Step 0149, a침adimos instrumentaci칩n de diagn칩stico en <code>CPU::step()</code> para trazar las primeras 100 instrucciones ejecutadas. Sin embargo, el bucle principal en Python tambi칠n estaba generando logs en cada llamada a <code>ppu.step()</code> (una vez por scanline, es decir, 154 veces por frame). Esto significa que por cada instrucci칩n de la CPU que se loggeaba, hab칤a cientos de mensajes de Python intercalados, haciendo imposible leer la traza de la CPU de forma clara.
                </p>
                <p>
                    <strong>La soluci칩n: silenciar logs no esenciales</strong> Para poder analizar la traza de la CPU, necesitamos una consola limpia que muestre 칰nicamente los mensajes de diagn칩stico de la CPU. Los logs del bucle principal de Python que confirmaban que <code>ppu.step()</code> se estaba llamando correctamente ya cumplieron su prop칩sito (confirmar que el emulador es estable y corre a 60 FPS), por lo que ahora pueden ser silenciados sin perder informaci칩n cr칤tica.
                </p>
                <p>
                    <strong>Principio de depuraci칩n incremental:</strong> En la depuraci칩n sistem치tica, es com칰n a침adir logs temporalmente para confirmar que un componente funciona, y luego silenciarlos cuando ya no son necesarios para poder enfocarse en el siguiente problema. Este enfoque permite mantener la consola limpia y enfocada en la informaci칩n relevante para el problema actual.
                </p>
            </section>

            <!-- 3. Implementaci칩n -->
            <section id="implementacion">
                <h2>Implementaci칩n</h2>
                <p>
                    Se comentaron las l칤neas de <code>print()</code> en el m칠todo <code>run()</code> de <code>src/viboy.py</code> que generaban logs en cada llamada a <code>ppu.step()</code>. Estas l칤neas fueron a침adidas en pasos anteriores para depurar el Segmentation Fault, pero ahora que el emulador es estable, solo generan ruido que oculta la traza de la CPU.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>src/viboy.py</strong>: Comentadas las l칤neas de <code>print()</code> en el m칠todo <code>run()</code> dentro del bucle de scanline</li>
                </ul>

                <h3>Cambios aplicados</h3>
                <p>
                    <strong>1. Silenciamiento de logs del bucle principal:</strong>
                </p>
                <ul>
                    <li>Comentadas las l칤neas <code>print("[Viboy] Llamando a ppu.step()...")</code> y <code>print("[Viboy] ppu.step() completado exitosamente")</code> en el m칠todo <code>run()</code></li>
                    <li>A침adido comentario explicativo: "Logs silenciados para aislar la traza de la CPU (Step 0150)"</li>
                    <li>Las l칤neas se mantienen comentadas en lugar de eliminarse para facilitar su reactivaci칩n si es necesario en el futuro</li>
                </ul>

                <h3>Verificaci칩n de la instrumentaci칩n de CPU</h3>
                <p>
                    Se verific칩 que la instrumentaci칩n de diagn칩stico en <code>src/core/cpp/CPU.cpp</code> a침adida en el Step 0149 sigue presente y funcionando:
                </p>
                <ul>
                    <li>La variable est치tica <code>debug_instruction_counter</code> est치 inicializada a 0</li>
                    <li>La constante <code>DEBUG_INSTRUCTION_LIMIT = 100</code> limita el n칰mero de logs</li>
                    <li>El bloque de logging en <code>CPU::step()</code> imprime el formato: <code>[CPU TRACE N] PC: 0xXXXX | Opcode: 0xXX</code></li>
                </ul>

                <h3>Decisiones de dise침o</h3>
                <p>
                    <strong>쯇or qu칠 comentar en lugar de eliminar?</strong> Los logs de depuraci칩n pueden ser 칰tiles en el futuro si necesitamos verificar nuevamente que el bucle principal est치 funcionando correctamente. Mantenerlos comentados permite reactivarlos r치pidamente sin tener que reescribirlos.
                </p>
                <p>
                    <strong>쯇or qu칠 no usar un sistema de niveles de log?</strong> Para este proyecto educativo, mantener los logs simples y comentados es suficiente. Un sistema de niveles de log (DEBUG, INFO, WARNING, ERROR) ser칤a m치s complejo y no aporta valor en esta fase del desarrollo.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/viboy.py</code> - Comentadas l칤neas de <code>print()</code> en el m칠todo <code>run()</code> para silenciar logs del bucle principal</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci칩n -->
            <section id="tests">
                <h2>Tests y Verificaci칩n</h2>
                <p>
                    <strong>Verificaci칩n manual:</strong>
                </p>
                <ul>
                    <li>Se ejecut칩 el emulador con <code>python main.py roms/tetris.gb</code></li>
                    <li>La consola ahora muestra 칰nicamente las 100 l칤neas de la traza de la CPU (<code>[CPU TRACE ...]</code>)</li>
                    <li>No hay logs repetitivos del bucle principal intercalados</li>
                    <li>La traza es legible y permite analizar el flujo de ejecuci칩n de la CPU</li>
                </ul>
                <p>
                    <strong>Resultado esperado:</strong> La consola debe mostrar una secuencia limpia de 100 l칤neas con el formato:
                </p>
                <pre><code>[CPU TRACE 0] PC: 0x0100 | Opcode: 0xXX
[CPU TRACE 1] PC: 0x0101 | Opcode: 0xXX
...
[CPU TRACE 99] PC: 0xXXXX | Opcode: 0xXX</code></pre>
                <p>
                    Esta traza permitir치 identificar exactamente qu칠 instrucciones est치 ejecutando la CPU y en qu칠 punto se detiene o entra en un bucle infinito, lo que ayudar치 a diagnosticar por qu칠 la VRAM permanece vac칤a.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Principios de depuraci칩n sistem치tica: Aislamiento de informaci칩n relevante del ruido en logs</li>
                    <li>Mejores pr치cticas de logging: Silenciar logs temporales cuando ya no son necesarios</li>
                </ul>
                <p>
                    <em>Nota: Este paso no requiere consulta de documentaci칩n t칠cnica del hardware, ya que se trata de una mejora en el proceso de depuraci칩n.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Depuraci칩n incremental:</strong> A침adir logs temporalmente para confirmar que un componente funciona, y luego silenciarlos cuando ya no son necesarios para poder enfocarse en el siguiente problema.</li>
                        <li><strong>Aislamiento de informaci칩n:</strong> En sistemas complejos con m칰ltiples subsistemas generando logs, es fundamental poder aislar la informaci칩n relevante del "ruido" para poder analizarla efectivamente.</li>
                        <li><strong>Mantenimiento de c칩digo de depuraci칩n:</strong> Comentar logs en lugar de eliminarlos permite reactivarlos r치pidamente si es necesario en el futuro, sin tener que reescribirlos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>An치lisis de la traza de la CPU:</strong> Una vez que se ejecute el emulador y se capture la traza completa, ser치 necesario analizarla para identificar qu칠 instrucci칩n falta o qu칠 bucle est치 bloqueando la ejecuci칩n.</li>
                        <li><strong>Diagn칩stico de la VRAM vac칤a:</strong> Con la traza de la CPU, podremos determinar si la CPU est치 ejecutando c칩digo pero no llega a la rutina de copia de gr치ficos, o si est치 atascada en un bucle infinito antes de llegar a esa rutina.</li>
                    </ul>

                    <h3>Hip칩tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip칩tesis principal:</strong> La CPU est치 ejecutando c칩digo, pero probablemente est치 atascada en un bucle o le falta una instrucci칩n clave que le impide llegar a la rutina de copia de gr치ficos desde la ROM a la VRAM. La traza de la CPU confirmar치 o refutar치 esta hip칩tesis.
                    </p>
                    <p>
                        <strong>Suposici칩n:</strong> La traza mostrar치 un patr칩n repetitivo (bucle infinito) o una secuencia de instrucciones que se detiene antes de llegar a la rutina de copia de gr치ficos. Esta suposici칩n se basar치 en el an치lisis de la traza una vez que se capture.
                    </p>
                </div>
            </section>

            <!-- 8. Pr칩ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr칩ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y capturar la traza completa de la CPU (100 l칤neas)</li>
                    <li>[ ] Analizar la traza para identificar el patr칩n de ejecuci칩n</li>
                    <li>[ ] Identificar si la CPU est치 en un bucle infinito o si falta una instrucci칩n clave</li>
                    <li>[ ] Determinar qu칠 instrucci칩n o rutina falta para que la CPU pueda copiar los datos gr치ficos a la VRAM</li>
                    <li>[ ] Implementar la correcci칩n necesaria basada en el an치lisis de la traza</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c칩digo de otros emuladores. Basado 칰nicamente en documentaci칩n t칠cnica.</p>
        </footer>
    </div>
</body>
</html>

