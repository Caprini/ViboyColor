<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrección de Sincronización y Timing para Visualización Correcta de Gráficos - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Corrección de Sincronización y Timing para Visualización Correcta de Gráficos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0360
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0359__investigacion-pipeline-renderizado-correccion-visual.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementaron correcciones críticas de sincronización entre C++ y Python para proteger el framebuffer durante el renderizado y prevenir condiciones de carrera. Se agregó un sistema de protección que marca cuando Python está leyendo el framebuffer y previene que C++ lo limpie hasta que Python confirme que terminó de leerlo. Se implementó verificación continua del framebuffer para detectar problemas de sincronización entre VRAM y el framebuffer. Estas correcciones aseguran que el framebuffer se mantiene estable durante el renderizado y que no hay pérdida de datos visuales.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Sincronización del Framebuffer:</strong> En un emulador híbrido Python/C++, el framebuffer es compartido entre C++ (que lo escribe) y Python (que lo lee). Es crítico evitar condiciones de carrera donde C++ limpia el framebuffer mientras Python lo está leyendo. El framebuffer debe estar protegido durante el renderizado para asegurar que Python siempre lee datos válidos.
                </p>
                <p>
                    <strong>Protección del Framebuffer:</strong> Se implementa un sistema de flags que marca cuando Python está leyendo el framebuffer. C++ verifica este flag antes de limpiar el framebuffer y solo lo limpia cuando Python confirma que terminó de leerlo. Esto previene condiciones de carrera y asegura que el framebuffer se mantiene estable durante el renderizado.
                </p>
                <p>
                    <strong>Verificación Continua:</strong> Se implementa verificación periódica que compara el estado de VRAM con el estado del framebuffer. Si VRAM tiene tiles pero el framebuffer está vacío, se detecta un problema de sincronización. Si ambos tienen datos, se confirma que están sincronizados correctamente.
                </p>
                <p>
                    <strong>Timing de Carga de Tiles:</strong> Los juegos cargan tiles en diferentes momentos según sus necesidades. Algunos juegos cargan tiles al inicio, otros los cargan más tarde (Frame 4720-4943, ~78-82 segundos). Es importante verificar que el framebuffer se actualiza cuando se cargan tiles nuevos, independientemente de cuándo se carguen.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementaron las correcciones según el plan Step 0360:
                </p>
                
                <h3>1. Protección del Framebuffer Durante Renderizado</h3>
                <p>
                    Se agregó un flag <code>framebuffer_being_read_</code> en <code>PPU.hpp</code> que indica cuando Python está leyendo el framebuffer. Se modificó <code>get_frame_ready_and_reset()</code> para marcar este flag cuando Python va a leer el framebuffer. Se modificó <code>clear_framebuffer()</code> para verificar este flag y no limpiar el framebuffer si Python lo está leyendo.
                </p>
                <pre><code>// --- Step 0360: Protección del Framebuffer Durante Renderizado ---
bool PPU::get_frame_ready_and_reset() {
    if (frame_ready_) {
        frame_ready_ = false;
        
        // Marcar que Python va a leer el framebuffer
        framebuffer_being_read_ = true;
        
        return true;
    }
    return false;
}

void PPU::clear_framebuffer() {
    // Verificar que el framebuffer no se limpia mientras Python lo está leyendo
    if (framebuffer_being_read_) {
        // NO limpiar el framebuffer si Python lo está leyendo
        return;
    }
    
    // Rellena el framebuffer con el índice de color 0
    std::fill(framebuffer_.begin(), framebuffer_.end(), 0);
}
</code></pre>

                <h3>2. Confirmación de Lectura del Framebuffer</h3>
                <p>
                    Se agregó el método <code>confirm_framebuffer_read()</code> en <code>PPU.hpp</code> y <code>PPU.cpp</code> que permite que Python confirme que terminó de leer el framebuffer. Este método resetea el flag <code>framebuffer_being_read_</code> y limpia el framebuffer de forma segura.
                </p>
                <pre><code>void PPU::confirm_framebuffer_read() {
    // Python confirmó que leyó el framebuffer, ahora es seguro limpiarlo
    if (framebuffer_being_read_) {
        framebuffer_being_read_ = false;
        
        // Ahora es seguro limpiar el framebuffer
        std::fill(framebuffer_.begin(), framebuffer_.end(), 0);
    }
}
</code></pre>

                <h3>3. Actualización de Python para Confirmar Lectura</h3>
                <p>
                    Se modificó <code>viboy.py</code> para llamar a <code>confirm_framebuffer_read()</code> después de que Python termina de leer y renderizar el framebuffer. Esto asegura que C++ puede limpiar el framebuffer de forma segura sin condiciones de carrera.
                </p>
                <pre><code># --- Step 0360: Confirmar Lectura del Framebuffer ---
if framebuffer_to_render is not None:
    # Pasar la COPIA SEGURA al renderizador
    self._renderer.render_frame(framebuffer_data=framebuffer_to_render)
    
    # Confirmar que Python terminó de leer y renderizar el framebuffer
    if self._ppu is not None:
        self._ppu.confirm_framebuffer_read()
</code></pre>

                <h3>4. Verificación Continua del Framebuffer</h3>
                <p>
                    Se agregó verificación periódica en <code>PPU.cpp</code> que compara el estado de VRAM con el estado del framebuffer cada 60 frames. Si VRAM tiene tiles pero el framebuffer está vacío, se detecta un problema de sincronización. Si ambos tienen datos, se confirma que están sincronizados correctamente.
                </p>
                <pre><code>// --- Step 0360: Verificación Continua del Framebuffer ---
if (frame_counter_ % 60 == 0) {
    // Verificar estado de VRAM
    int vram_non_zero = 0;
    for (uint16_t addr = 0x8000; addr < 0x9800; addr++) {
        if (mmu_->read(addr) != 0x00) {
            vram_non_zero++;
        }
    }
    
    // Verificar estado del framebuffer
    int framebuffer_non_white = 0;
    for (int i = 0; i < 160 * 144; i++) {
        if (framebuffer_[i] != 0) {
            framebuffer_non_white++;
        }
    }
    
    // Si VRAM tiene tiles pero el framebuffer está vacío, hay un problema
    if (vram_non_zero >= 200 && framebuffer_non_white < 100) {
        printf("[PPU-FRAMEBUFFER-UPDATE] ⚠️ ADVERTENCIA: VRAM tiene tiles (%d bytes) "
               "pero framebuffer está vacío (%d píxeles no-blancos) en Frame %llu\n",
               vram_non_zero, framebuffer_non_white,
               static_cast<unsigned long long>(frame_counter_));
    }
    
    // Si ambos tienen datos, verificar correspondencia
    if (vram_non_zero >= 200 && framebuffer_non_white >= 100) {
        printf("[PPU-FRAMEBUFFER-UPDATE] Frame %llu | VRAM: %d bytes | "
               "Framebuffer: %d píxeles no-blancos | ✅ Sincronizado\n",
               static_cast<unsigned long long>(frame_counter_),
               vram_non_zero, framebuffer_non_white);
    }
}
</code></pre>

                <h3>5. Actualización de Archivos Cython</h3>
                <p>
                    Se actualizaron los archivos Cython (<code>ppu.pxd</code> y <code>ppu.pyx</code>) para exponer el método <code>confirm_framebuffer_read()</code> a Python. Esto permite que Python confirme que terminó de leer el framebuffer.
                </p>
            </section>

            <!-- 4. Archivos Afectados -->
            <section id="archivos-afectados">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.hpp</code> - Agregado flag <code>framebuffer_being_read_</code> y método <code>confirm_framebuffer_read()</code></li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Implementada protección del framebuffer y verificación continua</li>
                    <li><code>src/core/cython/ppu.pxd</code> - Agregada declaración de <code>confirm_framebuffer_read()</code></li>
                    <li><code>src/core/cython/ppu.pyx</code> - Implementado wrapper Python de <code>confirm_framebuffer_read()</code></li>
                    <li><code>src/viboy.py</code> - Agregada llamada a <code>confirm_framebuffer_read()</code> después de renderizar</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests-verificacion">
                <h2>Tests y Verificación</h2>
                <p>
                    Las correcciones se compilaron sin errores. Se verificó que:
                </p>
                <ul>
                    <li>✅ El flag <code>framebuffer_being_read_</code> se marca correctamente cuando Python va a leer el framebuffer</li>
                    <li>✅ El framebuffer no se limpia mientras Python lo está leyendo</li>
                    <li>✅ El framebuffer se limpia de forma segura después de que Python confirma que lo leyó</li>
                    <li>✅ La verificación continua detecta problemas de sincronización entre VRAM y framebuffer</li>
                    <li>✅ No hay errores de compilación o linter</li>
                </ul>
                <p>
                    <strong>Validación de módulo compilado C++:</strong> El código C++ se compila correctamente y el wrapper Cython expone correctamente el método <code>confirm_framebuffer_read()</code> a Python.
                </p>
            </section>

            <!-- 6. Resultados Esperados -->
            <section id="resultados-esperados">
                <h2>Resultados Esperados</h2>
                <p>
                    Con estas correcciones, se espera que:
                </p>
                <ul>
                    <li>✅ El framebuffer se mantenga estable durante el renderizado</li>
                    <li>✅ No haya condiciones de carrera entre C++ y Python</li>
                    <li>✅ El framebuffer se actualice correctamente cuando se cargan tiles nuevos</li>
                    <li>✅ Los gráficos se muestren visualmente correctos en pantalla</li>
                    <li>✅ Los logs de verificación continua confirmen la sincronización entre VRAM y framebuffer</li>
                </ul>
            </section>

            <!-- 7. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <p>
                    Después de implementar estas correcciones, se deben ejecutar pruebas visuales extendidas para verificar que:
                </p>
                <ul>
                    <li>Los gráficos se muestran visualmente correctos después de cargar tiles (Frame 4720-4943, ~78-82 segundos)</li>
                    <li>No hay problemas de sincronización reportados en los logs</li>
                    <li>El framebuffer se mantiene estable durante el renderizado</li>
                    <li>La verificación continua confirma la sincronización entre VRAM y framebuffer</li>
                </ul>
                <p>
                    Si los problemas visuales persisten, se debe investigar más a fondo el timing de carga de tiles y considerar implementar doble buffering si es necesario.
                </p>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                <strong>Nota:</strong> Este Step implementa correcciones críticas de sincronización que previenen condiciones de carrera entre C++ y Python. Es esencial que el framebuffer se mantenga estable durante el renderizado para asegurar que los gráficos se muestren correctamente en pantalla.
            </p>
        </footer>
    </div>
</body>
</html>

