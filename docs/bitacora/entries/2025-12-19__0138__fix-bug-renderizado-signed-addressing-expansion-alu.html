<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix: Bug de Renderizado en Signed Addressing y Expansión de la ALU - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Fix: Bug de Renderizado en Signed Addressing y Expansión de la ALU</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0138
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0137__correccion-test-renderizado-ejecucion-tetris.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se mejoró la validación de direcciones en el método <code>render_scanline()</code> de la PPU para prevenir Segmentation Faults cuando se calculan direcciones de tiles en modo <strong>signed addressing</strong>. La corrección asegura que tanto la dirección base del tile como la dirección de la línea del tile (incluyendo el byte siguiente) estén dentro de los límites de VRAM (0x8000-0x9FFF). Además, se verificó que el bloque completo de la ALU (0x80-0xBF) esté implementado correctamente, confirmando que todos los 64 opcodes de operaciones aritméticas y lógicas están disponibles para la ejecución de juegos.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    La Game Boy tiene dos modos de direccionamiento para los tiles en VRAM:
                </p>
                <ul>
                    <li><strong>Unsigned Addressing (bit 4 de LCDC = 1)</strong>: Los tile IDs van de 0 a 255, y los tiles se almacenan desde la dirección 0x8000. Cada tile ID se multiplica por 16 (cada tile son 16 bytes) para obtener la dirección: <code>dirección = 0x8000 + (tile_id * 16)</code>.</li>
                    <li><strong>Signed Addressing (bit 4 de LCDC = 0)</strong>: Los tile IDs se interpretan como valores con signo (-128 a 127), y el tile 0 está en la dirección 0x9000 (no en 0x8800). La fórmula es: <code>dirección = 0x9000 + (signed_tile_id * 16)</code>.</li>
                </ul>
                <p>
                    El problema crítico es que cuando se usa signed addressing, un tile ID de 128 (0x80) se interpreta como -128, lo que resulta en una dirección de <code>0x9000 + (-128 * 16) = 0x9000 - 0x800 = 0x8800</code>. Sin embargo, si el tile ID es muy negativo o muy positivo, el cálculo puede resultar en direcciones fuera de VRAM (menor que 0x8000 o mayor que 0x9FFF), causando Segmentation Faults cuando la PPU intenta leer esos datos.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - Tile Data Addressing, LCD Control Register (LCDC)
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se mejoró la validación de direcciones en <code>PPU::render_scanline()</code> para asegurar que:
                </p>
                <ol>
                    <li>La dirección base del tile esté dentro de VRAM y tenga espacio suficiente para los 16 bytes del tile completo (verificando que <code>tile_addr <= VRAM_END - 15</code>).</li>
                    <li>La dirección de la línea del tile (que se calcula como <code>tile_addr + tile_y_offset * 2</code>) y el byte siguiente (<code>tile_line_addr + 1</code>) estén ambos dentro de VRAM.</li>
                </ol>
                <p>
                    Esta validación doble previene accesos fuera de límites que causaban Segmentation Faults cuando la PPU intentaba renderizar tiles con IDs que resultaban en direcciones inválidas.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code>: Mejora de la validación de direcciones en <code>render_scanline()</code> para cubrir todos los casos edge, incluyendo tiles que se extienden hasta el límite de VRAM.</li>
                </ul>

                <h3>Verificación del Bloque ALU</h3>
                <p>
                    Se verificó que el bloque completo de la ALU (0x80-0xBF) esté implementado correctamente en <code>CPU.cpp</code>. Este bloque contiene 64 opcodes que implementan operaciones aritméticas y lógicas entre el registro A y otros registros o memoria:
                </p>
                <ul>
                    <li><strong>0x80-0x87</strong>: ADD A, r (Suma)</li>
                    <li><strong>0x88-0x8F</strong>: ADC A, r (Suma con Carry)</li>
                    <li><strong>0x90-0x97</strong>: SUB r (Resta)</li>
                    <li><strong>0x98-0x9F</strong>: SBC A, r (Resta con Carry)</li>
                    <li><strong>0xA0-0xA7</strong>: AND r (AND lógico)</li>
                    <li><strong>0xA8-0xAF</strong>: XOR r (XOR lógico)</li>
                    <li><strong>0xB0-0xB7</strong>: OR r (OR lógico)</li>
                    <li><strong>0xB8-0xBF</strong>: CP r (Comparar)</li>
                </ul>
                <p>
                    Todos los opcodes están implementados correctamente, incluyendo las variantes que acceden a memoria a través de (HL).
                </p>

                <h3>Decisiones de diseño</h3>
                <p>
                    La validación mejorada usa comparaciones con límites ajustados (<code>VRAM_END - 15</code> para tiles completos y <code>VRAM_END - 1</code> para líneas de tiles) para asegurar que no solo la dirección base, sino también todos los bytes necesarios, estén dentro de VRAM. Esto es crítico porque un tile completo son 16 bytes, y una línea de tile son 2 bytes consecutivos.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Mejora de la validación de direcciones en <code>render_scanline()</code> para prevenir Segmentation Faults en modo signed addressing</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    La corrección se validó mediante:
                </p>
                <ul>
                    <li><strong>Test existente:</strong> <code>test_signed_addressing_fix</code> en <code>tests/test_core_ppu_rendering.py</code> verifica que el cálculo de direcciones en modo signed es correcto y que no se producen Segmentation Faults.</li>
                    <li><strong>Validación del bloque ALU:</strong> Se verificó mediante <code>grep</code> que todos los 64 opcodes del bloque 0x80-0xBF estén implementados en <code>CPU.cpp</code>.</li>
                    <li><strong>Linter:</strong> No se encontraron errores de compilación o linter en el código modificado.</li>
                </ul>
                
                <h3>Comando de test</h3>
                <pre><code>pytest tests/test_core_ppu_rendering.py::TestCorePPURendering::test_signed_addressing_fix -v</code></pre>
                
                <h3>Código del test relevante</h3>
                <pre><code>def test_signed_addressing_fix(self) -> None:
    """Verifica que el cálculo de dirección en modo signed es correcto."""
    mmu = PyMMU()
    ppu = PyPPU(mmu)
    
    # LCDC con bit 4=0 (signed addressing activo)
    mmu.write(0xFF40, 0x81)
    
    # Tile ID 128 (que se interpreta como -128 en modo signed)
    # Dirección esperada: 0x9000 + (-128 * 16) = 0x8800
    mmu.write(0x9800, 128)
    
    # Escribir tile en 0x8800
    for line in range(8):
        mmu.write(0x8800 + (line * 2), 0xFF)
        mmu.write(0x8800 + (line * 2) + 1, 0xFF)
    
    # Avanzar PPU hasta completar una línea
    ppu.step(456)
    
    # Verificar que no hay Segmentation Fault y que el renderizado es correcto
    framebuffer = ppu.get_framebuffer()
    assert framebuffer[0] == 3  # Color 3 (negro)</code></pre>
                
                <p>
                    <strong>Validación de módulo compilado C++:</strong> El test valida que la PPU C++ puede renderizar tiles en modo signed addressing sin causar Segmentation Faults, confirmando que la validación de direcciones funciona correctamente.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Data.html">Tile Data Addressing</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/LCDC.html">LCD Control Register (LCDC)</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/CPU_Instruction_Set.html">CPU Instruction Set - ALU Operations</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Signed Addressing en PPU:</strong> El modo signed addressing usa 0x9000 como base (no 0x8800), y los tile IDs se interpretan como valores con signo (-128 a 127). Esto permite acceder a tiles tanto por encima como por debajo del tile 0, pero requiere validación cuidadosa para prevenir accesos fuera de VRAM.</li>
                        <li><strong>Validación de Direcciones:</strong> Es crítico validar no solo la dirección base, sino también todos los bytes que se van a leer (en este caso, 2 bytes consecutivos para una línea de tile). Además, debemos considerar el tamaño completo del tile (16 bytes) al validar la dirección base.</li>
                        <li><strong>Bloque ALU Completo:</strong> El bloque 0x80-0xBF contiene todas las operaciones aritméticas y lógicas fundamentales de la CPU. Cada operación tiene 8 variantes (una por cada registro B, C, D, E, H, L, (HL), A), resultando en 64 opcodes totales.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Rendimiento:</strong> Verificar que la validación adicional no impacta significativamente el rendimiento del renderizado, especialmente en el bucle crítico de 160 píxeles por línea.</li>
                        <li><strong>Casos Edge:</strong> Probar con tile IDs extremos (0, 127, 128, 255) en ambos modos de direccionamiento para asegurar que la validación cubre todos los casos posibles.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        Asumimos que la validación con límites ajustados (<code>VRAM_END - 15</code> y <code>VRAM_END - 1</code>) es suficiente para prevenir todos los accesos fuera de límites. Esto se basa en el conocimiento de que un tile completo son 16 bytes y una línea de tile son 2 bytes consecutivos.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el módulo C++ y ejecutar todos los tests para verificar que la corrección no rompe funcionalidad existente</li>
                    <li>[ ] Ejecutar el emulador con la ROM de Tetris para verificar que el renderizado funciona correctamente sin Segmentation Faults</li>
                    <li>[ ] Medir el rendimiento del renderizado para confirmar que la validación adicional no impacta significativamente el rendimiento</li>
                    <li>[ ] Documentar el hito de "fix completo del bug de renderizado" con capturas de pantalla si es posible</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

