<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitor de Arranque Inmediato - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Monitor de Arranque Inmediato</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0065
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0064__sensor-vram-diagnostico.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implement√≥ un sistema de monitorizaci√≥n agresiva del arranque del emulador para detectar
                    "deadlocks silenciosos". El sistema imprime el estado de la CPU (PC, SP) en los primeros 20
                    pasos del bucle principal y a√±ade protecci√≥n contra opcodes que devuelven 0 ciclos, evitando
                    que el emulador se congele en un bucle infinito matem√°tico.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En un Game Boy real, cada instrucci√≥n de la CPU consume un n√∫mero determinado de ciclos de
                    m√°quina (M-Cycles). El reloj del sistema avanza continuamente, y cada componente (CPU, PPU,
                    Timer) consume ciclos para avanzar su estado interno.
                </p>
                <p>
                    Si una instrucci√≥n devolviera 0 ciclos (lo cual no deber√≠a ocurrir en hardware real), el
                    contador de tiempo del emulador nunca avanzar√≠a, causando que el bucle principal se quede
                    atascado en la misma instrucci√≥n infinitamente. Esto es un "deadlock silencioso": el programa
                    no crashea, pero tampoco progresa.
                </p>
                <p>
                    El diagn√≥stico de arranque permite identificar:
                </p>
                <ul>
                    <li><strong>PC estancado:</strong> Si el Program Counter no cambia entre pasos, la CPU est√°
                        ejecutando la misma instrucci√≥n repetidamente (posible bucle infinito en el c√≥digo del juego
                        o bug en el emulador).</li>
                    <li><strong>Bloqueo en inicializaci√≥n:</strong> Si el emulador se atasca antes de completar
                        el primer segundo, el problema est√° en la fase de arranque (posiblemente esperando un evento
                        que nunca ocurre).</li>
                    <li><strong>Opcode con 0 ciclos:</strong> Si se detecta una instrucci√≥n que devuelve 0 ciclos,
                        hay un bug en la implementaci√≥n del opcode que causa deadlock matem√°tico.</li>
                </ul>
                <p>
                    <strong>Fuente:</strong> Pan Docs - CPU Instruction Set, Timing, System Clock
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Se a√±adieron dos mecanismos de diagn√≥stico en <code>src/viboy.py</code>:
                </p>
                
                <h3>1. Monitor de Arranque (Boot Monitor)</h3>
                <p>
                    Al inicio del bucle principal <code>run()</code>, se a√±adi√≥ un contador <code>debug_step_counter</code>
                    que imprime el estado de la CPU (PC y SP) en los primeros 20 pasos del bucle. Esto permite
                    verificar que la CPU est√° ejecutando instrucciones y avanzando el Program Counter.
                </p>
                <pre><code># DEBUG: Monitor de arranque agresivo
debug_step_counter = 0

while True:
    # DEBUG: Monitor de arranque - imprimir los primeros 20 pasos
    if debug_step_counter < 20:
        pc = self._cpu.registers.get_pc()
        sp = self._cpu.registers.get_sp()
        print(f"üöÄ BOOT STEP {debug_step_counter}: PC={pc:04X} | SP={sp:04X}", flush=True)
    debug_step_counter += 1</code></pre>

                <h3>2. Protecci√≥n contra Ciclos Cero</h3>
                <p>
                    En el m√©todo <code>tick()</code>, se a√±adi√≥ una verificaci√≥n que detecta si la CPU devuelve
                    0 ciclos. Si esto ocurre, se fuerza al menos 1 ciclo para evitar que el contador de tiempo
                    se congele. Esta protecci√≥n se aplica tanto en ejecuci√≥n normal como en estado HALT.
                </p>
                <pre><code># Ejecutar una instrucci√≥n normal
cycles = self._cpu.step()

# CR√çTICO: Protecci√≥n contra bucle infinito
if cycles == 0:
    pc = self._cpu.registers.get_pc()
    print(f"üö® ALERTA: CPU devolvi√≥ 0 ciclos en PC={pc:04X}!", flush=True)
    cycles = 1  # Forzar avance para no colgar</code></pre>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>Print directo en lugar de logger:</strong> Se usa <code>print()</code> con
                        <code>flush=True</code> para garantizar visibilidad inmediata, incluso si el nivel de
                        logging est√° en WARNING o ERROR.</li>
                    <li><strong>L√≠mite de 20 pasos:</strong> Los primeros 20 pasos son suficientes para detectar
                        bloqueos inmediatos sin saturar la salida.</li>
                    <li><strong>Forzar 1 ciclo m√≠nimo:</strong> Si se detecta 0 ciclos, se fuerza 1 ciclo para
                        evitar deadlock, pero se mantiene el aviso para que el desarrollador sepa que hay un bug
                        en el opcode.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/viboy.py</code> - A√±adido monitor de arranque y protecci√≥n contra ciclos cero</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    Este cambio es puramente diagn√≥stico y no requiere tests unitarios. La validaci√≥n se realiza
                    ejecutando el emulador y observando la salida del monitor de arranque.
                </p>
                <p>
                    <strong>Comando ejecutado:</strong> <code>python main.py pkmn.gb --verbose</code>
                </p>
                <p>
                    <strong>Entorno:</strong> Windows, Python 3.13.5
                </p>
                <p>
                    <strong>Resultado:</strong> ‚úÖ PASSED - El monitor de arranque funcion√≥ correctamente
                </p>
                <p>
                    <strong>Observaciones:</strong>
                </p>
                <ul>
                    <li>‚úÖ La CPU est√° ejecutando instrucciones normalmente (PC avanza: 0x0100 ‚Üí 0x0101 ‚Üí 0x0150 ‚Üí ... ‚Üí 0x1F68)</li>
                    <li>‚úÖ No aparecieron alertas de "0 ciclos" (no hay opcodes problem√°ticos detectados)</li>
                    <li>‚úÖ El emulador se ejecut√≥ sin deadlock silencioso (el usuario lo detuvo manualmente con Ctrl+C despu√©s de 4211 ciclos)</li>
                    <li>‚ö†Ô∏è El heartbeat no apareci√≥ porque el emulador se detuvo antes de completar 60 frames (solo 4211 ciclos ejecutados, insuficiente para generar frames)</li>
                </ul>
                <p>
                    <strong>Interpretaci√≥n:</strong> El problema original (no ver heartbeat) no es un deadlock silencioso.
                    La CPU est√° funcionando correctamente. El siguiente paso es verificar si la PPU est√° generando frames
                    correctamente, ya que el <code>frame_count</code> solo se incrementa cuando <code>ppu.is_frame_ready()</code>
                    devuelve <code>True</code>.
                </p>
                <p>
                    <strong>Pr√≥ximo diagn√≥stico necesario:</strong> A√±adir monitor del estado de la PPU (LY, modo, frames generados)
                    para determinar si el problema est√° en que la PPU no est√° llegando a V-Blank o si hay otro problema.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set, Timing, System Clock</a></li>
                </ul>
                <p>
                    <em>Nota: La protecci√≥n contra 0 ciclos es una medida de seguridad del emulador. En hardware
                    real, todas las instrucciones consumen al menos 1 M-Cycle.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Deadlock silencioso:</strong> Un programa puede quedar atascado sin crashear,
                            especialmente si el contador de tiempo no avanza (ciclos == 0).</li>
                        <li><strong>Diagn√≥stico de arranque:</strong> Imprimir el estado de la CPU en los primeros
                            pasos permite identificar r√°pidamente d√≥nde se produce el bloqueo.</li>
                        <li><strong>Protecci√≥n defensiva:</strong> Aunque en hardware real no deber√≠a ocurrir, es
                            √∫til a√±adir verificaciones que detecten condiciones an√≥malas y eviten deadlocks.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Comportamiento real:</strong> Necesito ejecutar el emulador con una ROM para
                            verificar qu√© muestra el monitor de arranque y si detecta el problema del deadlock.</li>
                        <li><strong>Opcode problem√°tico:</strong> Si aparece la alerta de 0 ciclos, necesito
                            identificar qu√© opcode est√° causando el problema y corregirlo.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis principal:</strong> El emulador se est√° atascando en el bucle principal
                        antes de poder completar un segundo de ejecuci√≥n. El monitor de arranque permitir√° identificar
                        si el problema es:
                    </p>
                    <ul>
                        <li>Un PC que no avanza (bucle infinito en el c√≥digo del juego o bug en el emulador)</li>
                        <li>Un opcode que devuelve 0 ciclos (bug en la implementaci√≥n)</li>
                        <li>Un bloqueo en pygame.event.pump() o en la inicializaci√≥n gr√°fica</li>
                    </ul>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[x] Ejecutar el emulador con una ROM y observar la salida del monitor de arranque ‚úÖ</li>
                    <li>[x] Verificar que la CPU est√° ejecutando correctamente ‚úÖ</li>
                    <li>[ ] A√±adir monitor del estado de la PPU (LY, modo, frames generados) para diagnosticar por qu√© no aparece el heartbeat</li>
                    <li>[ ] Verificar si la PPU est√° llegando a V-Blank (l√≠nea 144) y marcando frames como listos</li>
                    <li>[ ] Si la PPU no est√° generando frames, investigar el timing o el estado del LCD (LCDC bit 7)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

