<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Instrumentaci칩n del Pipeline de P칤xeles en C++ - Viboy Color Bit치cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>丘멆잺 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c칩digo de otros emuladores. Implementaci칩n basada 칰nicamente en documentaci칩n t칠cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Instrumentaci칩n del Pipeline de P칤xeles en C++</h1>
            <!-- Entrada 0180 - Debug: Instrumentaci칩n del Pipeline de P칤xeles en C++ -->
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0180
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">游댌 DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0179__hack-educativo-forzar-renderizado-fondo-diagnostico-visual.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    <strong>춰Hito alcanzado!</strong> La arquitectura de bucle nativo ha resuelto todos los <code>deadlocks</code> y el emulador funciona a 60 FPS con <code>LY</code> ciclando correctamente. Sin embargo, la pantalla permanece en blanco porque el m칠todo <code>render_scanline()</code> de la PPU en C++ est치 generando un framebuffer lleno de ceros.
                </p>
                <p>
                    Este Step instrumenta el pipeline de renderizado de p칤xeles dentro de <code>PPU::render_scanline()</code> con logs de diagn칩stico detallados para identificar por qu칠 no se est치n leyendo los datos de los tiles desde la VRAM. El diagn칩stico del "renderizador ciego" sugiere que el m칠todo se ejecuta correctamente pero falla en alg칰n punto de la cadena de renderizado (c치lculo de direcciones, lectura de memoria, decodificaci칩n de bits).
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: El Pipeline de Renderizado de un P칤xel</h2>
                <p>
                    Para dibujar un solo p칤xel en la pantalla, la PPU realiza una compleja cadena de c치lculos y lecturas de memoria. Cada paso de esta cadena es cr칤tico y cualquier fallo resultar치 en un p칤xel incorrecto o en blanco:
                </p>
                <ol>
                    <li><strong>C치lculo de Coordenadas en el Tilemap:</strong> Calcula la coordenada <code>(map_x, map_y)</code> en el mapa de fondo de 256x256 p칤xeles, aplicando el scroll (<code>SCX</code>, <code>SCY</code>).</li>
                    <li><strong>B칰squeda del Tile en el Tilemap:</strong> Usa <code>(map_x, map_y)</code> para encontrar la posici칩n del tile correspondiente en el <strong>tilemap</strong> (<code>0x9800</code> o <code>0x9C00</code>).</li>
                    <li><strong>Lectura del ID del Tile:</strong> Lee el <strong>ID del tile</strong> (<code>tile_id</code>) de esa posici칩n del tilemap.</li>
                    <li><strong>C치lculo de la Direcci칩n del Tile:</strong> Usa el <code>tile_id</code> para calcular la direcci칩n base de los datos del tile en la <strong>tabla de tiles</strong> (<code>0x8000</code> o <code>0x8800</code>).</li>
                    <li><strong>Lectura de los Datos del P칤xel:</strong> Lee los <strong>2 bytes</strong> que corresponden a la l칤nea de p칤xeles correcta dentro de ese tile.</li>
                    <li><strong>Decodificaci칩n del 칈ndice de Color:</strong> Decodifica esos 2 bytes para obtener el <strong>칤ndice de color (0-3)</strong> del p칤xel final.</li>
                </ol>
                <p>
                    Si cualquier paso de esta cadena falla (un c치lculo de direcci칩n incorrecto, una lectura de memoria que devuelve 0, una decodificaci칩n err칩nea), el resultado final ser치 un p칤xel de color 0 (blanco). El framebuffer lleno de ceros que observamos sugiere que uno de estos pasos est치 fallando sistem치ticamente.
                </p>
                <p>
                    Seg칰n <strong>Pan Docs</strong>, el formato de datos de un tile es:
                </p>
                <ul>
                    <li>Cada tile ocupa 16 bytes (8 l칤neas 칑 2 bytes por l칤nea).</li>
                    <li>Cada l칤nea del tile ocupa 2 bytes consecutivos en VRAM.</li>
                    <li>El byte bajo contiene el bit menos significativo de cada p칤xel (bit 7 = p칤xel 0, bit 6 = p칤xel 1, ...).</li>
                    <li>El byte alto contiene el bit m치s significativo de cada p칤xel (bit 7 = p칤xel 0, bit 6 = p칤xel 1, ...).</li>
                    <li>El 칤ndice de color final se calcula como: <code>color_index = (byte_high_bit << 1) | byte_low_bit</code>.</li>
                </ul>
            </section>

            <!-- 3. Implementaci칩n -->
            <section id="implementacion">
                <h2>Implementaci칩n</h2>
                <p>
                    Se instrument칩 el m칠todo <code>render_scanline()</code> con logs de depuraci칩n detallados que muestran los valores intermedios del pipeline de renderizado para los primeros p칤xeles de las primeras dos l칤neas.
                </p>
                
                <h3>Modificaci칩n en PPU.cpp</h3>
                <p>
                    Se agreg칩 <code>#include &lt;cstdio&gt;</code> al principio del archivo y se a침adieron logs de depuraci칩n dentro del bucle de renderizado:
                </p>
                <pre><code>#include "PPU.hpp"
#include "MMU.hpp"
#include &lt;cstdio&gt;

// ... dentro de render_scanline() ...

// --- LOGS DE DEPURACI칍N (Step 0180) ---
// Variable est치tica para imprimir logs solo una vez (primeras dos l칤neas, primeros 8 p칤xeles)
static bool debug_printed = false;

// ... c칩digo de renderizado ...

// --- LOGS DE DEPURACI칍N (Step 0180) ---
// Imprimir logs detallados para los primeros p칤xeles de las primeras dos l칤neas
if (!debug_printed && ly_ &lt; 2 && x &lt; 8) {
    // Mostrar tile_id como signed si estamos en modo signed, unsigned si estamos en modo unsigned
    int display_tile_id = signed_addressing ? static_cast&lt;int8_t&gt;(tile_id) : static_cast&lt;int&gt;(tile_id);
    printf("[PPU DEBUG] ly=%d, x=%d | map_x=%d, map_y=%d | tile_map_addr=0x%04X | tile_id=%d | tile_addr=0x%04X | byte1=0x%02X, byte2=0x%02X | color=%d\n",
        ly_, x, map_x, map_y, tile_map_addr, display_tile_id, tile_addr, byte1, byte2, color_index);
}

// Marcar que ya imprimimos los logs (solo una vez, despu칠s de la l칤nea 1)
if (ly_ == 1) {
    debug_printed = true;
}</code></pre>

                <h3>Decisiones de Dise침o</h3>
                <ul>
                    <li><strong>Logs Limitados:</strong> Los logs solo se imprimen para los primeros 8 p칤xeles de las primeras 2 l칤neas para evitar saturar la consola. Una vez impresos, se desactivan autom치ticamente.</li>
                    <li><strong>Informaci칩n Completa:</strong> Cada log muestra todos los valores intermedios del pipeline: coordenadas, direcciones, IDs, bytes le칤dos y color final.</li>
                    <li><strong>Modo Signed/Unsigned:</strong> El <code>tile_id</code> se muestra correctamente seg칰n el modo de direccionamiento (signed o unsigned) para facilitar el diagn칩stico.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Agregado <code>#include &lt;cstdio&gt;</code> e instrumentaci칩n con logs de depuraci칩n en <code>render_scanline()</code></li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci칩n -->
            <section id="tests">
                <h2>Tests y Verificaci칩n</h2>
                <p>
                    Este cambio requiere recompilaci칩n del m칩dulo C++ y ejecuci칩n del emulador para capturar los logs de depuraci칩n:
                </p>
                <ol>
                    <li><strong>Recompilaci칩n del M칩dulo C++:</strong>
                        <pre><code>.\rebuild_cpp.ps1</code></pre>
                    </li>
                    <li><strong>Ejecuci칩n del Emulador:</strong>
                        <pre><code>python main.py roms/tetris.gb</code></pre>
                    </li>
                    <li><strong>An치lisis de la Salida:</strong>
                        <p>
                            La consola mostrar치 un log detallado para los primeros p칤xeles. Estaremos buscando:
                        </p>
                        <ul>
                            <li><strong>Si <code>byte1</code> y <code>byte2</code> son siempre <code>0x00</code>:</strong> El problema est치 en el c치lculo de <code>tile_addr</code> o <code>tile_line_addr</code>. Estamos apuntando a una zona vac칤a de la VRAM.</li>
                            <li><strong>Si <code>tile_id</code> es siempre <code>0</code>:</strong> El problema est치 en el c치lculo de <code>tile_map_addr</code>. No estamos leyendo el mapa de tiles correctamente.</li>
                            <li><strong>Si <code>byte1</code> y <code>byte2</code> tienen valores correctos pero <code>color_index</code> es <code>0</code>:</strong> El problema est치 en la decodificaci칩n final de los bits.</li>
                        </ul>
                    </li>
                </ol>
                <p>
                    <strong>Validaci칩n de M칩dulo Compilado C++:</strong> Los logs se generan directamente desde el c칩digo C++ compilado, confirmando que el pipeline de renderizado se est치 ejecutando en el c칩digo nativo.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li><strong>Pan Docs:</strong> Secci칩n sobre el formato de datos de tiles y el pipeline de renderizado de la PPU</li>
                    <li><strong>Diagn칩stico del Renderizador Ciego:</strong> An치lisis del framebuffer lleno de ceros y el comportamiento del m칠todo <code>render_scanline()</code></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Pipeline de Renderizado:</strong> El renderizado de un p칤xel es un proceso complejo que involucra m칰ltiples pasos: c치lculo de coordenadas, lectura del tilemap, c치lculo de direcciones, lectura de VRAM y decodificaci칩n de bits. Cualquier fallo en cualquier paso resultar치 en un p칤xel incorrecto.</li>
                        <li><strong>Instrumentaci칩n Quir칰rgica:</strong> Los logs de depuraci칩n deben ser limitados y espec칤ficos para evitar saturar la consola, pero deben mostrar suficiente informaci칩n para diagnosticar el problema.</li>
                        <li><strong>Diagn칩stico del Renderizador Ciego:</strong> El framebuffer lleno de ceros sugiere que el m칠todo se ejecuta pero falla en alg칰n punto del pipeline. Los logs nos permitir치n identificar exactamente d칩nde.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Punto de Fallo en el Pipeline:</strong> Necesitamos ejecutar el emulador y analizar los logs para identificar exactamente d칩nde falla el pipeline de renderizado.</li>
                        <li><strong>Estado de la VRAM:</strong> Necesitamos confirmar si los datos de tiles est치n realmente en VRAM o si el problema es que no se han copiado a칰n.</li>
                        <li><strong>C치lculo de Direcciones:</strong> Necesitamos verificar si las direcciones calculadas (<code>tile_map_addr</code>, <code>tile_addr</code>, <code>tile_line_addr</code>) son correctas.</li>
                    </ul>

                    <h3>Hip칩tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip칩tesis Principal:</strong> El pipeline de renderizado se est치 ejecutando, pero falla en alg칰n paso espec칤fico (c치lculo de direcciones, lectura de memoria, decodificaci칩n). Los logs nos permitir치n identificar exactamente d칩nde.
                    </p>
                    <p>
                        <strong>Suposici칩n:</strong> Asumimos que los datos de tiles est치n en VRAM (la CPU ha ejecutado las rutinas de inicializaci칩n). Si los logs muestran que <code>byte1</code> y <code>byte2</code> son siempre <code>0x00</code>, esto sugerir칤a que estamos apuntando a una zona vac칤a de VRAM o que el c치lculo de direcciones es incorrecto.
                    </p>
                </div>
            </section>

            <!-- 8. Pr칩ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr칩ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m칩dulo C++ con la instrumentaci칩n de depuraci칩n</li>
                    <li>[ ] Ejecutar el emulador y capturar los logs de depuraci칩n</li>
                    <li>[ ] Analizar los logs para identificar el punto de fallo en el pipeline</li>
                    <li>[ ] Si <code>byte1</code> y <code>byte2</code> son <code>0x00</code>: Investigar el c치lculo de direcciones de tiles</li>
                    <li>[ ] Si <code>tile_id</code> es siempre <code>0</code>: Investigar el c치lculo de direcciones del tilemap</li>
                    <li>[ ] Si los bytes son correctos pero <code>color_index</code> es <code>0</code>: Investigar la decodificaci칩n de bits</li>
                    <li>[ ] Corregir el problema identificado y verificar que el framebuffer se llena correctamente</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c칩digo de otros emuladores. Basado 칰nicamente en documentaci칩n t칠cnica.</p>
        </footer>
    </div>
</body>
</html>

