<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Trazado de la CPU para Diagnosticar VRAM Vac칤a - Viboy Color Bit치cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>丘멆잺 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c칩digo de otros emuladores. Implementaci칩n basada 칰nicamente en documentaci칩n t칠cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Trazado de la CPU para Diagnosticar VRAM Vac칤a</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-19
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0149
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">游댌 DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-19__0148__fix-corregir-paso-punteros-cython-segmentation-fault.html">Anterior (Step 0148)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Despu칠s de resolver el <code>Segmentation Fault</code> y lograr que el emulador corra estable a 60 FPS, el siguiente problema identificado es una <strong>pantalla en blanco</strong>. El diagn칩stico indica que la VRAM est치 vac칤a porque la CPU no est치 ejecutando la rutina que copia los datos gr치ficos desde la ROM a la VRAM. Se a침adi칩 instrumentaci칩n de diagn칩stico en <code>CPU::step()</code> para trazar las primeras 100 instrucciones ejecutadas por la ROM, mostrando el PC (Program Counter) y el opcode de cada instrucci칩n. Esta traza permitir치 identificar qu칠 instrucci칩n falta o qu칠 bucle est치 bloqueando la ejecuci칩n.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy, cuando se inicia una ROM, la CPU ejecuta una secuencia de instrucciones que inicializa el hardware y copia los datos gr치ficos (tiles, sprites, mapas) desde la ROM (memoria de solo lectura) a la VRAM (Video RAM, rango <code>0x8000-0x9FFF</code>). La PPU (Picture Processing Unit) lee estos datos de la VRAM para renderizar la pantalla.
                </p>
                <p>
                    <strong>El problema de la pantalla blanca:</strong> Si la pantalla est치 en blanco pero el emulador corre a 60 FPS, significa que:
                </p>
                <ul>
                    <li>El <code>framebuffer</code> se est치 creando y pasando a Pygame correctamente</li>
                    <li>El renderizador de Python est치 dibujando el contenido del <code>framebuffer</code></li>
                    <li>El contenido del <code>framebuffer</code> es uniformemente el color de fondo (칤ndice de color 0, que nuestra paleta por defecto traduce a blanco)</li>
                </ul>
                <p>
                    Esto indica que la PPU est치 renderizando correctamente, pero est치 leyendo una <strong>VRAM que est치 completamente vac칤a (llena de ceros)</strong>. La VRAM est치 vac칤a porque la CPU a칰n no ha ejecutado la rutina de c칩digo que copia los datos gr치ficos del logo de Nintendo desde la ROM a la VRAM.
                </p>
                <p>
                    <strong>쯇or qu칠 estar칤a la VRAM vac칤a?</strong> La CPU est치 ejecutando c칩digo, pero probablemente est치 atascada en un bucle o le falta una instrucci칩n clave que le impide llegar a la rutina de copia de gr치ficos. Para diagnosticar esto, necesitamos ver exactamente qu칠 instrucciones est치 ejecutando la CPU y en qu칠 punto se detiene o entra en un bucle infinito.
                </p>
                <p>
                    <strong>La soluci칩n: trazado de instrucciones</strong> A침adiendo logs de diagn칩stico en el m칠todo <code>CPU::step()</code> que muestren el PC (Program Counter) y el opcode de cada instrucci칩n antes de ejecutarla, podemos ver el flujo exacto de ejecuci칩n. Limitando el n칰mero de logs a las primeras 100 instrucciones, obtenemos suficiente informaci칩n para identificar el problema sin saturar la consola.
                </p>
            </section>

            <!-- 3. Implementaci칩n -->
            <section id="implementacion">
                <h2>Implementaci칩n</h2>
                <p>
                    Se a침adi칩 instrumentaci칩n de diagn칩stico en <code>src/core/cpp/CPU.cpp</code> para trazar las primeras 100 instrucciones ejecutadas por la CPU. El logging muestra el contador de instrucci칩n, el PC (Program Counter) antes de leer el opcode, y el opcode le칤do.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>src/core/cpp/CPU.cpp</strong>: A침adido <code>#include &lt;cstdio&gt;</code>, variables est치ticas para contador de debug, y bloque de logging en <code>step()</code></li>
                </ul>

                <h3>Cambios aplicados</h3>
                <p>
                    <strong>1. Inclusi칩n de librer칤a de I/O:</strong>
                </p>
                <ul>
                    <li>A침adido <code>#include &lt;cstdio&gt;</code> al principio del archivo para usar <code>printf</code></li>
                </ul>

                <p>
                    <strong>2. Variables est치ticas para logging:</strong>
                </p>
                <ul>
                    <li>A침adida variable est치tica <code>debug_instruction_counter</code> para contar las instrucciones loggeadas</li>
                    <li>A침adida constante <code>DEBUG_INSTRUCTION_LIMIT = 100</code> para limitar el n칰mero de logs</li>
                    <li>El contador se resetea a 0 en el constructor de <code>CPU</code> para cada nueva instancia</li>
                </ul>

                <p>
                    <strong>3. Bloque de logging en <code>step()</code>:</strong>
                </p>
                <ul>
                    <li>Se guarda el PC actual antes de leer el opcode (porque <code>fetch_byte()</code> incrementa el PC)</li>
                    <li>Se a침ade un bloque condicional que imprime el contador, PC y opcode si el contador es menor que el l칤mite</li>
                    <li>El formato del log es: <code>[CPU TRACE N] PC: 0xXXXX | Opcode: 0xXX</code></li>
                </ul>

                <h3>C칩digo clave</h3>
                <p>
                    <strong>Variables est치ticas a침adidas:</strong>
                </p>
                <pre><code>// Variables est치ticas para logging de diagn칩stico
static int debug_instruction_counter = 0;
static const int DEBUG_INSTRUCTION_LIMIT = 100;</code></pre>

                <p>
                    <strong>Reset del contador en el constructor:</strong>
                </p>
                <pre><code>CPU::CPU(MMU* mmu, CoreRegisters* registers)
    : mmu_(mmu), regs_(registers), cycles_(0), ime_(false), halted_(false), ime_scheduled_(false) {
    // ...
    // Resetear contador de debug al crear nueva instancia
    debug_instruction_counter = 0;
}</code></pre>

                <p>
                    <strong>Bloque de logging en <code>step()</code>:</strong>
                </p>
                <pre><code>// ========== FASE 4: Fetch-Decode-Execute ==========
// Fetch: Leer opcode de memoria
uint16_t current_pc = regs_->pc;  // Guardamos el PC actual para el log
uint8_t opcode = fetch_byte();

// --- BLOQUE DE LOGGING DE DIAGN칍STICO ---
if (debug_instruction_counter < DEBUG_INSTRUCTION_LIMIT) {
    printf("[CPU TRACE %d] PC: 0x%04X | Opcode: 0x%02X\n",
           debug_instruction_counter, current_pc, opcode);
    debug_instruction_counter++;
}
// --- FIN DEL BLOQUE DE LOGGING ---</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - A침adido <code>#include &lt;cstdio&gt;</code>, variables est치ticas para logging, y bloque de logging en <code>step()</code></li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci칩n -->
            <section id="tests">
                <h2>Tests y Verificaci칩n</h2>
                <p>
                    Para verificar la instrumentaci칩n:
                </p>
                <ol>
                    <li><strong>Recompilar el m칩dulo:</strong> Ejecutar <code>.\rebuild_cpp.ps1</code> (o <code>python setup.py build_ext --inplace</code>)</li>
                    <li><strong>Ejecutar el emulador:</strong> Ejecutar <code>python main.py roms/tetris.gb</code></li>
                    <li><strong>Analizar la salida:</strong> La consola mostrar치 las primeras 100 instrucciones ejecutadas con el formato:
                        <pre><code>[CPU TRACE 0] PC: 0x0100 | Opcode: 0x31
[CPU TRACE 1] PC: 0x0103 | Opcode: 0xAF
[CPU TRACE 2] PC: 0x0104 | Opcode: 0x21
...
[CPU TRACE 99] PC: 0xXXXX | Opcode: 0xXX</code></pre>
                    </li>
                    <li><strong>Identificar el problema:</strong> Buscar en la traza:
                        <ul>
                            <li>El 칰ltimo opcode ejecutado antes de que la CPU entre en un bucle</li>
                            <li>Un opcode no implementado (que retornar칤a 0 ciclos y causar칤a un bucle infinito)</li>
                            <li>Un bucle infinito evidente (mismo PC y opcode repetidos)</li>
                        </ul>
                    </li>
                </ol>
                <p>
                    <strong>Nota:</strong> Esta instrumentaci칩n es temporal y se eliminar치 despu칠s de identificar el problema para restaurar el rendimiento m치ximo.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set</a></li>
                    <li>GBEDG: <a href="https://gbdev.io/gb-opcodes/optables/">Opcodes Table</a></li>
                </ul>
                <p>
                    <em>Nota: La instrumentaci칩n de diagn칩stico es una t칠cnica est치ndar de depuraci칩n de bajo nivel. El formato del log sigue convenciones comunes de trazas de CPU.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Trazado de instrucciones:</strong> El trazado de instrucciones es una t칠cnica fundamental de depuraci칩n que muestra el flujo exacto de ejecuci칩n de un programa. En un emulador, esto es especialmente 칰til porque podemos ver exactamente qu칠 instrucciones est치 ejecutando la ROM y en qu칠 punto se detiene o entra en un bucle.</li>
                        <li><strong>Pantalla blanca vs Segmentation Fault:</strong> Una pantalla blanca a 60 FPS indica que el emulador est치 funcionando correctamente a nivel de sincronizaci칩n, pero la CPU no est치 ejecutando el c칩digo necesario para inicializar la VRAM. Esto es un problema diferente y m치s predecible que un Segmentation Fault.</li>
                        <li><strong>Variables est치ticas en C++:</strong> Las variables est치ticas en C++ tienen un scope de archivo y se inicializan una sola vez. Son 칰tiles para contadores globales que deben persistir entre llamadas a funciones, pero deben usarse con cuidado en contextos multi-threaded.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Opcode faltante:</strong> Necesitamos ejecutar el emulador y analizar la traza para identificar qu칠 opcode falta o qu칠 bucle est치 bloqueando la ejecuci칩n.</li>
                        <li><strong>Rutina de inicializaci칩n:</strong> Una vez identificado el opcode faltante, necesitaremos implementarlo y verificar que la CPU pueda continuar hasta la rutina de copia de gr치ficos.</li>
                    </ul>

                    <h3>Hip칩tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip칩tesis principal:</strong> La CPU est치 encontrando un opcode que a칰n no hemos migrado a C++ y que es esencial para la inicializaci칩n. Este opcode probablemente retorna 0 ciclos (porque est치 en el <code>default</code> del switch), causando que la CPU no avance y entre en un bucle infinito o se detenga.
                    </p>
                    <p>
                        <strong>Suposici칩n:</strong> El problema no est치 en la PPU ni en la MMU (ambas est치n funcionando correctamente), sino en la CPU que no puede ejecutar todas las instrucciones necesarias para inicializar la VRAM.
                    </p>
                </div>
            </section>

            <!-- 8. Pr칩ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr칩ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m칩dulo C++ con la instrumentaci칩n</li>
                    <li>[ ] Ejecutar el emulador y capturar la traza de las primeras 100 instrucciones</li>
                    <li>[ ] Analizar la traza para identificar el 칰ltimo opcode ejecutado o el bucle infinito</li>
                    <li>[ ] Implementar el opcode faltante o corregir el bucle</li>
                    <li>[ ] Verificar que la CPU pueda continuar hasta la rutina de copia de gr치ficos</li>
                    <li>[ ] Eliminar la instrumentaci칩n de diagn칩stico para restaurar el rendimiento</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c칩digo de otros emuladores. Basado 칰nicamente en documentaci칩n t칠cnica.</p>
        </footer>
    </div>
</body>
</html>

