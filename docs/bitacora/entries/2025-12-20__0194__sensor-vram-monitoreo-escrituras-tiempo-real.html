<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Sensor de VRAM: Monitoreo de Escrituras en Tiempo Real - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>El Sensor de VRAM: Monitoreo de Escrituras en Tiempo Real</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0194
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîç DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0193__limpieza-post-diagnostico-revertir-test-checkerboard.html">Anterior (0193)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El "Test del Checkerboard" del Step 0192 valid√≥ que nuestra tuber√≠a de renderizado funciona perfectamente. El diagn√≥stico es definitivo: la pantalla en blanco se debe a que la <strong>VRAM est√° vac√≠a</strong>, no a un problema de renderizado.
                </p>
                <p>
                    La hip√≥tesis actual es que la CPU nunca ejecuta el c√≥digo que copia los datos del logo de Nintendo desde la ROM a la VRAM. Est√° atrapada en un bucle l√≥gico <em>antes</em> de llegar a ese punto.
                </p>
                <p>
                    Este Step implementa un "sensor de movimiento" en la MMU que detectar√° y reportar√° la primera vez que cualquier instrucci√≥n intente escribir un byte en la VRAM (0x8000-0x9FFF). Esto nos dar√° una respuesta binaria y definitiva: ¬øla CPU intenta escribir en VRAM, s√≠ o no?
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Ingenier√≠a: El Punto √önico de Verdad (Single Point of Truth)</h2>
                <p>
                    En nuestra arquitectura, cada escritura en memoria, sin importar qu√© instrucci√≥n de la CPU la origine (<code>LD (HL), A</code>, <code>LDD (HL), A</code>, o una futura transferencia <code>DMA</code>), debe pasar a trav√©s de un √∫nico m√©todo: <code>MMU::write()</code>. Este m√©todo es nuestro "punto √∫nico de verdad" para todas las operaciones de escritura.
                </p>
                <p>
                    Al colocar un sensor de diagn√≥stico en este punto, podemos estar 100% seguros de que capturaremos cualquier intento de modificar la VRAM, d√°ndonos una respuesta definitiva: ¬øla CPU intenta escribir, s√≠ o no?
                </p>
                <p>
                    <strong>Principio del Sensor Binario:</strong> Este sensor act√∫a como un "detector de mentiras" que nos dir√° de una vez por todas si la CPU est√° cumpliendo con su parte del trato. No necesitamos capturar todas las escrituras (eso ser√≠a demasiado ruido), solo la primera. Eso es suficiente para responder a nuestra pregunta fundamental.
                </p>
                <p>
                    <strong>Rango de VRAM:</strong> El rango de memoria de VRAM en Game Boy es de <code>0x8000</code> a <code>0x9FFF</code> (8KB). Este rango contiene tanto los datos de tiles como los tilemaps. Cualquier escritura en este rango es significativa para nuestro diagn√≥stico.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Hemos a√±adido una comprobaci√≥n simple dentro del m√©todo <code>MMU::write()</code> que detecta la primera escritura en el rango de VRAM y la reporta inmediatamente en la consola.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code>: A√±adido include <code>&lt;cstdio&gt;</code> y sensor de VRAM en el m√©todo <code>write()</code></li>
                </ul>

                <h3>C√≥digo del Sensor</h3>
                <p>
                    El sensor utiliza una variable est√°tica para asegurar que el mensaje se imprima solo una vez:
                </p>
                <pre><code>void MMU::write(uint16_t addr, uint8_t value) {
    // Asegurar que la direcci√≥n est√© en el rango v√°lido
    addr &= 0xFFFF;
    
    // Enmascarar el valor a 8 bits
    value &= 0xFF;
    
    // --- SENSOR DE VRAM (Step 0194) ---
    // Variable est√°tica para asegurar que el mensaje se imprima solo una vez.
    static bool vram_write_detected = false;
    if (!vram_write_detected && addr >= 0x8000 && addr <= 0x9FFF) {
        printf("\n--- [VRAM WRITE DETECTED!] ---\n");
        printf("Primera escritura en VRAM en Addr: 0x%04X | Valor: 0x%02X\n", addr, value);
        printf("--------------------------------\n\n");
        vram_write_detected = true;
    }
    // --- Fin del Sensor ---
    
    // ... resto de la l√≥gica de write()
}</code></pre>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>Variable est√°tica:</strong> Usamos una variable est√°tica local para que el mensaje se imprima solo una vez durante toda la ejecuci√≥n del emulador. Esto evita inundar la consola con mensajes repetitivos.</li>
                    <li><strong>Detecci√≥n de primera escritura:</strong> Solo necesitamos saber si la CPU intenta escribir <em>alguna vez</em> en VRAM. La primera escritura es suficiente para responder a nuestra pregunta.</li>
                    <li><strong>Ubicaci√≥n del sensor:</strong> El sensor est√° colocado justo despu√©s de la validaci√≥n inicial de direcci√≥n y valor, pero antes de cualquier otra l√≥gica especial (registros de hardware, etc.). Esto asegura que capturamos todas las escrituras en VRAM, sin excepci√≥n.</li>
                    <li><strong>Informaci√≥n reportada:</strong> Reportamos tanto la direcci√≥n como el valor escrito, para poder analizar qu√© est√° haciendo la CPU si el sensor se activa.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - A√±adido include <code>&lt;cstdio&gt;</code> y sensor de VRAM en m√©todo <code>write()</code></li>
                    <li><code>docs/bitacora/entries/2025-12-20__0194__sensor-vram-monitoreo-escrituras-tiempo-real.html</code> - Nueva entrada de bit√°cora</li>
                    <li><code>docs/bitacora/index.html</code> - Actualizado con la nueva entrada</li>
                    <li><code>INFORME_FASE_2.md</code> - Actualizado con el Step 0194</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    La verificaci√≥n de este Step es principalmente de compilaci√≥n y ejecuci√≥n del emulador. El resultado esperado es que el sensor se active (o no) durante la ejecuci√≥n, d√°ndonos informaci√≥n definitiva sobre el comportamiento de la CPU.
                </p>
                
                <h3>Proceso de Verificaci√≥n</h3>
                <ol>
                    <li><strong>Recompilar el m√≥dulo C++:</strong>
                        <pre><code>.\rebuild_cpp.ps1</code></pre>
                        <p>Resultado: ‚úÖ Compilaci√≥n exitosa (con warnings menores esperados de variables no usadas en otros archivos)</p>
                    </li>
                    <li><strong>Ejecutar el emulador:</strong>
                        <pre><code>python main.py roms/tetris.gb</code></pre>
                        <p>El emulador debe ejecutarse normalmente. El usuario debe presionar una tecla para pasar el bucle del Joypad.</p>
                    </li>
                    <li><strong>Observar la consola:</strong>
                        <p>El sensor buscar√° el mensaje <code>[VRAM WRITE DETECTED!]</code> en la salida de la consola.</p>
                    </li>
                </ol>

                <h3>Validaci√≥n de m√≥dulo compilado C++</h3>
                <p>
                    El emulador utiliza el m√≥dulo C++ compilado (<code>viboy_core</code>), que contiene el sensor de VRAM implementado en <code>MMU::write()</code>. Cualquier escritura en VRAM pasar√° a trav√©s de este m√©todo y activar√° el sensor si corresponde.
                </p>

                <h3>Resultados Posibles</h3>
                <p>
                    Hay dos resultados posibles al ejecutar el emulador:
                </p>
                <ol>
                    <li><strong>NO aparece el mensaje <code>[VRAM WRITE DETECTED!]</code>:</strong>
                        <ul>
                            <li><strong>Significado:</strong> Nuestra hip√≥tesis es correcta. La CPU <strong>NUNCA</strong> intenta escribir en la VRAM. Est√° atrapada en un bucle l√≥gico <em>antes</em> de la rutina de copia de gr√°ficos.</li>
                            <li><strong>Diagn√≥stico:</strong> Hemos eliminado todas las causas de hardware. El problema debe ser un bucle de software en la propia ROM que no hemos previsto, quiz√°s esperando otro registro de I/O que no hemos inicializado correctamente.</li>
                            <li><strong>Siguiente Paso:</strong> Volver√≠amos a activar la traza de la CPU, pero esta vez con la confianza de que estamos buscando un bucle de software puro, no un deadlock de hardware.</li>
                        </ul>
                    </li>
                    <li><strong>S√ç aparece el mensaje <code>[VRAM WRITE DETECTED!]</code>:</strong>
                        <ul>
                            <li><strong>Significado:</strong> ¬°Nuestra hip√≥tesis principal era incorrecta! La CPU <strong>S√ç</strong> est√° escribiendo en la VRAM.</li>
                            <li><strong>Diagn√≥stico:</strong> Si la CPU est√° escribiendo en la VRAM, pero la pantalla sigue en blanco, solo puede significar una cosa: est√° escribiendo los datos equivocados (por ejemplo, ceros) o en el lugar equivocado.</li>
                            <li><strong>Siguiente Paso:</strong> Analizar√≠amos el valor y la direcci√≥n de la primera escritura para entender qu√© est√° haciendo la CPU. ¬øEst√° limpiando la VRAM antes de copiar? ¬øEst√° apuntando a una direcci√≥n incorrecta?</li>
                        </ul>
                    </li>
                </ol>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#memory-map">Memory Map</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#vram">VRAM (Video RAM)</a></li>
                    <li>Principios de ingenier√≠a de sistemas: Single Point of Truth y instrumentaci√≥n de diagn√≥stico</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>El poder del punto √∫nico de verdad:</strong> En arquitecturas bien dise√±adas, todas las operaciones de un tipo espec√≠fico (en este caso, escrituras en memoria) pasan a trav√©s de un √∫nico punto. Esto hace que la instrumentaci√≥n sea trivial y 100% confiable.</li>
                        <li><strong>Diagn√≥stico binario:</strong> A veces, la mejor herramienta de diagn√≥stico es la m√°s simple: una pregunta binaria (s√≠/no) que puede responderse con una sola observaci√≥n. No necesitamos capturar todo el flujo, solo necesitamos saber si algo est√° ocurriendo o no.</li>
                        <li><strong>Sensor de movimiento:</strong> Este sensor act√∫a como un "micr√≥fono" que nos grita en el instante en que algo ocurre. Es simple, directo y definitivo.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>¬øLa CPU intenta escribir en VRAM?</strong> Esta es la pregunta fundamental que el sensor responder√°. Dependiendo de la respuesta, sabremos exactamente hacia d√≥nde dirigir nuestros esfuerzos de diagn√≥stico.</li>
                        <li><strong>Si la CPU s√≠ escribe, ¬øqu√© est√° escribiendo?</strong> Si el sensor se activa, necesitaremos analizar el valor y la direcci√≥n para entender qu√© est√° haciendo la CPU.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis principal:</strong> La CPU nunca intenta escribir en VRAM porque est√° atrapada en un bucle l√≥gico antes de llegar a la rutina de copia de gr√°ficos. Esta hip√≥tesis se basar√° en la observaci√≥n previa de que la VRAM est√° vac√≠a y en la l√≥gica del c√≥digo de arranque de Game Boy.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> Si el sensor no se activa, entonces el problema debe ser un bucle de software en la propia ROM, posiblemente esperando un registro de hardware que no hemos inicializado correctamente o un opcode que no hemos implementado.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y observar si el sensor se activa</li>
                    <li>[ ] Si el sensor NO se activa: Analizar el flujo de ejecuci√≥n de la CPU durante el c√≥digo de arranque para identificar el bucle de software que impide el progreso</li>
                    <li>[ ] Si el sensor S√ç se activa: Analizar el valor y direcci√≥n de la primera escritura para entender qu√© est√° haciendo la CPU</li>
                    <li>[ ] Identificar la causa ra√≠z del problema (bucle de software, registro mal inicializado, opcode faltante, etc.)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

