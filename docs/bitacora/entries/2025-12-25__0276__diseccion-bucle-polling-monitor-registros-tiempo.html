<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operación Time-Lapse: Disección del Bucle de Polling y Monitor de Registros de Tiempo - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Operación Time-Lapse: Disección del Bucle de Polling y Monitor de Registros de Tiempo</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-25
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0276
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-25__0275__diseccion-rutina-inicializacion-watchdog-halt.html">Anterior (0275)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este Step implementa la "Operación Time-Lapse" para diseccionar el bucle de polling activo en el que
                    Pokémon Red está atrapado (PC: 614D - 6151). El análisis del Step 0275 reveló que el juego no está en
                    HALT, sino que está poleando (revisando constantemente) una condición. La hipótesis es que el juego está
                    esperando que un registro de hardware (como LY, DIV o el flag 0xD732) cambie, pero si nuestro Timer o PPU
                    no están avanzando correctamente, el juego se queda atrapado en el tiempo.
                </p>
                <p>
                    Se añadió instrumentación en un punto crítico: Sniper Trace del bucle atrapado (614D-6155) para
                    capturar exactamente qué opcodes ejecuta y qué valores lee de la memoria (LY, DIV, STAT, D732).
                    El objetivo es identificar qué registro está siendo poleado y si el tiempo está "congelado" para la CPU,
                    causando que el bucle de espera se vuelva infinito.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy, existen dos formas principales de sincronización entre el software y el hardware:
                    <strong>interrupciones</strong> y <strong>polling</strong>. Mientras que las interrupciones son el método
                    preferido (el hardware notifica al software cuando ocurre un evento), el polling es una alternativa que
                    algunos juegos usan para verificar el estado del hardware de forma activa.
                </p>
                
                <h3>1. Polling vs Interrupciones</h3>
                <p>
                    <strong>Interrupciones:</strong> El hardware notifica a la CPU cuando ocurre un evento (como V-Blank).
                    La CPU puede estar ejecutando otras tareas y será interrumpida automáticamente cuando el evento ocurra.
                    Esto es eficiente porque la CPU no necesita verificar constantemente el estado del hardware.
                </p>
                <p>
                    <strong>Polling:</strong> El software verifica activamente el estado del hardware leyendo registros
                    repetidamente hasta que el valor cambia. Esto consume ciclos de CPU pero puede ser necesario cuando:
                </p>
                <ul>
                    <li>Las interrupciones están deshabilitadas (IE=0 o IME=0)</li>
                    <li>El juego necesita sincronización precisa con un evento específico</li>
                    <li>El juego está en una rutina crítica donde no puede permitir interrupciones</li>
                </ul>
                
                <h3>2. Registros de Hardware que se Pueden Pollar</h3>
                <p>
                    Los juegos pueden leer varios registros de hardware para sincronización:
                </p>
                <ul>
                    <li><strong>LY (0xFF44):</strong> Línea de escaneo actual (0-153). Se incrementa automáticamente por la PPU
                        cada 456 T-Cycles. Los juegos pueden leer este registro para esperar a que la PPU complete un frame
                        o llegue a una línea específica.</li>
                    <li><strong>DIV (0xFF04):</strong> Registro de división del Timer. Se incrementa automáticamente cada
                        256 T-Cycles (frecuencia base del Timer). Los juegos pueden leer este registro para implementar
                        retardos de tiempo o esperar a que pase un intervalo específico.</li>
                    <li><strong>STAT (0xFF41):</strong> Estado de la PPU (modo actual, flags de coincidencia). Los juegos
                        pueden leer este registro para esperar a que la PPU entre en un modo específico (como V-Blank).</li>
                    <li><strong>Flags personalizados (ej: 0xD732):</strong> Algunos juegos usan flags en WRAM/HRAM para
                        comunicación entre rutinas. Una ISR puede modificar estos flags, y el código principal puede pollarlos.</li>
                </ul>
                
                <h3>3. El Peligro del "Timer Fantasma"</h3>
                <p>
                    Si un juego está poleando un registro de hardware (como DIV o LY) esperando que cambie, pero el emulador
                    no está actualizando ese registro correctamente, el juego se queda atrapado en un bucle infinito. Esto es
                    especialmente peligroso cuando:
                </p>
                <ol>
                    <li><strong>El Timer no avanza:</strong> Si el Timer no está siendo actualizado con los T-Cycles consumidos
                        por la CPU, el registro DIV permanece estático. El juego lee DIV repetidamente esperando que cambie,
                        pero nunca lo hace.</li>
                    <li><strong>La PPU no avanza:</strong> Si la PPU no está siendo actualizada después de cada instrucción,
                        el registro LY permanece estático. El juego lee LY repetidamente esperando que cambie, pero nunca lo hace.</li>
                    <li><strong>El bucle es muy apretado:</strong> Si el bucle de polling consume todos los ciclos de CPU sin
                        dar tiempo a que el Timer o la PPU avancen, el tiempo se "congela" desde la perspectiva del juego.</li>
                </ol>
                <p>
                    Este es el concepto del "Timer Fantasma": el hardware debería estar avanzando, pero desde la perspectiva del
                    software, el tiempo está congelado.
                </p>
                
                <h3>4. Sincronización en run_scanline()</h3>
                <p>
                    La función <code>run_scanline()</code> es crítica para evitar el "Timer Fantasma". Esta función ejecuta
                    instrucciones de la CPU hasta acumular 456 T-Cycles (una scanline completa), pero <strong>después de cada
                    instrucción</strong> actualiza la PPU y el Timer con los ciclos consumidos. Esto garantiza que:
                </p>
                <ul>
                    <li>La PPU avanza correctamente, actualizando LY y los modos de la PPU</li>
                    <li>El Timer avanza correctamente, actualizando DIV y TIMA</li>
                    <li>Incluso si la CPU está en un bucle apretado de polling, el hardware sigue avanzando</li>
                </ul>
                <p>
                    Si esta sincronización no está funcionando correctamente, el juego puede quedar atrapado en bucles de polling
                    infinitos esperando que el hardware haga algo que nunca ocurre.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementó una instrumentación para diseccionar el bucle de polling y entender qué registro está siendo
                    verificado:
                </p>
                
                <h3>Sniper Trace del Bucle de Polling (CPU.cpp)</h3>
                <p>
                    Se añadió un bloque de instrumentación al final de <code>CPU::step()</code> que captura el estado de la CPU
                    cuando el PC está en el rango 0x614A-0x6155 (el bucle de polling atrapado). El trace captura:
                </p>
                <ul>
                    <li><strong>PC y Opcode:</strong> La dirección actual y el opcode que se está ejecutando</li>
                    <li><strong>Registros de CPU:</strong> A, BC, HL (los registros más relevantes para el bucle)</li>
                    <li><strong>Registros de Hardware:</strong> LY (0xFF44), DIV (0xFF04), STAT (0xFF41), y el flag 0xD732</li>
                </ul>
                <p>
                    El trace se limita a 40 pasos (unas 10 vueltas al bucle) para no saturar el log. Esto nos permite ver:
                </p>
                <ul>
                    <li>Si LY, DIV o STAT están cambiando (confirmando que el hardware avanza)</li>
                    <li>Si el flag 0xD732 está cambiando (confirmando que una ISR lo modifica)</li>
                    <li>Qué opcodes se ejecutan en el bucle (para desensamblar la condición de salida)</li>
                    <li>El patrón de valores que el juego está leyendo en cada iteración</li>
                </ul>
                <p>
                    <strong>Ubicación del código:</strong> El trace se ejecuta al final de <code>step()</code>, después de que
                    la instrucción se ha ejecutado completamente. Esto garantiza que capturamos el estado real de los registros
                    después de cada instrucción del bucle.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Añadido Sniper Trace del bucle de polling (614D-6155) al final de
                        <code>step()</code> con captura de registros de hardware (LY, DIV, STAT, D732) y registros de CPU
                        (A, BC, HL)</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    La verificación se realizó ejecutando Pokémon Red y analizando los logs generados:
                </p>
                <ul>
                    <li><strong>Comando ejecutado:</strong> <code>python main.py roms/pkmn.gb</code></li>
                    <li><strong>Resultado:</strong> Se capturaron 40 trazas <code>[SNIPER-LOOP]</code> exitosamente</li>
                    <li><strong>Análisis de logs:</strong> Las trazas revelaron información crítica sobre el bucle</li>
                </ul>
                
                <h3>Resultados del Análisis</h3>
                <p>
                    <strong>Opcodes del bucle (desensamblado):</strong>
                </p>
                <ul>
                    <li><code>614A: 11</code> - LD DE, nn (carga un valor en DE)</li>
                    <li><code>614D: 00</code> - NOP</li>
                    <li><code>614E: 00</code> - NOP</li>
                    <li><code>614F: 00</code> - NOP</li>
                    <li><code>6150: 1B</code> - DEC DE (decrementa DE)</li>
                    <li><code>6151: 7A</code> - LD A, D (carga D en A)</li>
                    <li><code>6152: B3</code> - OR E (A = A | E)</li>
                    <li><code>6153: 20</code> - JR NZ, e (salto relativo si Z=0)</li>
                </ul>
                
                <p>
                    <strong>Estado de los registros de hardware:</strong>
                </p>
                <ul>
                    <li><strong>LY:</strong> 20 (constante, no cambia) - ⚠️ Posible problema de sincronización de PPU</li>
                    <li><strong>DIV:</strong> 15 → 16 (sí cambia) - ✅ Timer funciona correctamente</li>
                    <li><strong>STAT:</strong> 03 → 00 (cambia) - ✅ PPU está actualizando STAT</li>
                    <li><strong>D732:</strong> 00 (constante) - No se modifica durante el bucle</li>
                </ul>
                
                <h3>Interpretación del Bucle</h3>
                <p>
                    El bucle en <code>614D-6153</code> <strong>NO está poleando hardware</strong>. Es un bucle de retardo basado
                    en el registro DE:
                </p>
                <ol>
                    <li>Decrementa DE (<code>DEC DE</code> en 6150)</li>
                    <li>Carga D en A (<code>LD A, D</code> en 6151)</li>
                    <li>Hace OR E (<code>OR E</code> en 6152) - Si D=0 y E=0, Z=1</li>
                    <li>Salta si Z=0 (<code>JR NZ</code> en 6153) - Si Z=1, no salta y sale del bucle</li>
                </ol>
                <p>
                    <strong>Conclusión:</strong> El bucle espera a que DE llegue a 0. No está esperando que ningún registro de
                    hardware cambie. El Timer funciona correctamente (DIV avanza), pero LY está estático en 20, lo que sugiere
                    un posible problema de sincronización de la PPU.
                </p>
                
                <p>
                    <strong>Validación de módulo compilado C++:</strong> ✅ Compilación exitosa. Los logs
                    <code>[SNIPER-LOOP]</code> aparecen correctamente cuando el PC entra en el rango 614A-6155.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Timer_and_Divider_Registers.html">Timer and Divider Registers</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/STAT.html">LCD Status Register (STAT)</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Interrupts.html">Interrupts</a> - Sección sobre polling vs interrupciones</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Polling vs Interrupciones:</strong> Los juegos pueden usar polling cuando las interrupciones
                            están deshabilitadas o cuando necesitan sincronización precisa. El polling consume ciclos de CPU
                            pero es necesario en ciertos contextos.</li>
                        <li><strong>Timer Fantasma:</strong> Si el Timer o la PPU no están siendo actualizados correctamente,
                            los registros de hardware (DIV, LY) permanecen estáticos, causando que los bucles de polling se
                            vuelvan infinitos.</li>
                        <li><strong>Sincronización ciclo a ciclo:</strong> La función <code>run_scanline()</code> debe actualizar
                            la PPU y el Timer después de cada instrucción para garantizar que el hardware avanza incluso cuando
                            la CPU está en bucles apretados.</li>
                    </ul>

                    <h3>Hallazgos Confirmados</h3>
                    <ul>
                        <li><strong>Condición de salida del bucle:</strong> ✅ Confirmado. El bucle NO está poleando hardware.
                            Es un bucle de retardo basado en DE. El bucle termina cuando DE llega a 0 (cuando D=0 y E=0, OR E
                            da Z=1 y JR NZ no salta).</li>
                        <li><strong>Estado del Timer:</strong> ✅ Confirmado. El Timer está funcionando correctamente. DIV cambia
                            de 15 a 16 durante el bucle, confirmando que la sincronización del Timer funciona.</li>
                        <li><strong>Estado de la PPU:</strong> ⚠️ Problema identificado. LY está estático en 20 durante todo el
                            bucle. Esto sugiere que la PPU no está avanzando correctamente o que el juego está en un momento
                            donde LY no debería cambiar. STAT sí cambia (de 03 a 00), lo que indica que la PPU está procesando
                            algo, pero LY permanece constante.</li>
                    </ul>

                    <h3>Hipótesis Revisada</h3>
                    <p>
                        <strong>Hipótesis original (REFUTADA):</strong> El juego está poleando un registro de hardware
                        esperando que cambie. ❌ Esta hipótesis fue refutada: el bucle NO está poleando hardware, es un bucle
                        de retardo basado en DE.
                    </p>
                    <p>
                        <strong>Nueva hipótesis:</strong> El bucle es un retardo simple que debería terminar cuando DE llega a
                        0. Si el juego sigue atascado después de que DE llega a 0, el problema está en otra parte (posiblemente
                        en la lógica que sigue después del bucle, o en un problema de sincronización de la PPU que causa que LY
                        esté estático).
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[✅] Ejecutar Pokémon Red y analizar las trazas <code>[SNIPER-LOOP]</code> - COMPLETADO</li>
                    <li>[✅] Verificar si LY, DIV o STAT están cambiando - COMPLETADO (DIV y STAT cambian, LY estático)</li>
                    <li>[✅] Desensamblar los opcodes capturados - COMPLETADO (bucle de retardo basado en DE)</li>
                    <li>[ ] Investigar por qué LY está estático en 20 durante el bucle (posible problema de sincronización de PPU)</li>
                    <li>[ ] Verificar si el bucle termina cuando DE llega a 0 (el juego debería continuar)</li>
                    <li>[ ] Si el juego sigue atascado después de que DE llega a 0, investigar qué ocurre después del bucle</li>
                    <li>[ ] Si LY está estático cuando debería cambiar, corregir la sincronización de la PPU en <code>run_scanline()</code></li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

