<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silencio Total (Release Candidate) - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Silencio Total (Release Candidate)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-23
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0253
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-23__0252__rom-protection-interrupt-trace.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este Step elimina <strong>toda</strong> la instrumentación de depuración (`printf`) de `MMU.cpp` y `CPU.cpp` para permitir que el emulador corra a velocidad real (60 FPS). El Step 0252 confirmó que la lógica funcional (protección de ROM, DMA, interrupciones) está correcta, pero los miles de logs estaban ralentizando masivamente la ejecución, impidiendo ver el resultado final en pantalla. Esta es la limpieza final antes del "momento de la verdad": ejecutar Tetris a velocidad nativa.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En hardware real, la Game Boy ejecuta instrucciones a ~4.19 MHz, lo que permite renderizar 60 frames por segundo. Cada instrucción consume un número preciso de ciclos de máquina (M-Cycles), y el sistema debe mantener una sincronización perfecta entre la CPU, PPU, Timer y otros componentes.
                </p>
                <p>
                    <strong>El problema de la instrumentación:</strong> Cada llamada a `printf()` es una operación de I/O extremadamente lenta comparada con la ejecución de una instrucción de CPU. En un bucle de emulación que ejecuta millones de instrucciones por segundo, incluso un solo `printf()` por instrucción puede reducir el rendimiento de 60 FPS a 0.01 FPS reales. Para la CPU emulada, el tiempo pasa normal, pero para el usuario, el juego parece congelado.
                </p>
                <p>
                    <strong>Zero-Cost Abstractions:</strong> En el bucle crítico de emulación, cada operación debe ser lo más eficiente posible. Las abstracciones de alto nivel (como logging) deben eliminarse o moverse fuera del bucle crítico. El código C++ compilado debe ejecutarse sin overhead de I/O en el camino crítico.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - "CPU Instruction Set", "Timing", "Performance Considerations"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se eliminaron todos los `printf()` activos de los archivos críticos del núcleo, manteniendo únicamente la lógica funcional. Los logs comentados se mantienen para referencia futura, pero no se ejecutan en tiempo de ejecución.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>MMU.cpp</strong>: Eliminados logs de `[TIME]`, `[SENTINEL]`, `[DMA]`, `[WRAM-WRITE]`, `[HRAM]`. Eliminada variable estática `wram_log_count`.</li>
                    <li><strong>CPU.cpp</strong>: Eliminados logs de `[DI]`, `[EI]`, `[INT]`, `[SNIPER]`. Eliminado `#include <cstdio>`.</li>
                </ul>

                <h3>Lógica preservada</h3>
                <p>
                    Se mantiene intacta toda la lógica funcional crítica:
                </p>
                <ul>
                    <li><strong>Protección de ROM</strong> (Step 0252): Previene escrituras en `0x0000-0x7FFF`.</li>
                    <li><strong>DMA (OAM Transfer)</strong> (Step 0251): Copia 160 bytes a OAM cuando se escribe en `0xFF46`.</li>
                    <li><strong>Interrupciones</strong>: Procesamiento completo de V-Blank, LCD STAT, Timer, Serial y Joypad.</li>
                    <li><strong>Registros de Hardware</strong>: Lectura/escritura dinámica de STAT, DIV, TIMA, TMA, TAC, P1, LY.</li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    <strong>Eliminación Total de Logs:</strong> En lugar de usar flags de compilación condicionales (`#ifdef DEBUG`), se eliminaron todos los logs activos. Esto simplifica el código y garantiza que no haya overhead en builds de release. Si se necesita depuración en el futuro, se puede usar un sistema de logging más sofisticado (como un buffer circular que se vacía periódicamente) o herramientas externas (como GDB).
                </p>
                <p>
                    <strong>Preservación de Comentarios:</strong> Los logs comentados se mantienen en el código para referencia futura. Esto permite reactivar la instrumentación rápidamente si es necesario, sin perder el contexto histórico de por qué se añadieron.
                </p>
                <p>
                    <strong>Eliminación de Includes Innecesarios:</strong> Se eliminó `#include <cstdio>` de ambos archivos, ya que no hay funciones de I/O activas. Esto reduce ligeramente el tiempo de compilación y el tamaño del binario.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Eliminados todos los `printf()` activos y variable estática `wram_log_count`. Eliminado `#include <cstdio>`.</li>
                    <li><code>src/core/cpp/CPU.cpp</code> - Eliminados todos los `printf()` activos en `DI`, `EI` e `handle_interrupts()`. Eliminado `#include <cstdio>`.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    La verificación se realiza mediante compilación y ejecución a velocidad real:
                </p>
                <ul>
                    <li><strong>Compilación:</strong> El código compila sin errores ni warnings. No hay referencias a funciones no definidas.</li>
                    <li><strong>Linter:</strong> No se detectaron errores de linter en los archivos modificados.</li>
                    <li><strong>Validación Nativa:</strong> El código C++ compilado no contiene llamadas a funciones de I/O en el bucle crítico.</li>
                </ul>
                <p>
                    <strong>Prueba de Rendimiento:</strong> El emulador debe ejecutarse a 60 FPS reales cuando se ejecuta `python main.py roms/tetris.gb`. Si la lógica es correcta (y el Step 0252 sugiere que lo es), Tetris debería arrancar y mostrar el copyright o el menú principal.
                </p>
                <p>
                    <strong>Nota:</strong> Si el juego sigue mostrando una pantalla verde después de 10 segundos, el problema no es de rendimiento sino de lógica. En ese caso, se puede reactivar el logging selectivo (por ejemplo, solo en el GPS de Python) para diagnóstico.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set, Timing</a></li>
                    <li>Principios de Optimización: "Zero-Cost Abstractions" en C++</li>
                    <li>Análisis de Rendimiento: Overhead de I/O en bucles críticos</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Overhead de I/O:</strong> Las operaciones de I/O (`printf`, `std::cout`) son órdenes de magnitud más lentas que las operaciones aritméticas o de memoria. En un bucle crítico que ejecuta millones de iteraciones por segundo, incluso un solo `printf()` puede reducir el rendimiento de 60 FPS a menos de 1 FPS.</li>
                        <li><strong>Bucle Crítico:</strong> El método `step()` de la CPU se ejecuta millones de veces por segundo. Cualquier overhead en este método se multiplica por el número de instrucciones ejecutadas, haciendo que el emulador sea inutilizable.</li>
                        <li><strong>Instrumentación vs. Rendimiento:</strong> La instrumentación es esencial para el desarrollo y depuración, pero debe eliminarse o moverse fuera del bucle crítico en builds de release. El código de producción debe ser lo más eficiente posible.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Rendimiento Real:</strong> Verificar que el emulador ejecuta Tetris a 60 FPS reales sin logs. Si el rendimiento sigue siendo bajo, puede haber otros cuellos de botella (por ejemplo, en la PPU o en el bucle principal de Python).</li>
                        <li><strong>Comportamiento del Juego:</strong> Confirmar que Tetris arranca correctamente y muestra el copyright o el menú principal. Si la pantalla sigue verde, el problema es de lógica, no de rendimiento.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis Principal:</strong> El único problema restante era el overhead de los logs. Con la eliminación de todos los `printf()`, el emulador debería ejecutarse a velocidad real y Tetris debería arrancar correctamente.
                    </p>
                    <p>
                        <strong>Suposición:</strong> Si el juego sigue sin arrancar después de eliminar los logs, el problema está en la lógica de emulación (por ejemplo, un bug en el procesamiento de interrupciones o en la sincronización de componentes). En ese caso, se puede reactivar el logging selectivo para diagnóstico.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar `python main.py roms/tetris.gb` y verificar que el emulador corre a 60 FPS reales.</li>
                    <li>[ ] Confirmar que Tetris arranca y muestra el copyright o el menú principal.</li>
                    <li>[ ] Si el juego arranca correctamente, celebrar el hito y documentar el éxito.</li>
                    <li>[ ] Si la pantalla sigue verde, reactivar el logging selectivo (solo GPS de Python) para diagnóstico.</li>
                    <li>[ ] Considerar implementar un sistema de logging más sofisticado (buffer circular) para futuras depuraciones sin sacrificar rendimiento.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

