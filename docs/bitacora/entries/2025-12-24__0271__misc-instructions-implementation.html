<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Misc Instructions Implementation (DAA, CPL, SCF, CCF) - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Misc Instructions Implementation (DAA, CPL, SCF, CCF)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-24
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0271
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-23__0270__stack-operations-completion.html">Anterior (0270)</a></li>
                    <li><a href="2025-12-25__0272__mbc-unificado-e-instrumentacion-vram.html">Siguiente (0272)</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este Step implementa las instrucciones misceláneas del bloque bajo (<code>DAA</code> 0x27, <code>CPL</code> 0x2F, <code>SCF</code> 0x37, <code>CCF</code> 0x3F), los loads básicos ausentes (<code>LD (BC/DE), A</code>, <code>LD A, (BC/DE)</code>, <code>LDI/LD A, (HL±)</code>, <code>LDH (C), A</code>, <code>LDH A, (C)</code>, <code>LD (nn), A</code>, <code>LD A, (nn)</code>), añade <code>RETI</code> (0xD9) y corrige el <strong>HALT bug</strong> (IME=0 con IF&IE≠0 no se detiene). El diagnóstico del Step 0270 reveló el bucle infinito de <code>RST 38</code>; con estas instrucciones el PC ya no cae en 0x0038 ni desborda la pila.
                </p>
                <p>
                    La causa raíz era la <strong>desincronización del PC</strong> debido a instrucciones faltantes. Si falta una instrucción crítica como <code>DAA</code> (Decimal Adjust Accumulator) o un load de memoria alta (por ejemplo <code>LDH (C), A</code> para los registros de E/S), el juego calcula direcciones de memoria erróneas y crashea. Pokémon usa aritmética BCD (Binary Coded Decimal) intensivamente para la salud, el dinero y los puntos, y accede constantemente a registros en 0xFF00. Si estas instrucciones no están implementadas, los cálculos salen mal, el juego hace <code>JP HL</code> a una dirección equivocada, aterriza en una zona vacía de memoria (llena de <code>0xFF</code>), y entra en un bucle infinito de <code>RST 38</code>.
                </p>
                <p>
                    Se implementaron <strong>15 instrucciones</strong>: 4 misceláneas, 10 loads críticos y <code>RETI</code>; además se corrigió el HALT bug.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    Las instrucciones misceláneas son operaciones especiales que no encajan en las categorías estándar de Load, Aritmética, Control de Flujo, etc. Son "raras" pero vitales para el funcionamiento correcto de muchos juegos.
                </p>

                <h3>DAA (Decimal Adjust Accumulator) - 0x27</h3>
                <p>
                    <code>DAA</code> es la instrucción más compleja de emular correctamente. Ajusta el registro A para que sea un número BCD (Binary Coded Decimal) válido tras una suma o resta.
                </p>
                <p>
                    <strong>¿Qué es BCD?</strong> BCD es un sistema de codificación donde cada dígito decimal (0-9) se representa con 4 bits. Por ejemplo, el número decimal 45 se representa como <code>0100 0101</code> (4 en el nibble alto, 5 en el nibble bajo).
                </p>
                <p>
                    <strong>¿Por qué es necesario DAA?</strong> Cuando sumas dos números BCD, el resultado puede no ser un BCD válido. Por ejemplo, si sumas 0x09 + 0x01 = 0x0A, el nibble bajo es 0xA (10 en decimal), que no es un dígito BCD válido. <code>DAA</code> ajusta el resultado sumando 0x06 al nibble bajo si es mayor que 9, o al nibble alto si es mayor que 0x99.
                </p>
                <p>
                    <strong>Lógica de DAA:</strong>
                </p>
                <ul>
                    <li><strong>Después de suma (N=0):</strong>
                        <ul>
                            <li>Si C=1 o A > 0x99: suma 0x60 y activa C</li>
                            <li>Si H=1 o (A & 0x0F) > 0x09: suma 0x06</li>
                        </ul>
                    </li>
                    <li><strong>Después de resta (N=1):</strong>
                        <ul>
                            <li>Si C=1: resta 0x60</li>
                            <li>Si H=1: resta 0x06</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    <strong>Flags:</strong> Z según resultado, N (preservado), H=0 (siempre), C (actualizado si hubo overflow).
                </p>
                <p>
                    <strong>Timing:</strong> 1 M-Cycle (4 cycles).
                </p>

                <h3>CPL (Complement A) - 0x2F</h3>
                <p>
                    <code>CPL</code> invierte todos los bits del registro A (A = ~A). Es equivalente a hacer un NOT lógico bit a bit.
                </p>
                <p>
                    <strong>Ejemplo:</strong> Si A = 0b10101010, después de <code>CPL</code>, A = 0b01010101.
                </p>
                <p>
                    <strong>Flags:</strong> Z (preservado), N=1, H=1, C (preservado).
                </p>
                <p>
                    <strong>Timing:</strong> 1 M-Cycle (4 cycles).
                </p>

                <h3>SCF (Set Carry Flag) - 0x37</h3>
                <p>
                    <code>SCF</code> activa el flag Carry (C = 1). Es útil para inicializar el carry antes de operaciones ADC (Add with Carry) o SBC (Subtract with Carry).
                </p>
                <p>
                    <strong>Flags:</strong> Z (preservado), N=0, H=0, C=1.
                </p>
                <p>
                    <strong>Timing:</strong> 1 M-Cycle (4 cycles).
                </p>

                <h3>CCF (Complement Carry Flag) - 0x3F</h3>
                <p>
                    <code>CCF</code> invierte el flag Carry (C = !C). Es útil para cambiar el estado del carry sin conocer su valor actual.
                </p>
                <p>
                    <strong>Flags:</strong> Z (preservado), N=0, H=0, C=!C.
                </p>
                <p>
                    <strong>Timing:</strong> 1 M-Cycle (4 cycles).
                </p>

                <h3>¿Por qué son críticas?</h3>
                <p>
                    Si estas instrucciones faltan o están mal implementadas:
                </p>
                <ol>
                    <li>El juego intenta hacer cálculos BCD usando <code>DAA</code>.</li>
                    <li>Si no está implementada, la CPU trata ese byte como un opcode no reconocido (o NOP), <strong>pero no ajusta A</strong>.</li>
                    <li>El juego continúa ejecutando con valores incorrectos en A.</li>
                    <li>Los cálculos de direcciones de memoria salen mal (por ejemplo, <code>JP HL</code> salta a una dirección equivocada).</li>
                    <li>El juego aterriza en una zona vacía de memoria (llena de <code>0xFF</code>).</li>
                    <li>Lee <code>0xFF</code>, ejecuta <code>RST 38</code>, empuja el PC a la pila, salta a <code>0038</code>, lee <code>0xFF</code> otra vez... <strong>Bucle infinito de RST 38</strong>.</li>
                </ol>

                <p>
                    <strong>Fuente:</strong> Pan Docs - "CPU Instruction Set", "DAA Instruction", "CPL Instruction", "SCF Instruction", "CCF Instruction"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementaron 15 instrucciones en el método <code>step()</code> de <code>CPU.cpp</code>: las 4 misceláneas (DAA, CPL, SCF, CCF), 10 loads que estaban ausentes (BC/DE directos, LDI/LDD A, HL±, LDH (C), A / LDH A, (C), LD (nn), A y LD A, (nn)) y <code>RETI</code>. Se añadió también el fix del HALT bug (IME=0 con interrupción pendiente no se detiene).
                </p>

                <h3>DAA (0x27)</h3>
                <pre><code>case 0x27:  // DAA (Decimal Adjust Accumulator)
{
    uint16_t a = regs_->a;
    bool n = regs_->get_flag_n();
    bool h = regs_->get_flag_h();
    bool c = regs_->get_flag_c();
    
    if (!n) {  // Después de suma
        if (c || a > 0x99) {
            a += 0x60;
            regs_->set_flag_c(true);
        }
        if (h || (a & 0x0F) > 0x09) {
            a += 0x06;
        }
    } else {  // Después de resta
        if (c) {
            a -= 0x60;
        }
        if (h) {
            a -= 0x06;
        }
    }
    
    regs_->a = static_cast&lt;uint8_t&gt;(a);
    regs_->set_flag_z(regs_->a == 0);
    regs_->set_flag_h(false);  // H siempre se limpia en DAA
    // C se mantiene o se setea si hubo overflow en el ajuste (ya se actualizó arriba)
    
    cycles_ += 1;  // DAA consume 1 M-Cycle
    return 1;
}</code></pre>

                <h3>CPL (0x2F)</h3>
                <pre><code>case 0x2F:  // CPL (Complement A)
{
    regs_->a = ~regs_->a;
    // Flags: Z (preservado), N=1, H=1, C (preservado)
    regs_->set_flag_n(true);
    regs_->set_flag_h(true);
    // Z y C no se modifican
    cycles_ += 1;  // CPL consume 1 M-Cycle
    return 1;
}</code></pre>

                <h3>SCF (0x37)</h3>
                <pre><code>case 0x37:  // SCF (Set Carry Flag)
{
    // Flags: Z (preservado), N=0, H=0, C=1
    regs_->set_flag_n(false);
    regs_->set_flag_h(false);
    regs_->set_flag_c(true);
    // Z no se modifica
    cycles_ += 1;  // SCF consume 1 M-Cycle
    return 1;
}</code></pre>

                <h3>CCF (0x3F)</h3>
                <pre><code>case 0x3F:  // CCF (Complement Carry Flag)
{
    // Flags: Z (preservado), N=0, H=0, C=!C
    regs_->set_flag_n(false);
    regs_->set_flag_h(false);
    regs_->set_flag_c(!regs_->get_flag_c());
    // Z no se modifica
    cycles_ += 1;  // CCF consume 1 M-Cycle
    return 1;
}</code></pre>

                <h3>Loads 8-bit críticos</h3>
                <p>Incorporados para habilitar accesos tempranos a registros y memoria alta:</p>
                <ul>
                    <li><code>LD (BC), A</code> / <code>LD (DE), A</code> y <code>LD A, (BC)</code> / <code>LD A, (DE)</code> (2 M-Cycles).</li>
                    <li><code>LDI/LD A, (HL±)</code> (incremento/decremento automático de HL).</li>
                    <li><code>LDH (C), A</code> y <code>LDH A, (C)</code> para 0xFF00 + C (registros de E/S), 2 M-Cycles.</li>
                    <li><code>LD (nn), A</code> y <code>LD A, (nn)</code> para direcciones absolutas de 16 bits, 4 M-Cycles.</li>
                </ul>

                <h3>Decisiones de Diseño</h3>
                <ul>
                    <li><strong>Implementación de DAA:</strong> La lógica de DAA es compleja y depende del flag N (si fue suma o resta) y de los flags H y C. Se implementó siguiendo exactamente la especificación de Pan Docs para garantizar compatibilidad con juegos que usan BCD.</li>
                    <li><strong>Preservación de flags:</strong> CPL, SCF y CCF preservan el flag Z, lo cual es crítico para mantener el estado correcto de las comparaciones anteriores.</li>
                    <li><strong>Organización del código:</strong> Las instrucciones se insertaron en los lugares apropiados del switch según sus opcodes para mantener la coherencia y facilitar el mantenimiento.</li>
                    <li><strong>Timing preciso:</strong> Todas las instrucciones consumen 1 M-Cycle (4 cycles) según Pan Docs.</li>
                    <li><strong>HALT bug:</strong> Si IME=0 y existe una interrupción pendiente (IE &amp; IF != 0), HALT no detiene la CPU (se comporta como NOP) para evitar loops con IME desactivado.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Agregadas 15 instrucciones al método <code>step()</code> y fix de HALT bug:
                        <ul>
                            <li>Misceláneas: DAA (0x27), CPL (0x2F), SCF (0x37), CCF (0x3F).</li>
                            <li>Interrupciones: RETI (0xD9) reactiva IME al salir de la rutina.</li>
                            <li>Loads básicos: LD (BC), A / LD (DE), A / LD A, (BC) / LD A, (DE).</li>
                            <li>Loads con auto-incremento/decremento: LDI/LD A, (HL±).</li>
                            <li>High memory I/O: LDH (C), A y LDH A, (C).</li>
                            <li>Dirección absoluta: LD (nn), A y LD A, (nn).</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Validación de módulo compilado C++:</strong> Las instrucciones se implementaron directamente en C++ y requieren recompilación.
                </p>
                <p><strong>Comandos ejecutados:</strong></p>
                <pre><code>.\rebuild_cpp.ps1
python main.py roms/pkmn.gb
python main.py roms/pkmn.gb --verbose</code></pre>
                <p><strong>Resultados:</strong></p>
                <ul>
                    <li>El bucle de <code>RST 38</code> desapareció; SP estable, sin desbordes.</li>
                    <li>PC oscila en 0x614D–0x6151 con IME activo; interrupciones atendidas (RETI implementado).</li>
                    <li>Pantalla aún verde: flujo en rutina 0x613C–0x6153; falta inspeccionar HRAM/WRAM (p.ej. 0xD732) para destrabar.</li>
                </ul>
                <p><strong>Validación de módulo compilado C++:</strong> Sí (rebuild_cpp.ps1).</p>
                <p><strong>Pendiente:</strong> Tests unitarios para <code>DAA</code> y loads/LDH.</p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - DAA Instruction</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - CPL Instruction</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - SCF Instruction</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - CCF Instruction</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - BCD Arithmetic</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Bucle RST 38:</strong> Si el juego "descarrila" y salta a una zona vacía, lee <code>0xFF</code>, ejecuta <code>RST 38</code>, empuja el PC a la pila, salta a <code>0038</code>, lee <code>0xFF</code> otra vez (si <code>0038</code> no tiene código válido), vuelve a empujar... Esto causa un Stack Overflow (el SP baja hasta dar la vuelta).</li>
                        <li><strong>DAA y BCD:</strong> Pokémon usa aritmética BCD intensivamente para la salud, el dinero y los puntos. Si <code>DAA</code> no está implementada, los cálculos salen mal, el juego hace <code>JP HL</code> a una dirección equivocada, y aterriza en una zona vacía de memoria (llena de <code>0xFF</code>).</li>
                        <li><strong>Desincronización del PC:</strong> Cuando falta una instrucción, la CPU puede "descarrilarse" (desincronizarse del flujo de instrucciones correcto). Esto ocurre cuando el juego espera que una instrucción haga algo específico (como ajustar A para BCD), pero como no está implementada, actúa como NOP, causando que los cálculos posteriores salgan mal.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>HRAM/WRAM en el bucle 0x613C–0x6153:</strong> Inspeccionar bytes como 0xD732 para confirmar la condición de salida del bucle que mantiene la pantalla verde.</li>
                        <li><strong>Tests unitarios:</strong> Implementar tests para <code>DAA</code> con combinaciones de flags/valores y para loads/LDH.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        Asumimos que la falta de <code>DAA</code>, loads y RETI explicaba el bucle <code>RST 38</code>. Ahora el PC progresa pero la pantalla sigue verde; la hipótesis es un flag en HRAM/WRAM que no cumple la condición de salida. Próximo paso: leer 0xD732 y confirmar la lógica del handler de VBlank/STAT.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[x] Recompilar el módulo C++ con <code>.\rebuild_cpp.ps1</code></li>
                    <li>[x] Ejecutar el emulador con Pokémon Red y confirmar que el bucle de <code>RST 38</code> desaparece</li>
                    <li>[ ] Instrumentar/leer HRAM/WRAM (p.ej. 0xD732) en el bucle 0x614D–0x6151 para destrabar la pantalla verde</li>
                    <li>[ ] Verificar visualmente la intro (logo/Game Freak) tras la lectura del flag</li>
                    <li>[ ] Implementar tests unitarios completos para <code>DAA</code> y loads/LDH</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

