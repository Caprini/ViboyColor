<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Limpieza Post-Diagn√≥stico: Revertir el "Test del Checkerboard" - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Limpieza Post-Diagn√≥stico: Revertir el "Test del Checkerboard"</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-21
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0203
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîß DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-21__0202__test-checkerboard-validacion-pipeline-renderizado.html">Anterior (Step 0202)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El "Test del Checkerboard" del Step 0202 ha sido un √©xito rotundo. El patr√≥n de tablero de ajedrez que vimos en la pantalla es la prueba irrefutable de que nuestro pipeline de renderizado C++ ‚Üí Cython ‚Üí Python funciona perfectamente. El diagn√≥stico es ahora definitivo: el problema de la pantalla en blanco se debe a que la VRAM est√° vac√≠a, no a un fallo en el renderizado.
                </p>
                <p>
                    Ahora que hemos validado la tuber√≠a de datos, debemos restaurar la l√≥gica de renderizado normal de la PPU para poder investigar por qu√© la VRAM permanece vac√≠a. Este paso consiste en revertir los cambios temporales del "Test del Checkerboard" y volver a la implementaci√≥n que lee desde la VRAM.
                </p>
                <p>
                    El resultado esperado es que la pantalla vuelva a ser blanca, pero esta vez con la certeza absoluta de que el problema no est√° en el renderizado, sino en que la CPU no est√° ejecutando la rutina que copia los datos del logo desde la ROM a la VRAM.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Ingenier√≠a: Limpieza Post-Diagn√≥stico</h2>
                <p>
                    Las herramientas de diagn√≥stico temporales son incre√≠blemente poderosas, pero es crucial eliminarlas una vez que han cumplido su prop√≥sito para restaurar el comportamiento normal del sistema. El "Test del Checkerboard" nos ha dado la respuesta que necesit√°bamos: la tuber√≠a de datos funciona. Ahora necesitamos que la PPU vuelva a intentar leer de la VRAM para poder investigar por qu√© esa VRAM est√° vac√≠a.
                </p>
                <p>
                    <strong>El Tablero de Ajedrez: Nuestro Hito M√°s Importante</strong>
                </p>
                <p>
                    El patr√≥n de tablero de ajedrez que vimos en la pantalla es, en cierto sentido, m√°s hermoso incluso que el logo de Nintendo. No es el resultado de la emulaci√≥n de un juego; es la <strong>prueba irrefutable de que nuestra arquitectura funciona</strong>. Cada cuadrado oscuro y claro que vimos es la confirmaci√≥n de que:
                </p>
                <ul>
                    <li>El framebuffer C++ se est√° escribiendo correctamente.</li>
                    <li>El puntero se est√° pasando correctamente a trav√©s de Cython.</li>
                    <li>El <code>memoryview</code> de Python est√° leyendo los datos correctamente.</li>
                    <li>Pygame est√° renderizando los p√≠xeles en la pantalla.</li>
                </ul>
                <p>
                    <strong>El Diagn√≥stico Definitivo:</strong>
                </p>
                <p>
                    Con el "Test del Checkerboard", hemos aislado el problema con precisi√≥n quir√∫rgica. El diagn√≥stico es definitivo:
                </p>
                <ul>
                    <li><strong>La pantalla en blanco que ve√≠amos se debe a que la VRAM est√° vac√≠a</strong>, no a un problema de renderizado.</li>
                    <li>El verdadero culpable es que la CPU, por alguna raz√≥n, no est√° ejecutando la rutina de c√≥digo que copia los datos del logo de Nintendo desde la ROM a la VRAM.</li>
                    <li>La CPU est√° atrapada en un bucle l√≥gico <em>antes</em> de llegar a ese punto, o la rutina de copia nunca se ejecuta.</li>
                </ul>
                <p>
                    <strong>¬øPor qu√© carga de arriba hacia abajo?</strong> Porque nuestro <code>render_scanline()</code> se llama para cada l√≠nea (<code>LY</code> de 0 a 143), dibujando el tablero progresivamente.
                </p>
                <p>
                    <strong>¬øPor qu√© desaparece y vuelve a cargar?</strong> Porque nuestra limpieza de framebuffer sincronizada con <code>LY=0</code> (Step 0200) est√° funcionando a la perfecci√≥n. Cada vez que <code>LY</code> se resetea a 0 para empezar un nuevo fotograma, el framebuffer se limpia a blanco, y el tablero de ajedrez empieza a dibujarse de nuevo desde la l√≠nea 0.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    La implementaci√≥n consiste en restaurar la l√≥gica de renderizado normal de la PPU, eliminando el c√≥digo del "Test del Checkerboard" y volviendo a la implementaci√≥n que lee desde la VRAM.
                </p>
                
                <h3>Modificaci√≥n en PPU::render_scanline()</h3>
                <p>
                    En <code>src/core/cpp/PPU.cpp</code>, restauramos la l√≥gica de renderizado de fondo original:
                </p>
                <ul>
                    <li>Eliminamos el c√≥digo del "Test del Checkerboard" que generaba el patr√≥n de tablero de ajedrez.</li>
                    <li>Restauramos la l√≥gica que lee los registros LCDC, SCY, SCX.</li>
                    <li>Restauramos el c√°lculo de direcciones de tilemap y tile data.</li>
                    <li>Restauramos la lectura de IDs de tile desde el tilemap.</li>
                    <li>Restauramos la decodificaci√≥n de datos de tile desde la VRAM.</li>
                    <li>Restauramos la escritura del √≠ndice de color en el framebuffer.</li>
                </ul>
                <p>
                    El c√≥digo restaurado es similar al que ten√≠amos antes del Step 0202, pero ahora con la certeza de que la tuber√≠a de datos funciona correctamente.
                </p>

                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code>: Restaurada la l√≥gica de renderizado normal en <code>render_scanline()</code>.</li>
                </ul>

                <h3>Decisiones de dise√±o</h3>
                <p>
                    La decisi√≥n de restaurar la l√≥gica normal es obvia: el test de diagn√≥stico ha cumplido su prop√≥sito. Ahora necesitamos que la PPU vuelva a intentar leer de la VRAM para poder investigar por qu√© esa VRAM est√° vac√≠a. El siguiente paso de diagn√≥stico ser√° instrumentar la MMU para monitorear las escrituras en VRAM y entender por qu√© la CPU no est√° copiando los datos del logo.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Restaurada la l√≥gica de renderizado normal en <code>render_scanline()</code></li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    La verificaci√≥n consiste en confirmar que volvemos al estado anterior: una pantalla en blanco, pero esta vez con la certeza de que el problema no est√° en el renderizado.
                </p>
                <ol>
                    <li><strong>Recompilaci√≥n del m√≥dulo C++:</strong>
                        <pre><code>.\rebuild_cpp.ps1</code></pre>
                    </li>
                    <li><strong>Ejecuci√≥n del emulador:</strong>
                        <pre><code>python main.py roms/tetris.gb</code></pre>
                    </li>
                    <li><strong>Resultado Esperado:</strong> La pantalla debe volver a ser <strong>blanca</strong>. Esto confirmar√° que la PPU est√° intentando leer de una VRAM que, como ahora sabemos, est√° vac√≠a.</li>
                </ol>
                <p>
                    <strong>Validaci√≥n Nativa:</strong> Validaci√≥n de m√≥dulo compilado C++.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">LCD Timing, Background Rendering</a></li>
                    <li>Implementaci√≥n basada en conocimiento general de arquitectura LR35902 y pr√°cticas de ingenier√≠a de software (limpieza post-diagn√≥stico).</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Pipeline de Renderizado:</strong> El pipeline C++ ‚Üí Cython ‚Üí Python funciona perfectamente. El "Test del Checkerboard" lo ha confirmado de forma inequ√≠voca.</li>
                        <li><strong>Diagn√≥stico Definitivo:</strong> El problema de la pantalla en blanco se debe a que la VRAM est√° vac√≠a, no a un fallo en el renderizado.</li>
                        <li><strong>Limpieza Post-Diagn√≥stico:</strong> Es crucial eliminar las herramientas de diagn√≥stico temporales una vez que han cumplido su prop√≥sito para restaurar el comportamiento normal del sistema.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Por qu√© la VRAM est√° vac√≠a:</strong> Necesitamos instrumentar la MMU para monitorear las escrituras en VRAM y entender por qu√© la CPU no est√° copiando los datos del logo desde la ROM.</li>
                        <li><strong>Rutina de copia del logo:</strong> Necesitamos verificar si la CPU est√° ejecutando la rutina que copia los datos del logo, o si est√° atrapada en un bucle antes de llegar a ese punto.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        Suponemos que la CPU no est√° ejecutando la rutina de copia del logo, o que esa rutina nunca se ejecuta. El siguiente paso de diagn√≥stico ser√° instrumentar la MMU para monitorear las escrituras en VRAM y confirmar esta hip√≥tesis.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Instrumentar la MMU para monitorear las escrituras en VRAM</li>
                    <li>[ ] Verificar si la CPU est√° ejecutando la rutina de copia del logo</li>
                    <li>[ ] Entender por qu√© la VRAM permanece vac√≠a</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

