<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Final: Reactivaci√≥n de la Traza de CPU para Cazar el Bucle L√≥gico - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug Final: Reactivaci√≥n de la Traza de CPU para Cazar el Bucle L√≥gico</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0195
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîç DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0194__sensor-vram-monitoreo-escrituras-tiempo-real.html">Anterior (0194)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El "Sensor de VRAM" del Step 0194 ha confirmado con certeza que la CPU <strong>nunca intenta escribir en la VRAM</strong>. A pesar de que el emulador corri√≥ durante varios segundos y cientos de fotogramas, el mensaje <code>[VRAM WRITE DETECTED!]</code> <strong>nunca apareci√≥</strong>.
                </p>
                <p>
                    Dado que todos los <code>deadlocks</code> de hardware han sido resueltos (<code>LY</code> cicla correctamente), la √∫nica explicaci√≥n posible es que la CPU est√° atrapada en un <strong>bucle l√≥gico infinito</strong> en el propio c√≥digo de la ROM, antes de llegar a la rutina que copia los gr√°ficos a la VRAM.
                </p>
                <p>
                    Este Step reactiva el sistema de trazado de la CPU en C++ para capturar la secuencia de instrucciones que componen el bucle infinito, identificar el patr√≥n y deducir la condici√≥n de salida que no se est√° cumpliendo.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Ingenier√≠a: Aislamiento del Bucle de Software</h2>
                <p>
                    Hemos pasado de depurar nuestro emulador a depurar la propia ROM que se ejecuta en √©l. Necesitamos ver el c√≥digo ensamblador que est√° corriendo para entender su l√≥gica. Una traza de las √∫ltimas instrucciones ejecutadas nos mostrar√° un patr√≥n repetitivo de direcciones de <code>PC</code>.
                </p>
                <p>
                    Al analizar los <code>opcodes</code> en esas direcciones, podremos deducir qu√© est√° comprobando el juego. ¬øEst√° esperando un valor espec√≠fico en un registro de I/O que no hemos inicializado correctamente? ¬øEst√° comprobando un flag que nuestra ALU calcula de forma sutilmente incorrecta en un caso l√≠mite? La traza nos lo dir√°.
                </p>
                <p>
                    <strong>Principio del Trazado Disparado:</strong> En lugar de trazar desde el inicio (lo cual generar√≠a demasiado ruido), activamos el trazado cuando el <code>PC</code> alcanza <code>0x0100</code> (inicio del c√≥digo del cartucho). Esto nos da una ventana clara de la ejecuci√≥n del c√≥digo del juego, sin el ruido del c√≥digo de inicializaci√≥n de la BIOS.
                </p>
                <p>
                    <strong>L√≠mite de Instrucciones:</strong> Configuramos el trazado para capturar las primeras 200 instrucciones despu√©s de la activaci√≥n. Esto es suficiente para ver un patr√≥n de bucle claro. Si el bucle es m√°s largo, podemos aumentar el l√≠mite, pero 200 suele ser suficiente para identificar el patr√≥n.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Hemos reintroducido la l√≥gica de trazado que usamos en los Steps 0169-0170, pero esta vez configurada para activarse al inicio del c√≥digo del cartucho y darnos una ventana clara de la ejecuci√≥n.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code>: A√±adido include <code>&lt;cstdio&gt;</code> y sistema de trazado en el m√©todo <code>step()</code></li>
                </ul>

                <h3>C√≥digo del Trazado</h3>
                <p>
                    El trazado utiliza variables est√°ticas para mantener el estado entre llamadas:
                </p>
                <pre><code>// --- Variables para el Trazado de CPU (Step 0195) ---
static bool debug_trace_activated = false;
static int debug_instruction_counter = 0;
// Un l√≠mite de 200 es suficiente para ver un patr√≥n de bucle.
static const int DEBUG_INSTRUCTION_LIMIT = 200;

// En el constructor de la CPU, resetea el estado del trazado
CPU::CPU(MMU* mmu, CoreRegisters* registers) : /*...*/ {
    debug_trace_activated = false;
    debug_instruction_counter = 0;
}

// En el m√©todo step(), antes de fetch_byte():
uint16_t current_pc = regs_->pc;

// --- L√≥gica del Trazado (Step 0195) ---
// Empezamos a trazar desde el principio para cazar el bucle.
if (!debug_trace_activated && current_pc >= 0x0100) {
    debug_trace_activated = true;
    printf("--- [CPU TRACE ACTIVATED at PC: 0x%04X] ---\n", current_pc);
}

if (debug_trace_activated && debug_instruction_counter < DEBUG_INSTRUCTION_LIMIT) {
    uint8_t opcode_for_trace = mmu_->read(current_pc);
    printf("[CPU TRACE %d] PC: 0x%04X | Opcode: 0x%02X\n", debug_instruction_counter, current_pc, opcode_for_trace);
    debug_instruction_counter++;
}
// --- Fin del Trazado ---</code></pre>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>Activaci√≥n en 0x0100:</strong> El c√≥digo del cartucho comienza en <code>0x0100</code>. Activamos el trazado aqu√≠ para evitar el ruido del c√≥digo de inicializaci√≥n de la BIOS.</li>
                    <li><strong>L√≠mite de 200 instrucciones:</strong> Es suficiente para ver un patr√≥n de bucle. Si el bucle es m√°s largo, podemos aumentar el l√≠mite f√°cilmente.</li>
                    <li><strong>Lectura del opcode antes de fetch:</strong> Leemos el opcode directamente de la memoria usando <code>mmu_-&gt;read(current_pc)</code> antes de que <code>fetch_byte()</code> lo consuma. Esto nos da el opcode exacto que se va a ejecutar.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - A√±adido include <code>&lt;cstdio&gt;</code> y sistema de trazado en el m√©todo <code>step()</code></li>
                    <li><code>docs/bitacora/entries/2025-12-20__0195__debug-final-reactivacion-traza-cpu-cazar-bucle-logico.html</code> - Nueva entrada de bit√°cora</li>
                    <li><code>docs/bitacora/index.html</code> - Actualizado con la nueva entrada</li>
                    <li><code>INFORME_FASE_2.md</code> - Actualizado con el Step 0195</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    La verificaci√≥n de este Step es principalmente de compilaci√≥n y ejecuci√≥n del emulador. El resultado esperado es que la traza de la CPU muestre un patr√≥n repetitivo de direcciones de <code>PC</code> que forman el bucle infinito.
                </p>
                
                <h3>Proceso de Verificaci√≥n</h3>
                <ol>
                    <li><strong>Recompilar el m√≥dulo C++:</strong> <code>.\rebuild_cpp.ps1</code>
                        <ul>
                            <li>Resultado: ‚úÖ Compilaci√≥n exitosa (con warnings menores esperados)</li>
                        </ul>
                    </li>
                    <li><strong>Ejecutar el emulador:</strong> <code>python main.py roms/tetris.gb</code>
                        <ul>
                            <li>El emulador debe ejecutarse normalmente. El usuario debe presionar una tecla para pasar el bucle del Joypad.</li>
                        </ul>
                    </li>
                    <li><strong>Observar la consola:</strong> La traza buscar√° el mensaje <code>[CPU TRACE ACTIVATED at PC: 0xXXXX]</code> seguido de las primeras 200 instrucciones ejecutadas.</li>
                </ol>

                <h3>Validaci√≥n de m√≥dulo compilado C++</h3>
                <p>
                    El emulador utiliza el m√≥dulo C++ compilado (<code>viboy_core</code>), que contiene el sistema de trazado implementado en <code>CPU::step()</code>. Cada instrucci√≥n ejecutada pasar√° a trav√©s de este m√©todo y ser√° trazada si corresponde.
                </p>

                <h3>Resultado Esperado</h3>
                <p>
                    La traza de la CPU nos mostrar√° el bucle. Por ejemplo, podr√≠amos ver algo como:
                </p>
                <pre><code>[CPU TRACE 195] PC: 0x00A5 | Opcode: 0xE0
[CPU TRACE 196] PC: 0x00A7 | Opcode: 0xE6
[CPU TRACE 197] PC: 0x00A8 | Opcode: 0x20
[CPU TRACE 198] PC: 0x00A5 | Opcode: 0xE0
[CPU TRACE 199] PC: 0x00A7 | Opcode: 0xE6</code></pre>
                <p>
                    Este patr√≥n nos dir√° que las instrucciones en <code>0x00A5</code>, <code>0x00A7</code> y <code>0x00A8</code> forman el bucle. Al mirar qu√© hacen esos opcodes (por ejemplo, <code>LDH</code>, <code>AND</code>, <code>JR NZ</code>), podremos deducir la condici√≥n exacta que est√° fallando y aplicar la correcci√≥n final.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set</a></li>
                    <li>Implementaci√≥n basada en conocimiento general de arquitectura LR35902 y t√©cnicas de depuraci√≥n de emuladores.</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Trazado de CPU:</strong> El trazado de instrucciones es una herramienta fundamental para depurar emuladores. Nos permite ver exactamente qu√© instrucciones est√° ejecutando la CPU y en qu√© orden.</li>
                        <li><strong>Patrones de Bucle:</strong> Los bucles infinitos en c√≥digo de bajo nivel se manifiestan como patrones repetitivos de direcciones de <code>PC</code>. Identificar estos patrones es el primer paso para entender qu√© condici√≥n est√° fallando.</li>
                        <li><strong>Aislamiento del Problema:</strong> Hemos eliminado todas las causas de hardware (deadlocks, sincronizaci√≥n, etc.). El problema restante es un bucle de software puro, que requiere an√°lisis del c√≥digo ensamblador.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Patr√≥n del Bucle:</strong> Necesitamos ejecutar el emulador y analizar la traza para identificar el patr√≥n exacto del bucle.</li>
                        <li><strong>Condici√≥n de Salida:</strong> Una vez identificado el bucle, necesitamos deducir qu√© condici√≥n est√° esperando el juego y por qu√© no se est√° cumpliendo.</li>
                        <li><strong>Correcci√≥n Final:</strong> Una vez identificada la condici√≥n, necesitaremos aplicar la correcci√≥n correspondiente (inicializaci√≥n de registro, correcci√≥n de flag, etc.).</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis Principal:</strong> El juego est√° esperando un valor espec√≠fico en un registro de I/O que no hemos inicializado correctamente, o est√° comprobando un flag que nuestra ALU calcula de forma sutilmente incorrecta en un caso l√≠mite.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> El bucle es lo suficientemente corto (menos de 200 instrucciones) para que podamos capturarlo completamente con nuestro l√≠mite actual. Si el bucle es m√°s largo, podemos aumentar el l√≠mite f√°cilmente.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y analizar la traza de la CPU</li>
                    <li>[ ] Identificar el patr√≥n repetitivo de direcciones de <code>PC</code> que forman el bucle</li>
                    <li>[ ] Analizar los opcodes en esas direcciones para deducir qu√© condici√≥n est√° esperando el juego</li>
                    <li>[ ] Aplicar la correcci√≥n correspondiente (inicializaci√≥n de registro, correcci√≥n de flag, etc.)</li>
                    <li>[ ] Verificar que el juego sale del bucle y comienza a escribir en la VRAM</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

