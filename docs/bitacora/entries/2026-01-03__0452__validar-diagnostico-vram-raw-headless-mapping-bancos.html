<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validar Diagnóstico VRAM RAW + Headless + Mapping Bancos - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Validar Diagnóstico VRAM RAW + Headless + Mapping Bancos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-03
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0452
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-02__0451__ejecutar-clasificacion-mbc-headless-raw-evidencia.html">Anterior</a></li>
                    <li><a href="2026-01-03__0453__ejecutar-herramientas-trust-probe-rerun-documentar-evidencia.html">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Validación del diagnóstico de VRAM RAW, headless trust test y herramientas de prueba de mapping MBC.
                    Se confirmó que VRAM está almacenada en bancos separados (<code>vram_bank0_</code>, <code>vram_bank1_</code>) en MMU,
                    se corrigió <code>read_raw()</code> para leer correctamente de los bancos VRAM, se creó test de validación write→read_raw,
                    se creó herramienta de headless trust test y se creó herramienta de MBC bank probe para validar mapping determinista.
                    <strong>Hallazgo clave:</strong> VRAM storage confirmado en MMU (no en PPU), <code>read_raw()</code> funciona correctamente,
                    y las herramientas de diagnóstico están listas para validar mapping MBC y confiabilidad de headless.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En Game Boy Color (CGB), la <strong>VRAM (Video RAM)</strong> está dividida en dos bancos de 8KB cada uno (total 16KB):
                </p>
                <ul>
                    <li><strong>VRAM Bank 0 (0x8000-0x9FFF):</strong> Tile Data y Tile Map base</li>
                    <li><strong>VRAM Bank 1 (0x8000-0x9FFF):</strong> Tile Data alternativo y atributos de Tile Map (CGB)</li>
                </ul>
                <p>
                    El registro <strong>VBK (0xFF4F)</strong> bit 0 selecciona qué banco ve la CPU. El PPU puede acceder a ambos bancos simultáneamente
                    durante el renderizado. En modo DMG (Game Boy clásico), solo se usa Bank 0.
                </p>
                <p>
                    <strong>Diagnóstico RAW:</strong> Para diagnóstico confiable, necesitamos leer VRAM directamente sin restricciones de modo PPU.
                    <code>read_raw()</code> debe leer de los bancos VRAM correctos (<code>vram_bank0_</code>, <code>vram_bank1_</code>) cuando la dirección
                    está en el rango 0x8000-0x9FFF, no de <code>memory_[]</code> que no contiene el contenido de VRAM.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - "CGB Registers", "VRAM Banks", "FF4F - VBK - VRAM Bank"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementaron tres fases del plan:
                </p>
                
                <h3>Fase A: Verificar Dónde Está VRAM Realmente</h3>
                <p>
                    Se localizó el storage de VRAM usando <code>grep</code> sobre el código C++:
                </p>
                <ul>
                    <li><strong>Hallazgo:</strong> VRAM está en <code>MMU</code> como <code>vram_bank0_</code> y <code>vram_bank1_</code> (vectores de 0x2000 bytes cada uno)</li>
                    <li><strong>NO está en PPU:</strong> PPU no tiene arrays propios de VRAM, solo lee desde MMU usando <code>read_vram_bank()</code></li>
                    <li><strong>Problema identificado:</strong> <code>read_raw()</code> leía de <code>memory_[]</code> que no contiene VRAM</li>
                </ul>

                <h3>Fase B: Corregir read_raw() para Leer de Bancos VRAM</h3>
                <p>
                    Se modificó <code>MMU::read_raw()</code> en <code>src/core/cpp/MMU.cpp</code> para leer de los bancos VRAM cuando la dirección
                    está en el rango 0x8000-0x9FFF:
                </p>
                <pre><code>uint8_t MMU::read_raw(uint16_t addr) const {
    // Step 0452: VRAM está en bancos separados (vram_bank0_, vram_bank1_)
    // Para diagnóstico confiable, read_raw() debe leer de los bancos VRAM
    if (addr >= 0x8000 && addr <= 0x9FFF) {
        uint16_t offset = addr - 0x8000;
        if (vram_bank_ == 0 && offset < vram_bank0_.size()) {
            return vram_bank0_[offset];
        } else if (vram_bank_ == 1 && offset < vram_bank1_.size()) {
            return vram_bank1_[offset];
        }
        return 0xFF;
    }
    
    if (addr >= MEMORY_SIZE) {
        return 0xFF;
    }
    return memory_[addr];
}</code></pre>

                <h3>Fase C: Crear Test de Validación write→read_raw</h3>
                <p>
                    Se creó <code>tests/test_vram_raw_write_read_0452.py</code> con tres tests:
                </p>
                <ul>
                    <li><strong>test_vram_write_read_raw_mmu:</strong> Valida que escribir a VRAM y leer con <code>read_raw()</code> funciona</li>
                    <li><strong>test_vram_write_read_raw_range:</strong> Valida que <code>dump_raw_range()</code> funciona correctamente</li>
                    <li><strong>test_vram_nonzero_sampling:</strong> Valida que podemos detectar bytes non-zero en VRAM usando <code>read_raw()</code></li>
                </ul>
                <p>
                    <strong>Resultado:</strong> Todos los tests pasan correctamente ✅
                </p>

                <h3>Fase D: Crear Herramientas de Diagnóstico</h3>
                <p>
                    Se crearon dos herramientas:
                </p>
                <ul>
                    <li><strong>tools/test_headless_trust_0452.py:</strong> Headless trust test que valida que headless reporta correctamente con ROM clean-room</li>
                    <li><strong>tools/mbc_bank_probe_0452.py:</strong> MBC bank probe que prueba mapping MBC determinista comparando bytes leídos con ROM real</li>
                </ul>

                <h3>Corrección de dump_raw_range() en Cython</h3>
                <p>
                    Se corrigió <code>dump_raw_range()</code> en <code>src/core/cython/mmu.pyx</code> para manejar correctamente la conversión de bytes:
                </p>
                <pre><code>def dump_raw_range(self, uint16_t start, uint16_t length):
    # ... código de asignación de buffer ...
    try:
        self._mmu.dump_raw_range(start, length, buffer)
        # Convert to Python bytes by creating a list and converting to bytes
        result_list = []
        for i in range(length):
            result_list.append(buffer[i])
        return bytes(result_list)
    finally:
        free(buffer)</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Modificado <code>read_raw()</code> para leer de bancos VRAM</li>
                    <li><code>src/core/cython/mmu.pyx</code> - Corregido <code>dump_raw_range()</code> para conversión de bytes</li>
                    <li><code>tests/test_vram_raw_write_read_0452.py</code> - Creado test de validación write→read_raw</li>
                    <li><code>tools/test_headless_trust_0452.py</code> - Creado headless trust test</li>
                    <li><code>tools/mbc_bank_probe_0452.py</code> - Creado MBC bank probe</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Tests unitarios:</strong>
                </p>
                <pre><code>$ python3 -m pytest tests/test_vram_raw_write_read_0452.py -v

tests/test_vram_raw_write_read_0452.py::test_vram_write_read_raw_mmu PASSED
tests/test_vram_raw_write_read_0452.py::test_vram_write_read_raw_range PASSED
tests/test_vram_raw_write_read_0452.py::test_vram_nonzero_sampling PASSED

✅ 3 passed in 0.30s</code></pre>
                <p>
                    <strong>Validación de módulo compilado C++:</strong> Todos los tests pasan, confirmando que <code>read_raw()</code>
                    lee correctamente de los bancos VRAM y que <code>dump_raw_range()</code> funciona correctamente.
                </p>
                <p>
                    <strong>Código del Test:</strong>
                </p>
                <pre><code>def test_vram_write_read_raw_mmu():
    """Valida que escribir a VRAM y leer con read_raw funciona."""
    mmu = PyMMU()
    ppu = PyPPU(mmu)
    mmu.set_ppu(ppu)
    
    # Escribir patrón no-cero en 0x8000-0x8010
    pattern = [0xAA, 0xBB, 0xCC, 0xDD]
    for i, byte_val in enumerate(pattern):
        mmu.write(0x8000 + i, byte_val)
    
    # Leer con read_raw (VRAM está en MMU)
    for i, expected in enumerate(pattern):
        actual = mmu.read_raw(0x8000 + i)
        assert actual == expected, (
            f"VRAM write→read_raw falló en 0x{0x8000+i:04X}: "
            f"esperado 0x{expected:02X}, obtenido 0x{actual:02X}"
        )
    
    print("✅ MMU.write→read_raw funciona correctamente")</code></pre>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">"CGB Registers", "VRAM Banks", "FF4F - VBK - VRAM Bank"</a></li>
                    <li>Implementación basada en análisis del código C++ existente (MMU.cpp, PPU.hpp)</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>VRAM Storage:</strong> VRAM está en MMU como bancos separados (<code>vram_bank0_</code>, <code>vram_bank1_</code>), no en <code>memory_[]</code> ni en PPU. Esto es crítico para diagnóstico confiable.</li>
                        <li><strong>read_raw() vs read():</strong> <code>read_raw()</code> debe leer directamente de los bancos VRAM cuando la dirección está en 0x8000-0x9FFF, no de <code>memory_[]</code>. <code>read()</code> hace mapping dinámico de ROM pero no es útil para diagnóstico RAW de VRAM.</li>
                        <li><strong>Diagnóstico Confiable:</strong> Para validar que VRAM tiene datos, necesitamos <code>read_raw()</code> que lea directamente de los bancos VRAM sin restricciones de modo PPU.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Headless Trust Test:</strong> Validar que headless reporta correctamente con ROM clean-room (ejecutado en Step 0453)</li>
                        <li><strong>MBC Bank Probe:</strong> Validar que el mapping MBC funciona correctamente comparando bytes leídos con ROM real (ejecutado en Step 0453)</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        Se asume que los bancos VRAM (<code>vram_bank0_</code>, <code>vram_bank1_</code>) son la fuente de verdad para VRAM.
                        Esto se confirmó mediante análisis del código C++ y tests de validación write→read_raw.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[x] Validar VRAM storage (MMU vs PPU)</li>
                    <li>[x] Corregir read_raw() para leer de bancos VRAM</li>
                    <li>[x] Crear test write→read_raw</li>
                    <li>[x] Crear headless trust test</li>
                    <li>[x] Crear MBC bank probe</li>
                    <li>[ ] Ejecutar headless trust test y MBC bank probe (Step 0453)</li>
                    <li>[ ] Analizar resultados y decidir causa raíz (mapping vs CPU/IRQ vs PPU/paletas)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

