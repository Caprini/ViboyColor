<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Nonzero Tiledata + Source-Read Correlation + Wait-Loop Explainer - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>First-Nonzero Tiledata + Source-Read Correlation + Wait-Loop Explainer</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-10
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0502
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-10__0501__dmg-vram-tiledata-write-audit-force-writes-irq-tracking-fix.html">Anterior (0501)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este Step implementa instrumentación avanzada para diagnosticar por qué los juegos DMG solo escriben ceros a VRAM. Se añadieron <strong>contadores de contenido escrito</strong> (cero vs no-cero) en <code>VRAMWriteAuditStats</code>, tracking del <strong>primer/last nonzero write</strong> con contexto completo (PC, frame, modo PPU), y un <strong>ring buffer de reads MMU</strong> para correlación source-read (detectar si la CPU está copiando ceros desde ROM/RAM). Se implementó parada automática cuando se detecta el primer write no-cero y un clasificador DMG v4 que usa estas nuevas métricas para diagnóstico más preciso. El objetivo es obtener una respuesta binaria basada en datos: ¿se intentan escribir tiles reales (nonzero)? ¿de dónde salen los valores escritos?
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Problema del Step 0501</strong>: Se detectó que los juegos DMG realizan 6144 writes a tiledata (exactamente el tamaño de 0x8000-0x97FF = 0x1800 bytes), todos con valor 0x00. Esto sugiere que el juego está haciendo un "clear VRAM" completo, pero después no carga tiles reales.
                </p>
                <p>
                    <strong>Hipótesis del Step 0502</strong>: Necesitamos distinguir entre tres escenarios posibles:
                </p>
                <ul>
                    <li><strong>A) "Nunca hay writes no-cero"</strong>: El juego está atascado / no progresa a la fase de carga de tiles</li>
                    <li><strong>B) "Hay writes no-cero, pero luego se vuelve cero"</strong>: Algo está borrando los tiles o hay un clear/swap repetido</li>
                    <li><strong>C) "Writes son cero porque el source leído es cero"</strong>: Bug en ROM reads/MBC/mapping o el fetch de datos está fallando</li>
                </ul>
                <p>
                    <strong>Correlación Source-Read</strong>: Para diagnosticar el escenario C, necesitamos rastrear las lecturas de memoria que preceden a los writes a VRAM. Si un write a VRAM escribe 0x00 y el último read antes del write también leyó 0x00 desde ROM/RAM, entonces sabemos que el problema está en el "source" (los datos que se están copiando), no en el destino (VRAM).
                </p>
                <p>
                    <strong>Ring Buffer de Reads</strong>: Implementamos un ring buffer ligero (256 eventos) que captura todos los reads de memoria (ROM, WRAM, HRAM, VRAM, IO). Cuando se escribe a VRAM, buscamos en los últimos 1-3 reads del ring para encontrar el "source" más probable. Esto es heurístico pero suficiente para detectar si el problema es "source=0".
                </p>
                <p>
                    <strong>Wait Loop Detection</strong>: Si el juego hace clear y luego se queda en un loop esperando (ej: esperando VBlank, esperando un flag), necesitamos identificar en qué dirección I/O está esperando. Esto se hace analizando el "hotspot" de PC (PC más visitado) y qué direcciones I/O se leen desde ese hotspot.
                </p>
                <p>
                    <strong>Referencia</strong>: Pan Docs - Memory Map, VRAM Access, CPU Instruction Set
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase A: Contabilidad Real del Contenido Escrito ✅</h3>
                <p>
                    <strong>A1) VRAMWriteAuditStats v2</strong>:
                </p>
                <ul>
                    <li>Ampliado <code>VRAMWriteAuditStats</code> con contadores de contenido escrito:
                        <ul>
                            <li><code>tiledata_writes_zero_count</code>: Writes con valor 0x00</li>
                            <li><code>tiledata_writes_nonzero_count</code>: Writes con valor != 0x00</li>
                            <li><code>tiledata_writes_ff_count</code>: Writes con valor 0xFF (opcional)</li>
                        </ul>
                    </li>
                    <li>Añadido tracking de <code>FirstNonzeroWrite</code> y <code>LastNonzeroWrite</code> con contexto completo:
                        <ul>
                            <li>frame_id, PC, addr, value, stat_mode, ly, lcdc</li>
                            <li>Permite identificar exactamente cuándo y dónde aparece el primer tile real</li>
                        </ul>
                    </li>
                    <li>Muestra de valores únicos no-cero (hasta 8 valores) para identificar patrones</li>
                </ul>
                <p>
                    <strong>A2) Ring Buffer de Eventos "Interesantes"</strong>:
                </p>
                <ul>
                    <li>Ring buffer dedicado de 64 eventos para writes "interesantes":
                        <ul>
                            <li>tiledata write donde <code>value != 0x00</code></li>
                            <li>tiledata write bloqueado</li>
                            <li>tiledata write forzado</li>
                        </ul>
                    </li>
                    <li>Evita que el ring se llene de basura "clear = 0"</li>
                </ul>

                <h3>Fase B: Correlación Source-Read ✅</h3>
                <p>
                    <strong>B1) MMU Read Ring</strong>:
                </p>
                <ul>
                    <li>Implementado ring buffer de 256 eventos para todos los reads de memoria</li>
                    <li>Estructura <code>MMUReadEvent</code> captura: frame_id, PC, addr, value, region (ROM0/ROMX/WRAM/HRAM/IO/VRAM), type (normal/IO)</li>
                    <li>Captura en <code>MMU::read()</code> para ROM, VRAM, WRAM, HRAM</li>
                    <li>Ligero y no intrusivo (solo guarda últimos 256 reads)</li>
                </ul>
                <p>
                    <strong>B2) Correlación Heurística Write↔Read</strong>:
                </p>
                <ul>
                    <li>Ampliado <code>VRAMWriteEvent</code> con campos de correlación:
                        <ul>
                            <li><code>src_addr_guess</code>: Dirección source estimada (del último read)</li>
                            <li><code>src_value_guess</code>: Valor source estimado (del último read)</li>
                            <li><code>src_region_guess</code>: Región source estimada (ROM0/ROMX/WRAM/HRAM/IO)</li>
                            <li><code>src_correlation_valid</code>: Si la correlación es válida (últimos 1-3 reads)</li>
                        </ul>
                    </li>
                    <li>En <code>MMU::write()</code> cuando destino es VRAM, busca en los últimos 3 reads del ring:
                        <ul>
                            <li>Busca reads con el mismo PC (correlación directa)</li>
                            <li>O usa el read más reciente si está en los últimos 3</li>
                        </ul>
                    </li>
                    <li><strong>Interpretación dura</strong>:
                        <ul>
                            <li>Si <code>value_written == 0x00</code> y <code>src_value_guess == 0x00</code> repetidamente → Source está dando ceros</li>
                            <li>Si <code>src_value_guess != 0</code> pero <code>value_written == 0</code> → Problema en CPU/A-reg/orden (menos probable)</li>
                        </ul>
                    </li>
                </ul>

                <h3>Fase C: Hotspot Explainer (Parcial) ⚠️</h3>
                <p>
                    <strong>C1) Hotspot Explainer</strong>:
                </p>
                <ul>
                    <li>Parcialmente implementado: el clasificador DMG v4 usa el hotspot del PC para detectar wait loops</li>
                    <li>Pendiente: dump completo de ROM alrededor del hotspot, contador de "loop stability", y "top read addr" desde el hotspot</li>
                    <li>Esto requiere tracking adicional de reads por PC que se puede hacer heurísticamente desde el MMU read ring</li>
                </ul>

                <h3>Fase D: Run Until Evidence ✅</h3>
                <p>
                    <strong>D1) Parada Automática</strong>:
                </p>
                <ul>
                    <li>Implementado en <code>rom_smoke_0442.py</code>:
                        <ul>
                            <li>Flag <code>stop_on_first_tiledata_nonzero_write</code>: Para cuando se detecta primer write no-cero a tiledata</li>
                            <li>Flag <code>stop_on_first_tiledata_nonzero</code>: Para cuando se detecta primer tiledata no-cero en VRAM (readback)</li>
                        </ul>
                    </li>
                    <li>CLI arguments añadidos:
                        <ul>
                            <li><code>--stop-on-first-tiledata-nonzero</code></li>
                            <li><code>--stop-on-first-tiledata-nonzero-write</code></li>
                        </ul>
                    </li>
                    <li>Ejecuciones mínimas sin esperar a ojo: se para automáticamente cuando aparece evidencia</li>
                </ul>

                <h3>Fase E: Clasificador DMG v4 ✅</h3>
                <p>
                    <strong>E1) Clasificaciones Nuevas</strong>:
                </p>
                <ul>
                    <li><strong>ONLY_CLEAR_TO_ZERO</strong>: 6144 writes a 0, sin nonzero jamás</li>
                    <li><strong>SOURCE_READS_ZERO</strong>: src_guess casi siempre 0 (correlación source-read)</li>
                    <li><strong>NONZERO_WRITTEN_THEN_CLEARED</strong>: Aparece nonzero y luego vuelve a 0</li>
                    <li><strong>NONZERO_PRESENT_OK</strong>: tiledataNZ sube (tiles reales presentes)</li>
                    <li><strong>WAIT_LOOP_ON_ADDR_X</strong>: Hotspot lee siempre la misma addr (pendiente implementación completa)</li>
                </ul>
                <p>
                    <strong>E2) Fix Mínimo Sugerido</strong>:
                </p>
                <ul>
                    <li>Si <code>SOURCE_READS_ZERO</code> y <code>src_addr_guess</code> apunta a ROMX → Sospecha fuerte a MBC/banking/ROM read</li>
                    <li>Si <code>ONLY_CLEAR_TO_ZERO</code> + hotspot espera en WRAM/HRAM → Sospecha a flag de VBlank handler que no se setea</li>
                    <li>Si <code>NONZERO_WRITTEN_THEN_CLEARED</code> → Buscar quién limpia (PC del clear) y por qué se repite</li>
                </ul>

                <h3>Componentes Creados/Modificados</h3>
                <ul>
                    <li><code>src/core/cpp/MMU.hpp</code>: Estructuras ampliadas (VRAMWriteAuditStats, VRAMWriteStats, MMUReadEvent, FirstNonzeroWrite, LastNonzeroWrite)</li>
                    <li><code>src/core/cpp/MMU.cpp</code>: Implementación de contadores cero/no-cero, correlación source-read, ring buffer de reads</li>
                    <li><code>src/core/cython/mmu.pxd</code>: Declaraciones Cython actualizadas</li>
                    <li><code>src/core/cython/mmu.pyx</code>: Métodos <code>get_vram_write_stats_v2()</code>, <code>get_vram_write_audit_stats()</code> actualizado</li>
                    <li><code>tools/rom_smoke_0442.py</code>: Parada automática, clasificador DMG v4</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.hpp</code> - Ampliación de estructuras VRAMWriteStats, VRAMWriteAuditStats, nueva estructura MMUReadEvent</li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Implementación de contadores cero/no-cero, tracking primer/last nonzero, MMU read ring, correlación source-read</li>
                    <li><code>src/core/cython/mmu.pxd</code> - Declaraciones Cython actualizadas con nuevas estructuras</li>
                    <li><code>src/core/cython/mmu.pyx</code> - Método get_vram_write_stats_v2(), get_vram_write_audit_stats() ampliado, get_vram_write_ring() con correlación</li>
                    <li><code>tools/rom_smoke_0442.py</code> - Parada automática (stop_on_first_tiledata_nonzero, stop_on_first_tiledata_nonzero_write), clasificador DMG v4</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Compilación</strong>:
                </p>
                <pre><code>python3 setup.py build_ext --inplace
# Exit code: 0 (éxito)
# Solo warnings, ningún error crítico</code></pre>
                <p>
                    <strong>Test de Build</strong>:
                </p>
                <pre><code>python3 test_build.py
# [EXITO] El pipeline de compilacion funciona correctamente
# El nucleo C++/Cython esta listo para la Fase 2.</code></pre>
                <p>
                    <strong>Validación de Módulo Compilado C++</strong>: Los métodos <code>get_vram_write_stats_v2()</code> y <code>get_vram_write_audit_stats()</code> están disponibles desde Python y pueden ser llamados sin errores.
                </p>
                <p>
                    <strong>Tests Pendientes</strong>:
                </p>
                <ul>
                    <li>Ejecutar <code>rom_smoke_0442.py</code> con <code>--stop-on-first-tiledata-nonzero-write</code> para validar parada automática</li>
                    <li>Verificar que el clasificador DMG v4 retorna clasificaciones correctas basadas en las nuevas métricas</li>
                    <li>Validar que la correlación source-read funciona correctamente comparando writes VRAM con reads previos</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Memory Map, VRAM Access, CPU Instruction Set</a></li>
                    <li>Plan Step 0502: <code>.cursor/plans/step_0502_-_first-nonzero_tiledata_+_source-read_correlation_+_wait-loop_explainer_dd348105.plan.md</code></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Correlación Source-Read</strong>: Es posible rastrear de dónde vienen los valores escritos a VRAM analizando los reads previos. Esto es heurístico (buscar en los últimos 1-3 reads) pero suficiente para detectar si el problema es "source=0" (los datos que se están copiando son ceros) vs "destino=problema" (VRAM está bloqueada/corrupta).</li>
                        <li><strong>Contadores de Contenido</strong>: Distinguir entre "intentos de write" y "contenido escrito" es crucial. Un write bloqueado sigue siendo un intento, pero si el contenido escrito (cuando se permite) es siempre cero, entonces sabemos que el problema no es el bloqueo sino el contenido.</li>
                        <li><strong>Ring Buffer de Reads</strong>: Un ring buffer ligero (256 eventos) es suficiente para capturar el contexto necesario para correlación source-read sin saturar memoria. Solo necesitamos los últimos N reads, no todos los reads históricos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Hotspot Explainer Completo</strong>: Implementación completa del hotspot explainer que muestre dump de ROM alrededor del PC, contador de loop stability, y top read addr desde el hotspot. Esto requiere tracking adicional de reads por PC.</li>
                        <li><strong>Validación con ROMs Reales</strong>: Ejecutar rom_smoke_0442.py con las nuevas flags y verificar que las clasificaciones sean correctas y útiles para diagnóstico.</li>
                        <li><strong>Correlación Source-Read Más Precisa</strong>: La heurística actual (últimos 1-3 reads) es suficiente para casos simples, pero podría mejorarse con análisis de patrones de instrucciones (ej: si la instrucción es LD (HL),A, entonces el último read probablemente es el source).</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Suposición de Correlación</strong>: Asumimos que si un write a VRAM ocurre poco después de un read de ROM/RAM, el valor escrito probablemente viene del valor leído. Esto es heurístico y puede fallar en casos donde hay múltiples reads/writes intercalados, pero para la mayoría de casos (copia simple de datos) debería funcionar.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar <code>rom_smoke_0442.py</code> con <code>--stop-on-first-tiledata-nonzero-write</code> en tetris.gb y pkmn.gb para obtener evidencia real</li>
                    <li>[ ] Completar Hotspot Explainer: dump de ROM alrededor del PC, loop stability, top read addr</li>
                    <li>[ ] Analizar resultados del clasificador DMG v4 y determinar fix mínimo según las clasificaciones</li>
                    <li>[ ] Si SOURCE_READS_ZERO → Investigar MBC/banking/ROM read</li>
                    <li>[ ] Si ONLY_CLEAR_TO_ZERO + wait loop → Investigar flags de VBlank handler</li>
                    <li>[ ] Si NONZERO_WRITTEN_THEN_CLEARED → Identificar quién limpia y por qué</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>
