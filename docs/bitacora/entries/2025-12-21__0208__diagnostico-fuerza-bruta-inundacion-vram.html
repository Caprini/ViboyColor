<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagn贸stico de Fuerza Bruta: Inundaci贸n de VRAM - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Diagn贸stico de Fuerza Bruta: Inundaci贸n de VRAM</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-21
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0208
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-21__0207__ajuste-coordenadas-centrado-logo.html">Anterior (0207)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Despu茅s del Step 0207, con las coordenadas corregidas, la pantalla sigue mostr谩ndose en blanco y los logs muestran ceros. Esto sugiere que la PPU no est谩 "viendo" los datos que inyectamos en la VRAM. Para resolver esto definitivamente, aplicamos una t茅cnica de diagn贸stico agresiva: llenar toda la regi贸n de Tile Data (0x8000-0x97FF) con `0xFF` (p铆xeles negros). Si la pantalla se vuelve negra, confirmamos que la PPU S lee la VRAM y que el problema es de coordenadas o formato. Si la pantalla sigue blanca, hay un error fundamental en c贸mo la MMU o la PPU acceden a la memoria de v铆deo.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: Tile Data Inundado</h2>
                <p>
                    La regi贸n de Tile Data de la VRAM (`0x8000` a `0x97FF`) contiene los patrones gr谩ficos de todos los tiles que pueden ser renderizados. Cada tile ocupa 16 bytes en formato 2bpp (2 bits por p铆xel), lo que permite 384 tiles distintos (1536 bytes / 16 bytes por tile = 96 tiles en modo signed, o 384 tiles en modo unsigned).
                </p>
                <p>
                    <strong>Formato de Tile (2bpp):</strong>
                </p>
                <ul>
                    <li>Cada tile es una matriz de 88 p铆xeles</li>
                    <li>Cada p铆xel usa 2 bits (4 colores posibles: 00=Blanco, 01=Gris claro, 10=Gris oscuro, 11=Negro)</li>
                    <li>16 bytes por tile: 8 filas  2 bytes por fila (1 byte para el bit bajo, 1 byte para el bit alto)</li>
                </ul>
                <p>
                    <strong>El valor 0xFF en formato Tile:</strong>
                </p>
                <ul>
                    <li>Si llenamos toda la memoria de tiles con `0xFF`, cada byte se convierte en `0xFF`</li>
                    <li>En formato 2bpp, `0xFF` significa que ambos bits (alto y bajo) est谩n activados para todos los p铆xeles</li>
                    <li>Esto convierte cada tile en un bloque s贸lido de Color 3 (Negro)</li>
                    <li>Como el Tilemap por defecto (`0x9800`) est谩 inicializado a ceros (Tile ID 0), si convertimos el Tile 0 en un bloque negro, <strong>toda la pantalla deber铆a volverse negra</strong></li>
                </ul>
                <p>
                    <strong>Diagn贸stico binario:</strong>
                </p>
                <ul>
                    <li><strong>Pantalla NEGRA:</strong> La PPU S lee la VRAM correctamente. El problema anterior era de coordenadas, formato de datos o Tile IDs incorrectos.</li>
                    <li><strong>Pantalla BLANCA:</strong> La PPU NO est谩 leyendo la VRAM, o est谩 leyendo de otro lugar. Esto indica un error fundamental en el acceso a memoria de v铆deo (posiblemente VRAM Banking de CGB que devuelve ceros si no est谩 configurada correctamente).</li>
                </ul>
                <p>
                    <strong>Fuente:</strong> Pan Docs - "Tile Data", "Tile Map", "VRAM"
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Modificamos el constructor de `MMU::MMU()` para comentar temporalmente la carga del logo y a帽adir un bucle de "inundaci贸n" que llene toda la regi贸n de Tile Data con `0xFF`.
                </p>
                
                <h3>Modificaci贸n en MMU.cpp</h3>
                <p>
                    En <code>src/core/cpp/MMU.cpp</code>, dentro del constructor <code>MMU::MMU()</code>, comentamos la carga del logo (Steps 0206-0207) y a帽adimos el bucle de inundaci贸n:
                </p>
                <pre><code>// --- Step 0206: Pre-cargar VRAM con el logo personalizado "Viboy Color" (Formato Tile 2bpp) ---
// TEMPORALMENTE COMENTADO PARA STEP 0208: Diagn贸stico de Fuerza Bruta
/*
// ... c贸digo del logo comentado ...
*/

// --- Step 0208: DIAGNSTICO VRAM FLOOD (Inundaci贸n de VRAM) ---
// TCNICA DE FUERZA BRUTA: Llenar toda el 谩rea de Tile Data (0x8000 - 0x97FF) con 0xFF.
// Si la pantalla se vuelve negra, sabremos que la PPU S lee la VRAM.
// Si la pantalla sigue blanca, hay un error fundamental en el acceso a memoria de v铆deo.
//
// Concepto: 0xFF en formato Tile (2bpp) = todos los p铆xeles en Color 3 (Negro).
// Como el Tilemap por defecto (0x9800) est谩 inicializado a ceros (Tile ID 0),
// si convertimos el Tile 0 en un bloque negro, toda la pantalla deber铆a volverse negra.
//
// Fuente: Pan Docs - "Tile Data", "Tile Map"
printf("[MMU] INUNDANDO VRAM CON 0xFF (NEGRO) PARA DIAGNSTICO...\n");
for (int i = 0x8000; i < 0x9800; ++i) {
    memory_[i] = 0xFF;
}
// -----------------------------------------</code></pre>
                <p>
                    <strong>Explicaci贸n del rango:</strong>
                </p>
                <ul>
                    <li><strong>Inicio:</strong> `0x8000` (inicio de la regi贸n de Tile Data)</li>
                    <li><strong>Fin:</strong> `0x9800` (inicio del Tilemap, exclusivo)</li>
                    <li><strong>Rango total:</strong> `0x9800 - 0x8000 = 0x1800 = 6144 bytes = 384 tiles`</li>
                </ul>
                <p>
                    <strong>Nota sobre printf:</strong> El archivo ya incluye <code>#include &lt;cstdio&gt;</code> (l铆nea 6), por lo que no es necesario a帽adirlo.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Comentado c贸digo del logo (Steps 0206-0207) y a帽adido bucle de inundaci贸n de VRAM (l铆neas 95-121)</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    La verificaci贸n se realizar谩 mediante ejecuci贸n del emulador y observaci贸n visual del resultado:
                </p>
                <ul>
                    <li><strong>Comando de recompilaci贸n:</strong> <code>.\rebuild_cpp.ps1</code></li>
                    <li><strong>Comando de ejecuci贸n:</strong> <code>python main.py roms/tetris.gb</code></li>
                    <li><strong>Log esperado:</strong> El mensaje <code>[MMU] INUNDANDO VRAM CON 0xFF (NEGRO) PARA DIAGNSTICO...</code> debe aparecer en la consola al iniciar el emulador</li>
                </ul>
                <p>
                    <strong>Resultado esperado (Binario):</strong>
                </p>
                <ul>
                    <li><strong>Pantalla NEGRA (o muy oscura):</strong> 隆xito! La PPU lee correctamente la VRAM. El problema con el logo era que est谩bamos usando Tile IDs incorrectos, o escribiendo en un banco de VRAM equivocado, o el Tile 0 estaba dominando la pantalla.</li>
                    <li><strong>Pantalla BLANCA:</strong> Fallo cr铆tico de acceso a memoria. Aunque escribimos en `memory_`, la PPU est谩 leyendo de otro sitio, o la lectura es interceptada incorrectamente (quiz谩s por l贸gica de VRAM Banking de CGB que devuelve ceros si no est谩 configurada).</li>
                </ul>
                <p>
                    <strong>Validaci贸n de m贸dulo compilado C++:</strong> El m贸dulo C++ se recompil贸 usando <code>.\rebuild_cpp.ps1</code> para aplicar los cambios. La compilaci贸n fue exitosa sin errores.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Data.html">Tile Data</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Map.html">Tile Map</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Video_Display.html">Video Display</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Diagn贸stico de fuerza bruta:</strong> Cuando el diagn贸stico fino no funciona, a veces es necesario usar t茅cnicas agresivas que eliminen variables. Llenar toda la VRAM con un valor constante (0xFF) elimina cualquier duda sobre "d贸nde est谩 el logo" o "qu茅 tile usa el mapa". Si la PPU lee VRAM, veremos negro. Si no, seguiremos viendo blanco.</li>
                        <li><strong>Formato de Tile 2bpp:</strong> El valor 0xFF en ambos bytes (bit bajo y bit alto) convierte todos los p铆xeles de un tile en Color 3 (Negro). Si llenamos toda la regi贸n de Tile Data con 0xFF, todos los tiles posibles se convierten en bloques negros.</li>
                        <li><strong>Dependencia del Tilemap:</strong> Para que la inundaci贸n tenga efecto visual, el Tilemap debe estar apuntando a los tiles inundados. Como el Tilemap por defecto est谩 inicializado a ceros (Tile ID 0), si convertimos el Tile 0 en negro, toda la pantalla deber铆a volverse negra.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Resultado del diagn贸stico:</strong> 驴La pantalla se vuelve negra o sigue blanca? Este resultado determinar谩 el siguiente paso del diagn贸stico.</li>
                        <li><strong>Acceso a VRAM en modo CGB:</strong> Si la pantalla sigue blanca, necesitaremos investigar si hay l贸gica de VRAM Banking en modo CGB que est茅 interceptando las lecturas y devolviendo ceros.</li>
                        <li><strong>Integridad de la MMU::write():</strong> Si la pantalla sigue blanca, debemos verificar que `MMU::write()` est谩 realmente escribiendo en `memory_` para direcciones en el rango 0x8000-0x97FF, o si hay alguna l贸gica especial que intercepta estas escrituras.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Suposici贸n principal:</strong> Asumimos que si escribimos `0xFF` en `memory_[0x8000]` hasta `memory_[0x97FF]`, y el Tilemap apunta a Tile ID 0, la PPU deber铆a renderizar p铆xeles negros. Si esto no ocurre, hay un error fundamental en c贸mo la PPU accede a la VRAM, o en c贸mo la MMU maneja las escrituras en ese rango.
                    </p>
                    <p>
                        <strong>Posible interferencia de CGB:</strong> Si el emulador est谩 detectando la ROM como CGB (aunque sea una ROM DMG), podr铆a haber l贸gica de VRAM Banking que intercepta las lecturas y devuelve ceros si no est谩 configurada correctamente. Esta es una hip贸tesis a investigar si el diagn贸stico falla.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y observar el resultado visual</li>
                    <li>[ ] Si la pantalla se vuelve negra: Restaurar el c贸digo del logo y ajustar Tile IDs o coordenadas seg煤n sea necesario</li>
                    <li>[ ] Si la pantalla sigue blanca: Investigar el acceso a VRAM (posible VRAM Banking de CGB, o l贸gica especial en `MMU::read()` para el rango 0x8000-0x9FFF)</li>
                    <li>[ ] Verificar que `MMU::write()` est谩 realmente escribiendo en `memory_` para direcciones en el rango 0x8000-0x97FF</li>
                    <li>[ ] A帽adir logs de diagn贸stico en `PPU::render_scanline()` para verificar qu茅 valores lee realmente la PPU desde la VRAM</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

