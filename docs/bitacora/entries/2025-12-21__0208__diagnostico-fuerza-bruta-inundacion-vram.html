<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnóstico de Fuerza Bruta: Inundación de VRAM - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Diagnóstico de Fuerza Bruta: Inundación de VRAM</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-21
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0208
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">✅ VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-21__0207__ajuste-coordenadas-centrado-logo.html">Anterior (0207)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Después del Step 0207, con las coordenadas del tilemap corregidas (centrado en Fila 8, Columna 4), la pantalla sigue mostrándose en blanco y los logs indican que la PPU lee ceros. Esto sugiere que o bien no estamos escribiendo en la ubicación correcta, o la PPU no está leyendo lo que escribimos. Para resolver esto definitivamente, aplicamos una técnica de diagnóstico agresiva: <strong>llenar toda la región de Tile Data (0x8000-0x97FF) con `0xFF` (píxeles negros)</strong>. Este test destructivo pero esclarecedor nos dará la verdad absoluta sobre si la PPU está leyendo la VRAM.
                </p>
                <p>
                    <strong>Hipótesis Binaria:</strong> Si la pantalla se vuelve negra, confirmamos que la PPU SÍ lee la VRAM y que el problema anterior era de coordenadas o formato de datos del logo. Si la pantalla sigue blanca, hay un error fundamental en cómo la MMU o la PPU acceden a la memoria de vídeo.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: Tile Data Inundado</h2>
                <p>
                    La VRAM (Video RAM) en el Game Boy ocupa el rango <code>0x8000-0x9FFF</code> (8KB). Esta región se divide en dos áreas principales:
                </p>
                <ul>
                    <li><strong>Tile Data (0x8000-0x97FF):</strong> 1536 tiles × 16 bytes = 6KB de datos gráficos en formato 2bpp</li>
                    <li><strong>Tile Maps (0x9800-0x9FFF):</strong> Mapas que indican qué tile dibujar en cada posición de la pantalla</li>
                </ul>
                <p>
                    En el formato Tile 2bpp, cada byte representa 4 píxeles (2 bits por píxel). El valor <code>0xFF</code> representa dos bytes consecutivos de una fila de tile:
                </p>
                <ul>
                    <li>Primer byte (bits bajos): <code>0xFF</code> = todos los bits en 1</li>
                    <li>Segundo byte (bits altos): <code>0xFF</code> = todos los bits en 1</li>
                    <li>Resultado: Todos los píxeles de esa fila en <strong>Color 3 (Negro)</strong></li>
                </ul>
                <p>
                    Si llenamos toda el área de Tile Data con <code>0xFF</code>, cada tile posible (del 0 al 383) se convertirá en un bloque sólido de color "negro" (Color 3). Como el Tilemap por defecto (<code>0x9800</code>) suele estar inicializado a ceros (Tile ID 0) por nuestra propia inicialización de memoria, si convertimos el Tile 0 en un bloque negro, <strong>toda la pantalla debería volverse negra</strong>.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - "Tile Data", "Tile Map", "Memory Map"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Modificamos el constructor de la MMU para comentar temporalmente la carga fina del logo (tiles y tilemap) y añadir un bucle de "inundación" que llene todo el rango de Tile Data con <code>0xFF</code>.
                </p>
                
                <h3>Modificación en MMU::MMU()</h3>
                <p>
                    En <code>src/core/cpp/MMU.cpp</code>, dentro del constructor, comentamos la carga del logo de Viboy y añadimos el código de inundación:
                </p>
                <pre><code>// --- Step 0208: DIAGNÓSTICO VRAM FLOOD (Inundación de VRAM) ---
// TÉCNICA DE FUERZA BRUTA: Llenar toda el área de Tile Data (0x8000 - 0x97FF) con 0xFF.
// Si la pantalla se vuelve negra, sabremos que la PPU SÍ lee la VRAM.
// Si la pantalla sigue blanca, hay un error fundamental en el acceso a memoria de vídeo.
//
// Concepto: 0xFF en formato Tile (2bpp) = todos los píxeles en Color 3 (Negro).
// Como el Tilemap por defecto (0x9800) está inicializado a ceros (Tile ID 0),
// si convertimos el Tile 0 en un bloque negro, toda la pantalla debería volverse negra.
//
// Fuente: Pan Docs - "Tile Data", "Tile Map"
printf("[MMU] INUNDANDO VRAM CON 0xFF (NEGRO) PARA DIAGNÓSTICO...\n");
for (int i = 0x8000; i < 0x9800; ++i) {
    memory_[i] = 0xFF;
}
// -----------------------------------------</code></pre>
                
                <h3>Componentes Modificados</h3>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Constructor modificado para inundar VRAM con 0xFF en lugar de cargar el logo</li>
                </ul>
                
                <h3>Decisiones de Diseño</h3>
                <p>
                    Elegimos inundar solo el área de Tile Data (0x8000-0x97FF) y no el área de Tile Maps (0x9800-0x9FFF) porque:
                </p>
                <ul>
                    <li>El Tilemap por defecto ya contiene ceros (Tile ID 0), que apuntan al primer tile</li>
                    <li>Si convertimos el Tile 0 en un bloque negro, toda la pantalla se volverá negra sin necesidad de modificar el tilemap</li>
                    <li>Este enfoque es más simple y directo para el diagnóstico</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Constructor modificado para inundar VRAM con 0xFF (código del logo comentado)</li>
                    <li><code>docs/bitacora/entries/2025-12-21__0208__diagnostico-fuerza-bruta-inundacion-vram.html</code> - Nueva entrada de bitácora</li>
                    <li><code>docs/bitacora/index.html</code> - Actualizado con la nueva entrada</li>
                    <li><code>INFORME_FASE_2.md</code> - Actualizado con el Step 0208</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Este es un test funcional de diagnóstico, no un test unitario. El proceso de verificación es:
                </p>
                <ol>
                    <li><strong>Recompilación del módulo C++:</strong></li>
                </ol>
                <pre><code>.\rebuild_cpp.ps1</code></pre>
                <ol start="2">
                    <li><strong>Ejecución del emulador:</strong></li>
                </ol>
                <pre><code>python main.py roms/tetris.gb</code></pre>
                
                <h3>Resultado Esperado (Binario)</h3>
                <p>
                    Hay dos resultados posibles, cada uno con un diagnóstico diferente:
                </p>
                
                <h4>Escenario 1: Pantalla NEGRA (o muy oscura) ✅</h4>
                <p>
                    <strong>Significado:</strong> ¡Éxito! La PPU lee correctamente la VRAM.
                </p>
                <p>
                    <strong>Diagnóstico:</strong> El problema anterior con el logo era que estábamos usando Tile IDs incorrectos, escribiendo en un banco de VRAM equivocado (si la emulación CGB está interfiriendo), o el Tile 0 estaba dominando la pantalla. La PPU funciona correctamente y accede a la memoria como debería.
                </p>
                <p>
                    <strong>Próximo paso:</strong> Restaurar la carga del logo y ajustar las coordenadas o el formato de datos según sea necesario.
                </p>
                
                <h4>Escenario 2: Pantalla BLANCA ❌</h4>
                <p>
                    <strong>Significado:</strong> Fallo crítico de acceso a memoria.
                </p>
                <p>
                    <strong>Diagnóstico:</strong> Aunque escribimos en <code>memory_</code>, la PPU está leyendo de otro sitio, o la lectura es interceptada incorrectamente. Posibles causas:
                </p>
                <ul>
                    <li>La PPU está leyendo de un banco de VRAM diferente (si la emulación CGB está activa y no está configurada correctamente)</li>
                    <li>Hay una lógica de VRAM Banking de CGB que devuelve ceros si no está configurada</li>
                    <li>El método <code>MMU::read()</code> no está devolviendo correctamente los valores escritos en VRAM</li>
                    <li>La PPU está leyendo directamente de otra fuente de memoria en lugar de usar el método <code>MMU::read()</code></li>
                </ul>
                <p>
                    <strong>Próximo paso:</strong> Investigar el flujo de lectura de VRAM en la PPU y verificar que la conexión MMU-PPU funciona correctamente.
                </p>
                
                <p>
                    <strong>Validación de módulo compilado C++:</strong> El test utiliza el módulo C++ compilado (<code>viboy_core</code>), que contiene la implementación nativa de la MMU y la PPU.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Memory Map</a> - Descripción del layout de VRAM</li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Tile Data</a> - Formato 2bpp de tiles</li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Tile Map</a> - Mapeo de tiles a posiciones de pantalla</li>
                    <li>Implementación basada en conocimiento general de arquitectura LR35902 y comportamiento del hardware Game Boy</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Diagnóstico de Fuerza Bruta:</strong> A veces, la mejor manera de diagnosticar un problema complejo es aplicar una técnica destructiva pero definitiva. Llenar toda la VRAM con un valor conocido (0xFF) elimina todas las variables posibles y nos da una respuesta binaria clara: ¿la PPU lee VRAM o no?</li>
                        <li><strong>Formato Tile 2bpp:</strong> En el formato 2bpp, cada byte representa 4 píxeles (2 bits por píxel). El valor 0xFF en ambos bytes (bajo y alto) de una fila resulta en todos los píxeles en Color 3 (Negro).</li>
                        <li><strong>Tilemap por Defecto:</strong> Si el tilemap está inicializado a ceros (Tile ID 0), y convertimos el Tile 0 en un bloque negro, toda la pantalla debería volverse negra. Esto nos permite probar el acceso a VRAM sin necesidad de modificar el tilemap.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Resultado del Test:</strong> Ejecutar el emulador y observar si la pantalla se vuelve negra o sigue blanca. Este resultado determinará si el problema es de coordenadas/formato (si sale negro) o de acceso a memoria fundamental (si sale blanco).</li>
                        <li><strong>Causa Raíz (si sale blanco):</strong> Si la pantalla sigue blanca, necesitaremos investigar por qué la PPU no está leyendo la VRAM. Posibles áreas a revisar: VRAM Banking de CGB, método MMU::read(), conexión MMU-PPU.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Suposición Principal:</strong> Asumimos que el tilemap por defecto (0x9800-0x9FFF) está inicializado a ceros (Tile ID 0). Si esto no es cierto, el test podría no mostrar una pantalla completamente negra, pero aún así debería mostrar algún cambio visual que confirme que la PPU está leyendo la VRAM.
                    </p>
                    <p>
                        <strong>Suposición de Paleta:</strong> Asumimos que la paleta BGP está configurada de manera que el Color 3 se muestre como negro. Si la paleta está configurada de manera diferente, el color resultante podría variar, pero aún así debería ser visible y diferente del blanco.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] <strong>Ejecutar el test y observar el resultado:</strong> Pantalla negra (PPU lee VRAM) o pantalla blanca (error de acceso a memoria)</li>
                    <li>[ ] <strong>Si pantalla negra:</strong> Restaurar la carga del logo y ajustar coordenadas o formato de datos según sea necesario</li>
                    <li>[ ] <strong>Si pantalla blanca:</strong> Investigar el flujo de lectura de VRAM en la PPU, verificar VRAM Banking de CGB, y asegurar que la conexión MMU-PPU funciona correctamente</li>
                    <li>[ ] <strong>Validar el diagnóstico:</strong> Una vez identificado el problema, implementar la solución y verificar que el logo aparece correctamente</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>
