<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0387 - Diagn√≥stico de PC Corrupto en 0xFEE6 (Zelda DX)</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Breadcrumbs -->
        <nav class="breadcrumbs">
            <a href="../../index.html">Inicio</a> &raquo;
            <a href="../index.html">Bit√°cora</a> &raquo;
            <span>Step 0387</span>
        </nav>

        <!-- Entry Header -->
        <header class="entry-header">
            <h1>Step 0387: Diagn√≥stico de PC Corrupto en 0xFEE6 (Zelda DX)</h1>
            <div class="entry-meta">
                <span><strong>Fecha:</strong> 2025-12-30</span>
                <span><strong>Categor√≠a:</strong> Diagn√≥stico</span>
                <span><strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span></span>
                <span><strong>Commit:</strong> <code>feat(debug): crash-probe PC en 0xFE** y trazado de stack/RETI</code></span>
            </div>
        </header>

        <!-- Main Content -->
        <main class="entry-content">
            <!-- Contexto -->
            <section>
                <h2>Contexto</h2>
                <p>
                    El <strong>Step 0386</strong> aplic√≥ un workaround deshabilitando STAT IRQ para resolver el problema de <code>IF</code> "pegado" en <code>0x02</code>. 
                    Tras esa correcci√≥n, se report√≥ que <strong>Zelda DX</strong> segu√≠a sin ser jugable y crasheaba hacia <code>PC:0xFEE6</code>, 
                    un rango que corresponde a la regi√≥n OAM/No Usable (<code>0xFE00-0xFEFF</code>).
                </p>
                <p>
                    Ejecutar c√≥digo en esa regi√≥n normalmente indica:
                </p>
                <ul>
                    <li><strong>Corrupci√≥n del PC</strong>: Un return address inv√°lido sacado del stack</li>
                    <li><strong>Corrupci√≥n del Stack (SP)</strong>: Push/pop desbalanceados o escrituras fuera de rango</li>
                    <li><strong>Salto a direcci√≥n calculada incorrectamente</strong>: Ej. <code>JP (HL)</code> con <code>HL</code> corrupto</li>
                </ul>
                <p>
                    Este step implementa instrumentaci√≥n exhaustiva para capturar el momento exacto del crash y determinar su causa ra√≠z.
                </p>
            </section>

            <!-- Concepto de Hardware -->
            <section>
                <h2>Concepto de Hardware</h2>
                <h3>Regi√≥n 0xFE00-0xFEFF en Game Boy</h3>
                <p>
                    Seg√∫n Pan Docs, el mapa de memoria en esta regi√≥n es:
                </p>
                <ul>
                    <li><code>0xFE00-0xFE9F</code>: <strong>OAM (Object Attribute Memory)</strong> - 160 bytes para 40 sprites</li>
                    <li><code>0xFEA0-0xFEFF</code>: <strong>"Not Usable"</strong> - Regi√≥n no funcional, devuelve valores aleatorios en hardware real</li>
                </ul>
                <p>
                    <strong>Ejecutar c√≥digo en esta regi√≥n es siempre un error</strong>. Indica que el <code>PC</code> fue establecido 
                    a un valor inv√°lido, t√≠picamente por:
                </p>

                <h3>Stack y Retornos (RETI/RET)</h3>
                <p>
                    El stack de la Game Boy crece hacia abajo:
                </p>
                <ul>
                    <li><strong>PUSH</strong>: <code>SP = SP - 2</code>, escribe high byte en <code>SP+1</code>, low byte en <code>SP</code></li>
                    <li><strong>POP</strong>: Lee low byte de <code>SP</code>, high byte de <code>SP+1</code>, luego <code>SP = SP + 2</code></li>
                    <li><strong>RETI (0xD9)</strong>: <code>PC = pop_word(); IME = 1;</code></li>
                </ul>
                <p>
                    Si el stack est√° corrupto o <code>SP</code> apunta a datos no v√°lidos, <code>RETI</code> restaurar√° un 
                    <code>PC</code> basura (ej. <code>0xFEE6</code>).
                </p>

                <h3>Servicio de Interrupciones</h3>
                <p>
                    Cuando ocurre una interrupci√≥n con <code>IME=1</code>:
                </p>
                <ol>
                    <li>CPU deshabilita <code>IME</code> (evita interrupciones anidadas)</li>
                    <li>Guarda <code>PC</code> actual en el stack: <code>push_word(PC)</code></li>
                    <li>Salta al vector (ej. <code>0x0040</code> para VBlank)</li>
                    <li>El handler termina con <code>RETI</code>, que restaura <code>PC</code> desde el stack</li>
                </ol>
                <p>
                    Si el <code>PUSH</code> escribe a direcciones incorrectas o el <code>POP</code> lee de una regi√≥n 
                    sobrescrita, el retorno ser√° a una direcci√≥n inv√°lida.
                </p>

                <p><strong>Fuente:</strong> Pan Docs - Memory Map, Interrupts, Stack Operations</p>
            </section>

            <!-- Implementaci√≥n -->
            <section>
                <h2>Implementaci√≥n</h2>
                <h3>1. Ring Buffer de √öltimas 64 Instrucciones (CPU.hpp/CPU.cpp)</h3>
                <p>
                    Se a√±ade un ring buffer circular que captura un snapshot de cada instrucci√≥n ejecutada:
                </p>
                <pre><code class="language-cpp">// En CPU.hpp
struct InstrSnapshot {
    uint16_t pc, sp, af, bc, de, hl;
    uint8_t bank, op, op1, op2, ime, ie, if_flag;
};
static constexpr int RING_SIZE = 64;
InstrSnapshot ring_buffer_[RING_SIZE];
int ring_idx_;
bool crash_dumped_;</code></pre>

                <p>
                    En <code>step()</code>, despu√©s del fetch del opcode:
                </p>
                <pre><code class="language-cpp">// Capturar snapshot en el ring buffer
ring_buffer_[ring_idx_].pc = original_pc;
ring_buffer_[ring_idx_].sp = regs_->sp;
ring_buffer_[ring_idx_].af = regs_->get_af();
// ... (resto de registros)
ring_idx_ = (ring_idx_ + 1) % RING_SIZE;

// Detectar crash en regi√≥n FE00-FEFF
if (!crash_dumped_ && original_pc >= 0xFE00 && original_pc <= 0xFEFF) {
    crash_dumped_ = true;
    printf("[CRASH-PC] ‚ö†Ô∏è PC CORRUPTO: PC=0x%04X (regi√≥n OAM/no usable)\n", original_pc);
    
    // Dump completo del ring buffer (√∫ltimas 64 instrucciones)
    for (int i = 0; i < RING_SIZE; i++) {
        int idx = (ring_idx_ + i) % RING_SIZE;
        printf("[CRASH-RING] #%02d PC:0x%04X Bank:%d OP:%02X %02X %02X | SP:%04X AF:%04X...\n",
               i, ring_buffer_[idx].pc, ...);
    }
}</code></pre>

                <h3>2. Trazado de Stack en IRQ Push (CPU.cpp - handle_interrupts)</h3>
                <pre><code class="language-cpp">// ANTES del push_word(prev_pc)
uint16_t sp_before_push = regs_->sp;
printf("[IRQ-PUSH-PC] ANTES: SP=0x%04X PC_to_push=0x%04X\n", sp_before_push, prev_pc);

push_word(prev_pc);

// DESPUES del push
uint16_t sp_after_push = regs_->sp;
uint8_t byte_low = mmu_->read(sp_after_push);
uint8_t byte_high = mmu_->read(sp_after_push + 1);
printf("[IRQ-PUSH-PC] DESPUES: SP=0x%04X Written=[0x%02X,0x%02X] Reconstruct=0x%04X\n",
       sp_after_push, byte_low, byte_high,
       (static_cast<uint16_t>(byte_high) << 8) | byte_low);

// Guardrail: verificar SP en rango peligroso
if (sp_after_push < 0xC000 || sp_after_push >= 0xFE00) {
    printf("[STACK-WARN] ‚ö†Ô∏è SP en rango peligroso: 0x%04X\n", sp_after_push);
}</code></pre>

                <h3>3. Trazado de RETI Pop (CPU.cpp - case 0xD9)</h3>
                <pre><code class="language-cpp">// ANTES del pop_word()
uint16_t sp_before_pop = regs_->sp;
uint8_t byte_low = mmu_->read(sp_before_pop);
uint8_t byte_high = mmu_->read(sp_before_pop + 1);
uint16_t reconstructed = (byte_high << 8) | byte_low;
printf("[RETI-POP-PC] ANTES: SP=0x%04X Bytes=[0x%02X,0x%02X] Reconstruct=0x%04X\n",
       sp_before_pop, byte_low, byte_high, reconstructed);

uint16_t return_addr = pop_word();

// DESPUES del pop
printf("[RETI-POP-PC] DESPUES: return_addr=0x%04X SP=0x%04X IME=1\n", return_addr, regs_->sp);

// Guardrail: verificar return_addr corrupto
if (return_addr >= 0xFE00 && return_addr <= 0xFEFF) {
    printf("[RETI-POP-PC] ‚ö†Ô∏è RETURN ADDRESS CORRUPTO: 0x%04X (regi√≥n OAM!)\n", return_addr);
}</code></pre>

                <h3>4. Instrumentaci√≥n de Escrituras a FE00-FEFF (MMU.cpp)</h3>
                <pre><code class="language-cpp">// Al inicio de MMU::write()
if (addr >= 0xFE00 && addr <= 0xFEFF && fe_write_count < 60) {
    printf("[MMU-FE-WRITE] PC=0x%04X addr=0x%04X value=0x%02X Bank=%d",
           debug_current_pc, addr, value, get_current_rom_bank());
    
    if (addr >= 0xFEA0) {
        printf(" ‚ö†Ô∏è UNUSABLE REGION\n");
    } else {
        printf(" (OAM valid)\n");
    }
    fe_write_count++;
}</code></pre>
            </section>

            <!-- Tests y Verificaci√≥n -->
            <section>
                <h2>Tests y Verificaci√≥n</h2>
                <h3>Compilaci√≥n</h3>
                <pre><code class="language-bash">python3 setup.py build_ext --inplace > build_log_step0387.txt 2>&1
# ‚úÖ Compilaci√≥n exitosa sin errores</code></pre>

                <h3>Ejecuci√≥n de Prueba</h3>
                <pre><code class="language-bash">timeout 10 python3 main.py roms/zelda-dx.gbc > logs/step0387_fe_pc_probe.log 2>&1</code></pre>

                <h3>An√°lisis de Logs (Comandos Seguros)</h3>
                <pre><code class="language-bash"># 1) Buscar crash en FE00-FEFF
grep -E "\[CRASH-PC\]" logs/step0387_fe_pc_probe.log | head -n 5
# Resultado: ‚ùå No encontrado (exit code 1)

# 2) Verificar push/pop de IRQ
grep -E "\[(IRQ-PUSH-PC|RETI-POP-PC|STACK-WARN)\]" logs/step0387_fe_pc_probe.log | head -n 60
# Resultado: ‚ùå No encontrado (las interrupciones no se est√°n procesando)

# 3) Verificar writes a FE00-FEFF
grep -E "\[MMU-FE-WRITE\]" logs/step0387_fe_pc_probe.log | head -n 60
# Resultado: ‚ùå No encontrado

# 4) CPU Samples (verificar estado general)
grep -E "\[CPU-SAMPLE\]" logs/step0387_fe_pc_probe.log | head -n 20
# Resultado: ‚úÖ CPU ejecutando normalmente (200K+ instrucciones)</code></pre>

                <h3>Hallazgos Cr√≠ticos</h3>
                <div class="hallazgo-critico">
                    <h4>üîç Hallazgo Principal: El Crash en 0xFEE6 NO Se Reproduce</h4>
                    <p>
                        Tras ejecutar 10 segundos (‚âà200K instrucciones), <strong>NO se detect√≥ ning√∫n salto a PC en rango 0xFE00-0xFEFF</strong>. 
                        El crash reportado en Step 0386 NO ocurre en la ejecuci√≥n actual.
                    </p>
                </div>

                <div class="hallazgo-critico">
                    <h4>‚ö†Ô∏è Problema Real: Interrupciones Completamente Deshabilitadas</h4>
                    <p>An√°lisis de los CPU samples revela:</p>
                    <ul>
                        <li><code>PC: 0x6B95-0x6B9B</code> (Bank 60) - Bucle de polling estrecho</li>
                        <li><code>IME=0</code> - Interrupciones deshabilitadas globalmente</li>
                        <li><code>IE=0x00</code> - <strong>NINGUNA interrupci√≥n habilitada</strong> (ni VBlank, ni STAT, ni Timer...)</li>
                        <li><code>IF=0x01</code> - VBlank flag activo pero ignorado (no puede atenderse con IE=0x00)</li>
                        <li>El juego lee <code>P1 (0xFF00)</code> repetidamente - <strong>bucle de polling de joypad</strong></li>
                    </ul>
                    <p>
                        <strong>Diagn√≥stico:</strong> El workaround del Step 0386 (deshabilitar STAT IRQ) caus√≥ un efecto secundario 
                        donde el juego deshabilita TODAS las interrupciones (<code>IE=0x00</code>), quedando atascado en un wait-loop.
                    </p>
                </div>

                <div class="hallazgo-critico">
                    <h4>‚úÖ Evidencia de Renderizado Funcional</h4>
                    <ul>
                        <li>Frame 94 alcanzado (m√°s de 1.5 segundos de emulaci√≥n)</li>
                        <li>Framebuffer con p√≠xeles v√°lidos (80/160 no-cero por l√≠nea)</li>
                        <li>Distribuci√≥n de colores normal (√≠ndices 0 y 3)</li>
                    </ul>
                </div>
            </section>

            <!-- Validaci√≥n Nativa -->
            <section>
                <h2>Validaci√≥n Nativa</h2>
                <p>
                    ‚úÖ <strong>M√≥dulo compilado C++</strong> con instrumentaci√≥n completa en:
                </p>
                <ul>
                    <li><code>CPU::step()</code> - Ring buffer de 64 snapshots + detecci√≥n de crash</li>
                    <li><code>CPU::handle_interrupts()</code> - Trazado de IRQ push con verificaci√≥n de SP</li>
                    <li><code>CPU (case 0xD9)</code> - Trazado de RETI pop con detecci√≥n de return_addr corrupto</li>
                    <li><code>MMU::write()</code> - Detecci√≥n de writes a regi√≥n FE00-FEFF</li>
                </ul>
                <p>
                    La instrumentaci√≥n funcion√≥ correctamente. <strong>No se detect√≥ ning√∫n crash</strong>, pero revel√≥ 
                    el problema subyacente: <code>IE=0x00</code> (interrupciones totalmente deshabilitadas).
                </p>
            </section>

            <!-- Archivos Modificados -->
            <section>
                <h2>Archivos Modificados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.hpp</code> - A√±adido struct InstrSnapshot y miembros del ring buffer</li>
                    <li><code>src/core/cpp/CPU.cpp</code> - Implementaci√≥n de ring buffer, detecci√≥n de crash, trazado IRQ/RETI</li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Trazado de writes a FE00-FEFF</li>
                    <li><code>build_log_step0387.txt</code> - Log de compilaci√≥n</li>
                    <li><code>logs/step0387_fe_pc_probe.log</code> - Log de ejecuci√≥n (1.8MB)</li>
                </ul>
            </section>

            <!-- Conclusi√≥n -->
            <section>
                <h2>Conclusi√≥n</h2>
                <p>
                    El <strong>Step 0387</strong> implement√≥ instrumentaci√≥n exhaustiva para diagnosticar el crash reportado en <code>PC:0xFEE6</code>, 
                    pero el hallazgo principal es que <strong>ese crash NO se reproduce en la ejecuci√≥n actual</strong>.
                </p>
                <p>
                    En su lugar, se identific√≥ el problema real: <strong><code>IE=0x00</code> (interrupciones completamente deshabilitadas)</strong>, 
                    lo que deja al juego atascado en un bucle de polling sin capacidad de progresar.
                </p>
                <p>
                    <strong>Pr√≥ximos pasos (Step 0388):</strong>
                </p>
                <ul>
                    <li>Revisar el workaround del Step 0386 que deshabilita STAT IRQ</li>
                    <li>Implementar rising edge detection correcto para STAT sin deshabilitar la interrupci√≥n completamente</li>
                    <li>Verificar que <code>IE</code> se inicialice correctamente (deber√≠a tener al menos VBlank habilitado)</li>
                    <li>Mantener la instrumentaci√≥n del ring buffer como herramienta de diagn√≥stico permanente</li>
                </ul>
            </section>

            <!-- Referencias -->
            <section>
                <h2>Referencias</h2>
                <ul>
                    <li><a href="https://gbdev.io/pandocs/Memory_Map.html#fe00-feff-range" target="_blank">Pan Docs - Memory Map (0xFE00-0xFEFF)</a></li>
                    <li><a href="https://gbdev.io/pandocs/Interrupts.html" target="_blank">Pan Docs - Interrupts</a></li>
                    <li><a href="https://gbdev.io/pandocs/CGB_Registers.html" target="_blank">Pan Docs - Interrupt Enable (IE) Register</a></li>
                    <li><a href="https://rgbds.gbdev.io/docs/v0.5.2/gbz80.7#RETI" target="_blank">GBZ80 - RETI Instruction</a></li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><a href="../index.html">‚Üê Volver a la Bit√°cora</a></p>
        </footer>
    </div>
</body>
</html>

