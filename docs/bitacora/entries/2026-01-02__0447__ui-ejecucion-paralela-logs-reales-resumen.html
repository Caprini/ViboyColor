<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Ejecución Paralela + Logs Reales + Resumen Path/Profiling - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>UI Ejecución Paralela + Logs Reales + Resumen Path/Profiling</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-02
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0447
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-02__0446__ui-evidencia-real-profiling-presenter.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Ejecución de UI en paralelo con múltiples ROMs (Mario, Pokémon, Tetris, Zelda) para capturar logs reales de path de renderizado, profiling por etapas y métricas de nonwhite. Creación de scripts automatizados para ejecución paralela con timeout, extracción de muestras de logs y detección de freezes. Objetivo: obtener evidencia objetiva de qué path se usa (cpp_rgb_view vs legacy), qué etapa consume más tiempo, y dónde se pierden píxeles (nonwhite antes/después del blit). Resultados: todas las ROMs usan path correcto (cpp_rgb_view), Mario NO se congela pero tiene pérdida masiva de píxeles (11520→1), Pokémon tiene framebuffer blanco desde el core (no es problema de UI), profiling muestra TOTAL ~420ms (posible bloqueo en pygame.event.pump o sleep).
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Ejecución Paralela de UI</strong>: Para ahorrar tiempo en pruebas, se ejecutan múltiples instancias de la UI en paralelo, cada una con una ROM diferente. Cada instancia tiene un timeout (15 segundos) para evitar que se quede colgada indefinidamente. Los logs se capturan por separado para cada ROM, permitiendo análisis independiente.
                </p>
                <p>
                    <strong>Análisis de Logs</strong>: Los logs contienen tres tipos de información crítica:
                </p>
                <ul>
                    <li><strong>[UI-PATH]</strong>: Indica qué path de renderizado se usa (cpp_rgb_view vs legacy_fallback), métricas del framebuffer (len, shape, nonwhite, hash), tiempo de frame y FPS estimada.</li>
                    <li><strong>[UI-PROFILING]</strong>: Mide tiempo por etapa del presenter (frombuffer/reshape, blit_array, scale/blit, flip) y tiempo TOTAL del frame completo.</li>
                    <li><strong>[UI-DEBUG]</strong>: Verifica nonwhite antes y después del blit para detectar pérdida de píxeles durante la presentación.</li>
                </ul>
                <p>
                    <strong>Detección de Freezes</strong>: Si una ROM se congela, el log tendrá muy pocas líneas (<50 líneas). Si una ROM funciona correctamente, generará miles o millones de líneas (dependiendo del timeout y FPS).
                </p>
                <p>
                    <strong>Análisis de Profiling</strong>: El tiempo TOTAL del frame debe ser ~16.67ms para 60 FPS. Si TOTAL es mucho mayor (ej: 420ms), hay un bloqueo o espera en alguna parte (posiblemente pygame.event.pump(), sleep(), o sincronización con el core). Las etapas individuales (frombuffer, blit_array, scale, flip) deben ser <5ms cada una en condiciones normales.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase A: Script de Ejecución Paralela</h3>
                <p>
                    <strong>Archivo</strong>: <code>tools/run_ui_parallel_0447.sh</code>
                </p>
                <p>
                    <strong>Funcionalidad</strong>:
                </p>
                <ul>
                    <li>Ejecuta múltiples ROMs en paralelo usando <code>&</code> (background jobs)</li>
                    <li>Cada instancia tiene timeout de 15 segundos usando <code>timeout 15s</code></li>
                    <li>Usa <code>stdbuf -oL -eL</code> para line-buffering (captura en tiempo real)</li>
                    <li>Logs se guardan en <code>/tmp/viboy_0447/{rom}.log</code></li>
                    <li>Espera a que todas las instancias finalicen con <code>wait</code></li>
                </ul>
                <pre><code>#!/bin/bash
# Ejecutar UI en paralelo con varias ROMs para capturar logs (Step 0447)

LOG_DIR="/tmp/viboy_0447"
mkdir -p "$LOG_DIR"

ROMS=(
    "mario.gbc"      # Crítico: antes freeze + 0.1 FPS
    "pkmn.gb"        # Crítico: blanco previo
    "tetris.gb"      # Baseline DMG
    "tetris_dx.gbc"  # Baseline GBC
    "zelda-dx.gbc"   # Baseline GBC
)

run_ui() {
    local rom="$1"
    local out="$LOG_DIR/${rom}.log"
    timeout 15s stdbuf -oL -eL python3 main.py "roms/${rom}" 2>&1 | tee "$out" &
}

for rom in "${ROMS[@]}"; do
    if [ -f "roms/${rom}" ]; then
        run_ui "$rom"
        sleep 0.5
    fi
done

wait</code></pre>

                <h3>Fase B: Script de Extracción de Logs</h3>
                <p>
                    <strong>Archivo</strong>: <code>tools/extract_ui_logs_0447.sh</code>
                </p>
                <p>
                    <strong>Funcionalidad</strong>:
                </p>
                <ul>
                    <li>Extrae muestras de logs por ROM (primeras 8 líneas de cada tipo)</li>
                    <li>Busca <code>[UI-PATH]</code>, <code>[UI-PROFILING]</code>, <code>[UI-DEBUG]</code></li>
                    <li>Cuenta líneas totales para detectar freezes</li>
                    <li>Genera resumen en <code>/tmp/viboy_0447/summary.txt</code></li>
                </ul>

                <h3>Fase C: Script de Detección de Freezes y Tabla Resumen</h3>
                <p>
                    <strong>Archivo</strong>: <code>tools/detect_freezes_0447.sh</code>
                </p>
                <p>
                    <strong>Funcionalidad</strong>:
                </p>
                <ul>
                    <li>Extrae métricas clave de cada log (path, FPS, nonwhite, etapa más cara)</li>
                    <li>Detecta posibles freezes (ROMs con <50 líneas)</li>
                    <li>Genera tabla resumen en formato markdown</li>
                </ul>
                <pre><code>echo "ROM | Lines | Path | FPS | NonWhite (before/after) | Etapa más cara"
for f in "$LOG_DIR"/*.log; do
    # Extraer métricas...
    # Detectar freeze si line_count < 50
done</code></pre>

            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>tools/run_ui_parallel_0447.sh</code> - Script para ejecutar UI en paralelo con timeout</li>
                    <li><code>tools/extract_ui_logs_0447.sh</code> - Script para extraer muestras de logs por ROM</li>
                    <li><code>tools/detect_freezes_0447.sh</code> - Script para detectar freezes y generar tabla resumen</li>
                </ul>
                <p>
                    <strong>Nota</strong>: No se modificó código core. Solo se crearon scripts de análisis.
                </p>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Ejecución</strong>: Scripts ejecutados exitosamente. Logs capturados para 5 ROMs.
                </p>
                <p>
                    <strong>Resultados por ROM</strong>:
                </p>
                <table style="border-collapse: collapse; width: 100%; margin: 1em 0;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid #ddd; padding: 8px;">ROM</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Lines</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Path</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">FPS</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">NonWhite (before/after)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Etapa más cara</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">mario.gbc</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">6,573,610</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">cpp_rgb_view</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">1304.0</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">11520/1</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">TOTAL</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">pkmn.gb</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">664,683</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">cpp_rgb_view</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">950.1</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">N/A/0</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">TOTAL</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">tetris_dx.gbc</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">44,343</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">cpp_rgb_view</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">1249.9</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">11520/1</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">TOTAL</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">tetris.gb</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">66,850</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">cpp_rgb_view</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">951.2</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">N/A/0</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">TOTAL</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">zelda-dx.gbc</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">31,160</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">cpp_rgb_view</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">947.3</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">11520/0</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">TOTAL</td>
                        </tr>
                    </tbody>
                </table>
                <p>
                    <strong>Hallazgos Clave</strong>:
                </p>
                <ul>
                    <li><strong>Mario NO se congela</strong>: 6.5M líneas de log indican que la UI está funcionando, pero hay pérdida masiva de píxeles (11520→1). El TOTAL de profiling es ~420ms, lo que sugiere bloqueo en pygame.event.pump() o sleep().</li>
                    <li><strong>Pokémon tiene framebuffer blanco desde el core</strong>: NonWhite=0 indica que el problema está en el PPU/core, no en la UI.</li>
                    <li><strong>Todas las ROMs usan path correcto</strong>: cpp_rgb_view (no legacy_fallback).</li>
                    <li><strong>Pérdida de píxeles en GBC</strong>: Mario y Zelda pierden casi todos los píxeles en el blit (11520→1 o 0), sugiriendo problema en formato de superficie o blit.</li>
                </ul>
                <p>
                    <strong>Ejemplo de Log [UI-PATH]</strong>:
                </p>
                <pre><code>[UI-PATH] Frame 4 | Path=cpp_rgb_view | Len=69120 | Shape=rgb_view | NonWhite=11520 | Hash=5d6c318f | Time=0.75ms | FPS=1327.7</code></pre>
                <p>
                    <strong>Ejemplo de Log [UI-PROFILING]</strong>:
                </p>
                <pre><code>[UI-PROFILING] Frame 241 | frombuffer/reshape: 0.01ms | blit_array: 0.06ms | scale/blit: 0.01ms | flip: 5.80ms | TOTAL: 421.43ms</code></pre>
                <p>
                    <strong>Ejemplo de Log [UI-DEBUG]</strong>:
                </p>
                <pre><code>[UI-DEBUG] Nonwhite antes del blit: 11520 (estimado)
[UI-DEBUG] Nonwhite después del blit (sample): 1/3</code></pre>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Bash documentation: <code>timeout</code>, <code>stdbuf</code>, background jobs</li>
                    <li>Pygame documentation: Profiling y optimización de renderizado</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Ejecución paralela</strong>: Se pueden ejecutar múltiples instancias de UI en paralelo usando background jobs de bash, cada una con su propio log.</li>
                        <li><strong>Análisis de logs</strong>: Los logs contienen información estructurada que se puede extraer con grep/awk para generar resúmenes y tablas.</li>
                        <li><strong>Detección de freezes</strong>: Si una ROM se congela, el log tendrá muy pocas líneas. Si funciona, generará miles o millones de líneas.</li>
                        <li><strong>Profiling TOTAL vs etapas</strong>: El TOTAL del frame puede ser mucho mayor que la suma de las etapas individuales si hay bloqueos o esperas (pygame.event.pump(), sleep(), sincronización).</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Por qué TOTAL es ~420ms</strong>: Necesito investigar si hay bloqueo en pygame.event.pump(), sleep(), o sincronización con el core. El tiempo de las etapas individuales suma <1ms, pero TOTAL es 420ms.</li>
                        <li><strong>Pérdida de píxeles en blit</strong>: Por qué Mario y Zelda pierden casi todos los píxeles (11520→1 o 0) durante el blit. Puede ser problema de formato de superficie o blit_array.</li>
                        <li><strong>Pokémon framebuffer blanco</strong>: El problema está en el PPU/core (NonWhite=0), no en la UI. Necesito investigar por qué el PPU genera framebuffer blanco para Pokémon.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>TOTAL ~420ms</strong>: Hipótesis: hay un bloqueo o espera en pygame.event.pump() o sleep() que no se está midiendo en el profiling. El tiempo de las etapas individuales suma <1ms, pero TOTAL es 420ms, lo que sugiere que hay algo fuera del profiling que está bloqueando.
                    </p>
                    <p>
                        <strong>Pérdida de píxeles</strong>: Hipótesis: el formato de la superficie o el blit_array está causando que los píxeles se pierdan. Puede ser problema de formato RGB888 vs RGB24, o problema de stride/contiguidad.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] <strong>Step 0448</strong>: Investigar por qué TOTAL es ~420ms (posible bloqueo en pygame.event.pump() o sleep())</li>
                    <li>[ ] <strong>Step 0448</strong>: Fix de pérdida de píxeles en blit (Mario y Zelda pierden 11520→1 o 0)</li>
                    <li>[ ] <strong>Step 0448</strong>: Investigar por qué Pokémon tiene framebuffer blanco desde el core (problema PPU, no UI)</li>
                    <li>[ ] Optimizar profiling para medir también pygame.event.pump() y sleep()</li>
                    <li>[ ] Verificar formato de superficie y blit_array para evitar pérdida de píxeles</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

