<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Prueba Final: Completar la ALU (SUB, SBC) para el Checksum - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>La Prueba Final: Completar la ALU (SUB, SBC) para el Checksum</h1>
            <!-- Entrada 0188 - La Prueba Final: Completar la ALU (SUB, SBC) para el Checksum -->
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0188
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">‚úÖ VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0186__implementacion-timer-completo-tima-tma-tac.html">Anterior (0186)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El emulador ha superado todos los <code>deadlocks</code> de sincronizaci√≥n, pero la pantalla sigue en blanco porque la VRAM permanece vac√≠a. El diagn√≥stico indica que la CPU est√° fallando la verificaci√≥n del checksum del header del cartucho porque le faltan instrucciones de resta (<code>SUB</code>, <code>SBC</code>). Como resultado, el software de arranque entra en un bucle infinito deliberado, impidiendo que el juego se inicie.
                </p>
                <p>
                    Este Step completa la ALU de la CPU implementando y corrigiendo las instrucciones <code>SUB A, r</code> y <code>SBC A, r</code> (Subtract with Carry), permitiendo que la CPU calcule correctamente el checksum del cartucho y supere la secuencia de arranque. Con la ALU completa, el emulador finalmente podr√° pasar la verificaci√≥n de integridad del cartucho y ceder el control al juego principal.
                </p>
                <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem; margin: 1rem 0;">
                    <strong>üîç Diagn√≥stico Definitivo:</strong> La Paradoja de la Precisi√≥n - El Checksum Fallido. El c√≥digo de arranque realiza una verificaci√≥n de integridad del cartucho antes de ceder el control al juego. Esta verificaci√≥n calcula un checksum usando la f√≥rmula <code>x = 0; for (i = 0x0134; i <= 0x014C; i++) { x = x - rom[i] - 1; }</code>, que depende fundamentalmente de las instrucciones <code>SUB</code> y <code>SBC</code>. Si estas instrucciones no est√°n implementadas o tienen bugs, el checksum ser√° incorrecto y el sistema se bloquear√° deliberadamente.
                </div>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: El Cartridge Header Checksum y la Aritm√©tica</h2>
                <p>
                    El header de la ROM, en la direcci√≥n <code>0x014D</code>, contiene un checksum de 8 bits. El software de arranque calcula su propio checksum para validar la integridad de la ROM. La f√≥rmula es:
                </p>
                <pre><code>x = 0;
for (i = 0x0134; i <= 0x014C; i++) {
    x = x - rom[i] - 1;
}</code></pre>
                <p>
                    Esta operaci√≥n repetida de resta y decremento depende fundamentalmente de las instrucciones <code>SUB</code> (resta) y <code>SBC</code> (resta con acarreo/pr√©stamo). Si alguna de estas instrucciones falla o no est√° implementada, el checksum ser√° incorrecto y el sistema se bloquear√°.
                </p>
                <p>
                    <strong>¬øPor qu√© es cr√≠tico?</strong> El c√≥digo de arranque (ya sea el BIOS o el propio juego) realiza esta verificaci√≥n como medida de seguridad. Si el checksum calculado no coincide con el almacenado en <code>0x014D</code>, el sistema entra deliberadamente en un bucle infinito para congelar el sistema. No copia los gr√°ficos. No inicia el juego. Simplemente se detiene de forma segura.
                </p>
                <p>
                    <strong>Fuente:</strong> Pan Docs - Cartridge Header, Checksum Calculation.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                
                <h3>1. Correcci√≥n de la Implementaci√≥n de SBC</h3>
                <p>
                    Aunque las funciones <code>alu_sub</code> y <code>alu_sbc</code> ya estaban implementadas, se detect√≥ un bug sutil en el c√°lculo del flag C (Carry/Borrow) en <code>alu_sbc</code>. La implementaci√≥n original usaba <code>a_old < (value + carry)</code>, que puede causar overflow si <code>value + carry > 255</code>.
                </p>
                <p>
                    Se corrigi√≥ para usar el resultado de 16 bits de forma segura: <code>result > 0xFF</code> indica que hubo underflow (el resultado es negativo en aritm√©tica con signo de 16 bits), lo cual es la condici√≥n correcta para activar el flag C en una resta.
                </p>
                <pre><code>void CPU::alu_sbc(uint8_t value) {
    // SBC: Subtract with Carry - A = A - value - C
    uint8_t a_old = regs_->a;
    uint8_t carry = regs_->get_flag_c() ? 1 : 0;
    uint16_t result = static_cast&lt;uint16_t&gt;(a_old) - 
                      static_cast&lt;uint16_t&gt;(value) - 
                      static_cast&lt;uint16_t&gt;(carry);
    
    regs_->a = static_cast&lt;uint8_t&gt;(result);
    
    // Calcular flags
    regs_->set_flag_z(regs_->a == 0);
    regs_->set_flag_n(true);
    
    // H: half-borrow (bit 4 -> 3) incluyendo carry
    uint8_t a_low = a_old & 0x0F;
    uint8_t value_low = value & 0x0F;
    bool half_borrow = (a_low < (value_low + carry));
    regs_->set_flag_h(half_borrow);
    
    // C: borrow completo (underflow)
    // Usar el resultado de 16 bits para detectar underflow de forma segura
    regs_->set_flag_c(result > 0xFF);
}</code></pre>

                <h3>2. Verificaci√≥n de Opcodes SUB y SBC</h3>
                <p>
                    Se verific√≥ que todos los opcodes de <code>SUB</code> (0x90-0x97) y <code>SBC</code> (0x98-0x9F) est√°n correctamente implementados en el switch de la CPU:
                </p>
                <ul>
                    <li><code>0x90-0x97</code>: <code>SUB A, r</code> (donde r puede ser B, C, D, E, H, L, (HL), A)</li>
                    <li><code>0x98-0x9F</code>: <code>SBC A, r</code> (donde r puede ser B, C, D, E, H, L, (HL), A)</li>
                </ul>
                <p>
                    Todos los opcodes est√°n correctamente mapeados y llaman a las funciones helper correspondientes.
                </p>

                <h3>3. Tests Espec√≠ficos para SUB y SBC</h3>
                <p>
                    Se a√±adieron tres tests nuevos en <code>tests/test_core_cpu_alu.py</code> para validar espec√≠ficamente las instrucciones <code>SUB</code> y <code>SBC</code> con registros:
                </p>
                <ul>
                    <li><strong>test_sub_a_b:</strong> Verifica que <code>SUB B</code> calcula correctamente la resta y activa el flag Z cuando el resultado es 0.</li>
                    <li><strong>test_sbc_a_b_with_borrow:</strong> Verifica que <code>SBC A, B</code> funciona correctamente cuando el flag C (borrow) est√° activado.</li>
                    <li><strong>test_sbc_a_b_with_full_borrow:</strong> Verifica que <code>SBC A, B</code> detecta correctamente el borrow completo (underflow) y activa el flag C.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Correcci√≥n del c√°lculo del flag C en <code>alu_sbc</code></li>
                    <li><code>tests/test_core_cpu_alu.py</code> - A√±adidos 3 tests nuevos para SUB y SBC con registros</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    Se ejecutaron los tests de la ALU para validar que todas las instrucciones de resta funcionan correctamente:
                </p>
                <pre><code>$ python -m pytest tests/test_core_cpu_alu.py -v

============================= test session starts =============================
platform win32 -- Python 3.13.5, pytest-9.0.2, pluggy-1.6.0
collected 10 items

tests/test_core_cpu_alu.py::TestCoreCPUALU::test_add_immediate_basic PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_sub_immediate_zero_flag PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_add_half_carry PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_xor_a_optimization PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_inc_a PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_dec_a PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_add_full_carry PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_sub_a_b PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_sbc_a_b_with_borrow PASSED
tests/test_core_cpu_alu.py::TestCoreCPUALU::test_sbc_a_b_with_full_borrow PASSED

============================= 10 passed in 0.07s =============================</code></pre>
                <p>
                    <strong>Validaci√≥n de m√≥dulo compilado C++:</strong> Todos los tests pasan, confirmando que las instrucciones <code>SUB</code> y <code>SBC</code> est√°n correctamente implementadas y calculan los flags de forma precisa.
                </p>
                <p>
                    <strong>Test espec√≠fico de SUB:</strong>
                </p>
                <pre><code>def test_sub_a_b(self, cpu, mmu):
    """Verifica SUB B."""
    cpu.registers.a = 0x3E
    cpu.registers.b = 0x3E
    mmu.write(0x0100, 0x90) # SUB B
    cpu.registers.pc = 0x0100
    
    cpu.step()
    
    assert cpu.registers.a == 0x00
    assert cpu.registers.flag_z is True
    assert cpu.registers.flag_n is True</code></pre>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">CPU Instruction Set - SUB, SBC</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Cartridge Header - Checksum Calculation</a></li>
                    <li>GBEDG: <a href="https://gbdev.io/gb-opcodes/optables/">Opcodes Table - SUB, SBC</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>El Checksum del Cartucho:</strong> Es una medida de seguridad cr√≠tica que valida la integridad de la ROM antes de iniciar el juego. Si el checksum calculado no coincide con el almacenado, el sistema se bloquea deliberadamente.</li>
                        <li><strong>La Importancia de SUB y SBC:</strong> Estas instrucciones no son solo operaciones aritm√©ticas b√°sicas; son fundamentales para el c√°lculo del checksum. Sin ellas, el emulador no puede pasar la verificaci√≥n de integridad.</li>
                        <li><strong>El Flag C en Restas:</strong> En restas, el flag C indica "borrow" (pr√©stamo). Se activa cuando hay underflow (el resultado es negativo en aritm√©tica con signo). La forma segura de calcularlo es usando el resultado de 16 bits: <code>result > 0xFF</code>.</li>
                        <li><strong>La Secuencia de Arranque:</strong> El c√≥digo de arranque realiza m√∫ltiples verificaciones antes de ceder el control al juego. El checksum es la √∫ltima barrera de software antes de que el juego pueda iniciar.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Verificaci√≥n con ROM Real:</strong> Aunque los tests unitarios pasan, falta verificar que el emulador puede calcular correctamente el checksum de una ROM real y pasar la verificaci√≥n de arranque.</li>
                        <li><strong>Comportamiento del BIOS:</strong> Si el emulador usa un BIOS real, el checksum se calcula durante la ejecuci√≥n del BIOS. Si no usa BIOS, el juego mismo puede calcular su propio checksum.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis Principal:</strong> Con la ALU completa (SUB y SBC correctamente implementadas), el emulador deber√≠a poder calcular el checksum del cartucho correctamente y pasar la verificaci√≥n de arranque. Esto deber√≠a permitir que el juego finalmente copie los gr√°ficos a la VRAM y active el renderizado del fondo.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> Asumimos que el c√≥digo de arranque usa la f√≥rmula est√°ndar de checksum documentada en Pan Docs. Si un juego usa una f√≥rmula diferente, podr√≠a requerir investigaci√≥n adicional.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador con una ROM real (ej: <code>tetris.gb</code>) y verificar que puede calcular el checksum correctamente</li>
                    <li>[ ] Verificar que el juego pasa la verificaci√≥n de arranque y copia los gr√°ficos a la VRAM</li>
                    <li>[ ] Si la pantalla sigue en blanco, investigar otras posibles causas (ej: instrucciones faltantes, bugs en otras partes de la CPU)</li>
                    <li>[ ] Documentar el resultado final: ¬øSe ve el logo de Nintendo o hay m√°s barreras que superar?</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

