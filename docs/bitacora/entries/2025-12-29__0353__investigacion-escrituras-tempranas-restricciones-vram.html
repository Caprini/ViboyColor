<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigación de Escrituras Tempranas y Restricciones de Acceso a VRAM - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Investigación de Escrituras Tempranas y Restricciones de Acceso a VRAM</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0353
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0352__investigacion-por-que-vram-no-se-llena-con-tiles.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementó monitoreo de VRAM desde el inicio de la ejecución para investigar por qué los juegos escriben solo ceros (0x00) a VRAM durante la ejecución. Se verificó el estado inicial de VRAM cuando se carga la ROM, se investigaron restricciones de acceso a VRAM cuando LCD=ON, y se monitorearon cambios de estado del LCD. Los resultados muestran que los juegos SÍ tienen datos iniciales en VRAM (92-98% de bytes no-cero), pero todas las escrituras durante la ejecución son ceros (0% de escrituras no-cero). El LCD se apaga y se enciende durante la ejecución, pero cuando se apaga, VRAM ya tiene solo 40 bytes no-cero (0.65%), sugiriendo que los datos iniciales se borran antes de que el juego pueda cargar tiles nuevos.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Restricciones de Acceso a VRAM:</strong> En el hardware real de Game Boy, el acceso a VRAM está restringido cuando el LCD está encendido. Solo se puede acceder a VRAM durante VBLANK (cuando el LCD está en modo VBLANK, LY >= 144) o cuando el LCD está completamente apagado (LCDC bit 7 = 0). Escribir a VRAM cuando el LCD está encendido (fuera de VBLANK) puede causar problemas o ser ignorado por el hardware. Esta restricción es crítica porque la PPU está leyendo VRAM constantemente durante el renderizado, y escribir mientras se lee puede causar corrupción de datos.
                </p>
                <p>
                    <strong>Timing de LCD:</strong> Los juegos suelen apagar el LCD para cargar tiles en VRAM de forma segura. Después de cargar los tiles, los juegos encienden el LCD. El LCD se puede apagar/encender mediante el registro LCDC (bit 7). Cuando el LCD está apagado, la PPU se detiene y LY se mantiene en 0, permitiendo que el juego modifique VRAM sin restricciones. Si un juego intenta escribir tiles cuando el LCD está encendido, las escrituras pueden ser ignoradas o causar corrupción.
                </p>
                <p>
                    <strong>Carga de Tiles:</strong> Los tiles se cargan en VRAM durante la inicialización del juego o durante la ejecución cuando el LCD está apagado. Los tiles se escriben en secuencias de 16 bytes consecutivos (cada tile es 8x8 píxeles, 2 bytes por línea, 8 líneas = 16 bytes). Si un juego escribe solo 0x00 a VRAM, no se están cargando tiles reales, solo se está limpiando VRAM. Si un juego tiene datos iniciales en VRAM (desde la ROM o desde la inicialización), pero luego escribe solo ceros, los datos iniciales se están borrando.
                </p>
                <p>
                    <strong>Estado Inicial de VRAM:</strong> Algunos juegos pueden tener datos iniciales en VRAM desde la ROM o desde la inicialización del juego. Estos datos pueden ser tiles de prueba, tiles del logo de Nintendo, o tiles básicos del juego. Si estos datos se borran (escribiendo 0x00) antes de que el juego cargue tiles nuevos, VRAM quedará vacía y no se mostrará nada en pantalla.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se implementaron 4 tareas principales de diagnóstico según el plan Step 0353:
                </p>
                
                <h3>1. Monitoreo de VRAM Desde el Inicio de la Ejecución (MMU.cpp)</h3>
                <p>
                    Se agregó código en <code>MMU::write()</code> para monitorear VRAM desde el inicio de la ejecución, no solo después de activar logs. El código inicializa el monitoreo en la primera escritura a VRAM y loggea todas las escrituras no-cero (hasta 200) con información sobre el estado del LCD y el PC.
                </p>
                <pre><code>// --- Step 0353: Monitoreo Desde el Inicio ---
static int vram_write_from_start_count = 0;
static int vram_write_non_zero_from_start = 0;
static bool vram_monitoring_initialized = false;

if (!vram_monitoring_initialized) {
    vram_monitoring_initialized = true;
    printf("[MMU-VRAM-MONITOR-INIT] Monitoreo de VRAM inicializado desde el inicio\n");
}

if (addr >= 0x8000 && addr < 0x9800) {
    vram_write_from_start_count++;
    
    if (value != 0x00) {
        vram_write_non_zero_from_start++;
        
        // Loggear todas las escrituras no-cero (hasta 200)
        if (vram_write_non_zero_from_start <= 200) {
            uint16_t pc = debug_current_pc;
            bool lcd_is_on = false;
            if (ppu_ != nullptr) {
                lcd_is_on = ppu_->is_lcd_on();
            }
            
            printf("[MMU-VRAM-WRITE-FROM-START] Non-zero write #%d | Addr=0x%04X | Value=0x%02X | "
                   "PC=0x%04X | LCD=%s | Total writes=%d\n",
                   vram_write_non_zero_from_start, addr, value, pc,
                   lcd_is_on ? "ON" : "OFF", vram_write_from_start_count);
        }
    }
    
    // Loggear estadísticas cada 1000 escrituras
    if (vram_write_from_start_count % 1000 == 0) {
        printf("[MMU-VRAM-WRITE-FROM-START-STATS] Total writes=%d | Non-zero writes=%d | "
               "Non-zero ratio=%.2f%%\n",
               vram_write_from_start_count, vram_write_non_zero_from_start,
               (vram_write_non_zero_from_start * 100.0) / vram_write_from_start_count);
    }
}
// -------------------------------------------</code></pre>

                <h3>2. Verificación del Estado Inicial de VRAM (MMU.cpp)</h3>
                <p>
                    Se agregó la función <code>MMU::check_initial_vram_state()</code> que se llama desde <code>MMU::load_rom()</code> para verificar el estado inicial de VRAM cuando se carga la ROM. La función cuenta bytes no-cero y tiles completos en VRAM, y genera un log con estadísticas.
                </p>
                <pre><code>// --- Step 0353: Verificación del Estado Inicial de VRAM ---
void MMU::check_initial_vram_state() {
    int non_zero_bytes = 0;
    int complete_tiles = 0;
    
    for (uint16_t addr = 0x8000; addr < 0x9800; addr += 16) {
        int tile_non_zero = 0;
        
        for (int i = 0; i < 16; i++) {
            uint8_t byte = memory_[addr - 0x8000 + i];
            if (byte != 0x00) {
                non_zero_bytes++;
                tile_non_zero++;
            }
        }
        
        if (tile_non_zero >= 8) {
            complete_tiles++;
        }
    }
    
    printf("[MMU-VRAM-INITIAL-STATE] VRAM initial state | Non-zero bytes: %d/6144 (%.2f%%) | "
           "Complete tiles: %d/384 (%.2f%%)\n",
           non_zero_bytes, (non_zero_bytes * 100.0) / 6144,
           complete_tiles, (complete_tiles * 100.0) / 384);
    
    if (non_zero_bytes > 200) {
        printf("[MMU-VRAM-INITIAL-STATE] ✅ VRAM tiene datos iniciales (posiblemente desde ROM)\n");
    } else {
        printf("[MMU-VRAM-INITIAL-STATE] ⚠️ VRAM está vacía al inicio\n");
    }
}
// -------------------------------------------</code></pre>

                <h3>3. Verificación de Restricciones de Acceso a VRAM Cuando LCD=ON (MMU.cpp)</h3>
                <p>
                    Se agregó código en <code>MMU::write()</code> para verificar si hay restricciones de acceso a VRAM cuando LCD=ON. El código detecta escrituras no-cero a VRAM cuando el LCD está encendido y no estamos en VBLANK, y loggea estas escrituras (hasta 50) con información sobre el estado del LCD.
                </p>
                <pre><code>// --- Step 0353: Verificación de Restricciones de Acceso a VRAM ---
bool lcd_is_on = false;
bool in_vblank = false;

if (ppu_ != nullptr) {
    lcd_is_on = ppu_->is_lcd_on();
    uint8_t ly = ppu_->get_ly();
    in_vblank = (ly >= 144);
}

bool access_restricted = lcd_is_on && !in_vblank;

if (access_restricted && value != 0x00) {
    static int restricted_access_count = 0;
    restricted_access_count++;
    
    if (restricted_access_count <= 50) {
        uint16_t pc = debug_current_pc;
        
        printf("[MMU-VRAM-ACCESS-RESTRICTED] Write #%d | Addr=0x%04X | Value=0x%02X | "
               "PC=0x%04X | LCD=ON, not in VBLANK | Access should be restricted\n",
               restricted_access_count, addr, value, pc);
    }
}
// TODO: Implementar restricciones de acceso a VRAM cuando LCD=ON (excepto VBLANK)
// -------------------------------------------</code></pre>

                <h3>4. Verificación de Cambios de Estado del LCD (PPU.cpp)</h3>
                <p>
                    Se agregó código en <code>PPU::step()</code> para verificar cambios de estado del LCD durante la ejecución. El código detecta cuando el LCD se apaga o se enciende, y cuando se apaga, verifica el estado de VRAM (cuántos bytes no-cero tiene).
                </p>
                <pre><code>// --- Step 0353: Verificación de Cambios de Estado del LCD ---
static bool last_lcd_state_step0353 = false;
static int lcd_state_change_count = 0;

bool current_lcd_state = lcd_enabled;

if (current_lcd_state != last_lcd_state_step0353) {
    lcd_state_change_count++;
    
    printf("[PPU-LCD-STATE-CHANGE] Change #%d | Frame %llu | LY: %d | "
           "LCD changed from %s to %s\n",
           lcd_state_change_count,
           static_cast<unsigned long long>(frame_counter_),
           ly_,
           last_lcd_state_step0353 ? "ON" : "OFF",
           current_lcd_state ? "ON" : "OFF");
    
    // Si el LCD se apaga, verificar el estado de VRAM
    if (!current_lcd_state) {
        int non_zero_bytes = 0;
        for (uint16_t addr = 0x8000; addr < 0x9800; addr++) {
            uint8_t byte = mmu_->read(addr);
            if (byte != 0x00) {
                non_zero_bytes++;
            }
        }
        
        printf("[PPU-LCD-STATE-CHANGE] LCD OFF | VRAM non-zero bytes: %d/6144 (%.2f%%)\n",
               non_zero_bytes, (non_zero_bytes * 100.0) / 6144);
    }
    
    last_lcd_state_step0353 = current_lcd_state;
}
// -------------------------------------------</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/MMU.cpp</code> - Agregado monitoreo desde el inicio, verificación de estado inicial de VRAM, y verificación de restricciones de acceso</li>
                    <li><code>src/core/cpp/MMU.hpp</code> - Agregada declaración de <code>check_initial_vram_state()</code></li>
                    <li><code>src/core/cpp/PPU.cpp</code> - Agregada verificación de cambios de estado del LCD</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se ejecutaron pruebas con las 5 ROMs en paralelo (~2.5 minutos total) para analizar el comportamiento de VRAM:
                </p>
                <ul>
                    <li><strong>ROMs probadas:</strong> pkmn.gb, tetris.gb, mario.gbc, pkmn-amarillo.gb, Oro.gbc</li>
                    <li><strong>Comando ejecutado:</strong> <code>timeout 150 python3 main.py roms/&lt;rom&gt;.gb 2>&1 | tee logs/test_&lt;rom&gt;_step0353.log</code></li>
                    <li><strong>Análisis de logs:</strong> Se usaron comandos <code>grep</code> y <code>head</code> para extraer información específica sin saturar el contexto</li>
                </ul>
                
                <h3>Resultados Clave</h3>
                <ul>
                    <li><strong>Monitoreo desde el inicio:</strong> ✅ Inicializado correctamente en todas las ROMs</li>
                    <li><strong>Escrituras no-cero:</strong> ❌ 0 escrituras no-cero en todas las ROMs (0% de escrituras no-cero)</li>
                    <li><strong>Estado inicial de VRAM:</strong> ✅ Los juegos SÍ tienen datos iniciales (92-98% de bytes no-cero)</li>
                    <li><strong>Restricciones de acceso:</strong> ⚠️ No se detectaron accesos restringidos (no hay escrituras no-cero cuando LCD=ON)</li>
                    <li><strong>Cambios de estado del LCD:</strong> ✅ El LCD se apaga y se enciende, pero cuando se apaga, VRAM tiene solo 40 bytes no-cero (0.65%)</li>
                </ul>
                
                <h3>Ejemplo de Logs</h3>
                <pre><code>[MMU-VRAM-MONITOR-INIT] Monitoreo de VRAM inicializado desde el inicio
[MMU-VRAM-INITIAL-STATE] VRAM initial state | Non-zero bytes: 5867/6144 (95.49%) | Complete tiles: 374/384 (97.40%)
[MMU-VRAM-INITIAL-STATE] ✅ VRAM tiene datos iniciales (posiblemente desde ROM)
[MMU-VRAM-WRITE-FROM-START-STATS] Total writes=1000 | Non-zero writes=0 | Non-zero ratio=0.00%
[PPU-LCD-STATE-CHANGE] Change #1 | Frame 0 | LY: 0 | LCD changed from OFF to ON
[PPU-LCD-STATE-CHANGE] Change #2 | Frame 1 | LY: 148 | LCD changed from ON to OFF
[PPU-LCD-STATE-CHANGE] LCD OFF | VRAM non-zero bytes: 40/6144 (0.65%)</code></pre>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">LCD Timing, VRAM Access Restrictions</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">LCD Control Register (LCDC)</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">VRAM (Video RAM)</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Restricciones de acceso a VRAM:</strong> En hardware real, el acceso a VRAM está restringido cuando el LCD está encendido (excepto durante VBLANK). Esto previene corrupción de datos cuando la PPU está leyendo VRAM durante el renderizado.</li>
                        <li><strong>Estado inicial de VRAM:</strong> Los juegos pueden tener datos iniciales en VRAM desde la ROM o desde la inicialización. Estos datos pueden ser tiles de prueba, tiles del logo, o tiles básicos del juego.</li>
                        <li><strong>Problema identificado:</strong> Los juegos tienen datos iniciales en VRAM (92-98% de bytes no-cero), pero todas las escrituras durante la ejecución son ceros (0% de escrituras no-cero). Esto sugiere que los datos iniciales se están borrando antes de que el juego pueda cargar tiles nuevos.</li>
                        <li><strong>Timing del LCD:</strong> El LCD se apaga y se enciende durante la ejecución, pero cuando se apaga, VRAM ya tiene solo 40 bytes no-cero (0.65%), sugiriendo que los datos iniciales se borraron antes de que el LCD se apagara.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>¿Por qué se borran los datos iniciales?</strong> Necesitamos investigar si hay escrituras de ceros que borran los datos iniciales antes de que el juego pueda cargar tiles nuevos.</li>
                        <li><strong>¿Cuándo se borran los datos iniciales?</strong> Necesitamos verificar si las escrituras de ceros ocurren durante la inicialización o durante la ejecución.</li>
                        <li><strong>¿Los juegos esperan que VRAM esté vacía?</strong> Algunos juegos pueden esperar que VRAM esté vacía al inicio y cargar tiles desde cero. Necesitamos verificar si los juegos intentan cargar tiles pero fallan por alguna razón.</li>
                        <li><strong>¿Hay restricciones de acceso implementadas?</strong> Actualmente no implementamos restricciones de acceso a VRAM cuando LCD=ON. Necesitamos verificar si esto es necesario o si el problema es otro.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis principal:</strong> Los datos iniciales en VRAM se están borrando (escribiendo 0x00) antes de que el juego pueda cargar tiles nuevos. Esto podría ocurrir durante la inicialización del juego o durante la ejecución cuando el LCD está encendido. Si los juegos intentan cargar tiles cuando el LCD está apagado, pero los datos iniciales ya se borraron, VRAM quedará vacía y no se mostrará nada en pantalla.
                    </p>
                    <p>
                        <strong>Suposición:</strong> Los juegos pueden estar escribiendo ceros a VRAM durante la inicialización para limpiar VRAM antes de cargar tiles nuevos. Si esto ocurre antes de que empecemos a monitorear, no lo detectaríamos. Sin embargo, el monitoreo desde el inicio debería capturar estas escrituras.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] <strong>Step 0354:</strong> Investigar por qué se borran los datos iniciales de VRAM. Verificar si hay escrituras de ceros que ocurren antes de que el juego pueda cargar tiles nuevos.</li>
                    <li>[ ] <strong>Step 0355:</strong> Implementar restricciones de acceso a VRAM cuando LCD=ON (excepto VBLANK) si es necesario.</li>
                    <li>[ ] <strong>Step 0356:</strong> Verificar si los juegos intentan cargar tiles pero fallan por alguna razón. Investigar si hay problemas con el timing o con el acceso a VRAM.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

