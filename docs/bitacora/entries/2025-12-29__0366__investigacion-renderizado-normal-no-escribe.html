<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigación de Por Qué el Renderizado Normal No Escribe Datos - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Investigación de Por Qué el Renderizado Normal No Escribe Datos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0366
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0365__investigacion-pantallas-blancas-post-doble-buffering.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se investigó por qué el código de renderizado normal en <code>render_scanline()</code> no estaba escribiendo datos al <code>framebuffer_back_</code>, 
                    a pesar de que el doble buffering funcionaba correctamente. Se implementaron logs de diagnóstico detallados en todas las etapas del pipeline 
                    de renderizado (ejecución de función, condiciones, código inline, escritura al framebuffer). Los logs revelaron que el problema era una verificación 
                    incorrecta de modo: <code>render_scanline()</code> se llama en H-Blank (MODE_0) después de que MODE_3 (Pixel Transfer) completa, pero el código 
                    verificaba <code>mode_ == MODE_3_PIXEL_TRANSFER</code> y retornaba temprano. Al corregir esta verificación, el código de renderizado ahora se ejecuta 
                    correctamente y escribe datos al framebuffer (80/160 píxeles no-blancos por línea).
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <h3>Timing del Renderizado en la Game Boy</h3>
                <p>
                    En la Game Boy, el renderizado de cada línea de escaneo sigue un ciclo estricto de modos PPU:
                </p>
                <ol>
                    <li><strong>MODE_2 (OAM Search):</strong> 80 T-Cycles - La PPU busca sprites en OAM que se solapan con la línea actual</li>
                    <li><strong>MODE_3 (Pixel Transfer):</strong> 172-289 T-Cycles - La PPU renderiza la línea leyendo tiles de VRAM y escribiendo píxeles al framebuffer interno</li>
                    <li><strong>MODE_0 (H-Blank):</strong> 87-204 T-Cycles - Período de espera horizontal antes de la siguiente línea</li>
                </ol>
                <p>
                    <strong>Crítico:</strong> El renderizado ocurre <em>durante</em> MODE_3, pero en la implementación del emulador, la función <code>render_scanline()</code> 
                    se llama <em>después</em> de que MODE_3 completa, cuando la PPU entra en H-Blank (MODE_0). Esto es correcto porque:
                </p>
                <ul>
                    <li>El hardware renderiza durante MODE_3, pero el emulador puede renderizar en H-Blank sin afectar la sincronización</li>
                    <li>En H-Blank, la PPU no está accediendo a VRAM, por lo que es seguro leer tiles y escribir al framebuffer</li>
                    <li>La función <code>render_scanline()</code> renderiza la línea que acaba de completarse, no la línea actual</li>
                </ul>
                <h3>Verificación Incorrecta de Modo</h3>
                <p>
                    El código original verificaba <code>mode_ == MODE_3_PIXEL_TRANSFER</code> al inicio de <code>render_scanline()</code>, pero cuando la función se llama, 
                    el modo ya cambió a MODE_0 (H-Blank). Esta verificación causaba que la función retornara temprano sin ejecutar el código de renderizado, 
                    resultando en líneas completamente vacías en el framebuffer.
                </p>
                <p>
                    <strong>Solución:</strong> Eliminar la verificación de modo, ya que <code>render_scanline()</code> solo se llama cuando <code>ly_ < VISIBLE_LINES</code>, 
                    lo que garantiza que estamos en una línea visible y es seguro renderizar.
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <h3>Logs de Diagnóstico Implementados</h3>
                <p>
                    Se implementaron logs de diagnóstico en todas las etapas del pipeline de renderizado para identificar exactamente dónde fallaba:
                </p>
                <ol>
                    <li><strong>Verificación de Ejecución:</strong> Logs al inicio de <code>render_scanline()</code> para verificar que se ejecuta y en qué modo</li>
                    <li><strong>Verificación de Código de Renderizado:</strong> Logs antes del bucle de renderizado para verificar que el código inline se ejecuta</li>
                    <li><strong>Verificación de Condiciones:</strong> Logs para verificar LCDC, VRAM y tilemap antes del renderizado</li>
                    <li><strong>Verificación del Bucle:</strong> Logs dentro del bucle de renderizado para verificar lectura de tilemap y cálculo de direcciones</li>
                    <li><strong>Verificación de Escritura:</strong> Logs inmediatamente después de escribir al framebuffer para verificar que los valores se escriben correctamente</li>
                    <li><strong>Verificación de Línea Completa:</strong> Logs al final de <code>render_scanline()</code> para verificar que la línea tiene datos después de renderizar</li>
                </ol>
                <h3>Corrección del Problema</h3>
                <p>
                    Se identificó que la verificación <code>mode_ == MODE_3_PIXEL_TRANSFER</code> era incorrecta porque:
                </p>
                <ul>
                    <li><code>render_scanline()</code> se llama en H-Blank (MODE_0), no en MODE_3</li>
                    <li>El renderizado ocurre durante MODE_3 en el hardware, pero el emulador puede renderizar en H-Blank</li>
                    <li>La verificación causaba que la función retornara temprano sin ejecutar el código de renderizado</li>
                </ul>
                <p>
                    <strong>Corrección aplicada:</strong> Se eliminó la verificación incorrecta de modo y se agregó un comentario explicando que <code>render_scanline()</code> 
                    se llama en H-Blank para renderizar la línea que acaba de completarse.
                </p>
                <h3>Código Modificado</h3>
                <pre><code>// ANTES (incorrecto):
if (mode_ != MODE_3_PIXEL_TRANSFER) {
    return;  // ❌ Retornaba temprano porque mode_ == MODE_0 (H-Blank)
}

// DESPUÉS (correcto):
// NOTA: render_scanline() se llama en H-Blank (MODE_0) después de que MODE_3 (Pixel Transfer)
// ya completó. Esto es correcto según el hardware: el renderizado ocurre durante MODE_3,
// pero la función se llama en H-Blank para renderizar la línea que acaba de completarse.
// No necesitamos verificar el modo porque render_scanline() solo se llama cuando ly_ < VISIBLE_LINES</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Agregados logs de diagnóstico y corregida verificación de modo en <code>render_scanline()</code></li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se ejecutaron pruebas con TETRIS para verificar que el código de renderizado se ejecuta correctamente:
                </p>
                <h3>Comando Ejecutado</h3>
                <pre><code>timeout 10 python3 main.py roms/tetris.gb > logs/test_tetris_step0366_fix.log 2>&1</code></pre>
                <h3>Resultados de los Logs</h3>
                <ul>
                    <li><strong>Ejecución de render_scanline():</strong> ✅ Se ejecuta correctamente (Condiciones OK: LY=0-143, Mode=2 H-Blank)</li>
                    <li><strong>Código de renderizado inline:</strong> ✅ Se ejecuta correctamente (PPU-RENDER-CODE muestra LCDC: 0x91, LCD: ON, BG Display: ON)</li>
                    <li><strong>Escritura al framebuffer:</strong> ✅ Los valores escritos coinciden con los leídos (PPU-WRITE-VERIFY muestra valores idénticos)</li>
                    <li><strong>Líneas completas:</strong> ✅ Cada línea tiene 80/160 píxeles no-blancos después de renderizar (PPU-LINE-COMPLETE)</li>
                </ul>
                <h3>Evidencia de Logs</h3>
                <pre><code>[PPU-RENDER-ENTRY] ✅ Condiciones OK: LY=0, Mode=2 (H-Blank), continuando...
[PPU-RENDER-CODE] Frame 1 | LY: 0 | Código de renderizado inline ejecutándose
[PPU-RENDER-CODE] LCDC: 0x91 | LCD: ON | BG Display: ON
[PPU-WRITE-VERIFY] Frame 1 | LY: 0 | X: 0 | Escribió color_idx=3 | Leído del framebuffer: 3
[PPU-LINE-COMPLETE] Frame 1 | LY: 0 | Línea renderizada | Non-zero pixels: 80/160</code></pre>
                <p>
                    <strong>Validación de módulo compilado C++:</strong> Los logs confirman que el código C++ se ejecuta correctamente y escribe datos al framebuffer.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">LCD Timing</a> - Explicación de los modos PPU y timing del renderizado</li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">PPU Modes</a> - Descripción de MODE_2, MODE_3 y MODE_0</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Timing del renderizado:</strong> El renderizado ocurre durante MODE_3 en el hardware, pero el emulador puede renderizar en H-Blank sin afectar la sincronización</li>
                        <li><strong>Llamada de render_scanline():</strong> La función se llama en H-Blank (MODE_0) después de que MODE_3 completa, para renderizar la línea que acaba de completarse</li>
                        <li><strong>Verificaciones de modo:</strong> No debemos verificar el modo actual cuando renderizamos, porque el modo ya cambió a H-Blank cuando se llama la función</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Renderizado durante MODE_3:</strong> Verificar si es posible renderizar durante MODE_3 en lugar de H-Blank para mayor precisión</li>
                        <li><strong>Acceso a VRAM durante H-Blank:</strong> Confirmar que es seguro acceder a VRAM durante H-Blank sin causar conflictos</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Suposición:</strong> Es seguro renderizar en H-Blank porque la PPU no está accediendo a VRAM durante este período. 
                        Esta suposición está respaldada por el hecho de que el renderizado funciona correctamente después de la corrección.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Verificar que el renderizado funciona correctamente con todas las ROMs de prueba</li>
                    <li>[ ] Optimizar el código de renderizado si es necesario</li>
                    <li>[ ] Preparar para la siguiente fase (Audio/APU) si el renderizado está completamente funcional</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

