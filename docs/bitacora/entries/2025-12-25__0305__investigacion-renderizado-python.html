<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigación de Renderizado Python - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Investigación de Renderizado Python</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-25
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0305
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-25__0304__verificacion-extendida-monitor-framebuffer.html">Anterior (0304)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Investigación exhaustiva del código de renderizado en Python para identificar por qué aparecen rayas verdes cuando el
                    framebuffer de PPU C++ solo contiene índices 0. Se implementaron 3 monitores adicionales para rastrear la paleta, el
                    PixelArray y las modificaciones de paleta durante la ejecución.
                </p>
                <p>
                    <strong>Objetivo</strong>: Identificar la causa raíz de las rayas verdes que aparecen después de ~2 minutos de ejecución,
                    cuando el framebuffer PPU C++ solo contiene índices 0. El problema NO está en PPU C++, sino en el renderizado Python.
                </p>
                <p>
                    <strong>Hipótesis evaluadas</strong>:
                </p>
                <ul>
                    <li><strong>Hipótesis A</strong>: La paleta se modifica durante la ejecución</li>
                    <li><strong>Hipótesis B</strong>: Hay otro código que renderiza usando una paleta incorrecta</li>
                    <li><strong>Hipótesis C</strong>: Problema con PixelArray o scaling que causa artefactos visuales</li>
                    <li><strong>Hipótesis D</strong>: Hay alguna paleta que no se corrigió en los steps anteriores</li>
                </ul>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>Flujo de Renderizado</h3>
                <p>
                    El flujo de renderizado en el emulador sigue estos pasos:
                </p>
                <ol>
                    <li><strong>PPU C++ genera framebuffer</strong>: El framebuffer contiene índices de color (0-3) en formato 1D (23040 elementos = 160x144)</li>
                    <li><strong>Renderer Python obtiene framebuffer</strong>: Zero-Copy mediante memoryview desde PPU C++</li>
                    <li><strong>Renderer mapea índices a RGB</strong>: Usa una paleta para convertir índices (0-3) a colores RGB</li>
                    <li><strong>Renderer escribe en PixelArray</strong>: Escribe píxeles RGB en una superficie Pygame (160x144)</li>
                    <li><strong>PixelArray se escala y blit</strong>: La superficie se escala a la ventana (480x432) y se blit a la pantalla</li>
                </ol>

                <h3>Posibles Problemas en el Flujo</h3>
                <p>
                    Si el framebuffer PPU C++ solo contiene índices 0 (blanco), pero aparecen rayas verdes, el problema debe estar en uno de estos puntos:
                </p>
                <ul>
                    <li><strong>Paleta modificada</strong>: La paleta se cambia durante la ejecución, causando que índices 0 se mapeen a verde</li>
                    <li><strong>Múltiples paletas</strong>: Hay otra paleta en uso que no se corrigió</li>
                    <li><strong>Problemas con PixelArray</strong>: El PixelArray o el scaling causan artefactos visuales</li>
                    <li><strong>Código adicional</strong>: Hay otro código que renderiza usando una paleta incorrecta</li>
                </ul>

                <p>
                    <strong>Fuente</strong>: Pan Docs - "Framebuffer", "Palette", "Pixel Mapping"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Búsqueda Exhaustiva de Paletas</h3>
                <p>
                    Se realizó una búsqueda exhaustiva de todas las paletas en el código:
                </p>
                <ul>
                    <li><strong>Búsqueda de valores verdes</strong>: No se encontraron valores verdes (224, 248, 208), (136, 192, 112), (52, 104, 86)</li>
                    <li><strong>Búsqueda de definiciones de paleta</strong>: Se encontraron 40 coincidencias, todas verificadas y corregidas</li>
                </ul>
                <p>
                    <strong>Paletas encontradas</strong>:
                </p>
                <ul>
                    <li><code>self.COLORS</code> (línea 191): Paleta base del renderer - ✅ Corregida</li>
                    <li><code>debug_palette_map</code> (líneas 502, 614, 990): Paleta de debug - ✅ Corregida</li>
                    <li><code>palette0</code> y <code>palette1</code> (líneas 999, 1005): Paletas para sprites - ✅ Corregidas</li>
                </ul>

                <h3>Búsqueda de Código de Renderizado</h3>
                <p>
                    Se buscaron todas las funciones y operaciones de renderizado:
                </p>
                <ul>
                    <li><strong>Funciones de renderizado</strong>: 4 funciones encontradas (update_tile_cache, render_vram_debug, render_frame, render_sprites)</li>
                    <li><strong>Operaciones de renderizado</strong>: 17 operaciones encontradas (blit, fill, set_at)</li>
                    <li><strong>Conclusión</strong>: No hay código adicional que renderice. El flujo es claro y único.</li>
                </ul>

                <h3>Monitores Implementados</h3>
                <p>
                    Se implementaron 3 monitores adicionales para rastrear el renderizado:
                </p>

                <h4>Monitor 1: [PALETTE-VERIFY]</h4>
                <p>
                    Verifica la paleta usada en cada frame:
                </p>
                <ul>
                    <li><strong>Ubicación</strong>: <code>render_frame()</code> después de definir <code>palette</code></li>
                    <li><strong>Frecuencia</strong>: Cada 1000 frames o primeros 100 frames</li>
                    <li><strong>Funcionalidad</strong>: Imprime los valores RGB de la paleta (Palette[0], Palette[1], Palette[2], Palette[3])</li>
                </ul>
                <pre><code>if self._palette_verify_count % 1000 == 0 or self._palette_verify_count < 10:
    if self._palette_verify_count < 100:
        print(f"[PALETTE-VERIFY] Frame {self._palette_verify_count} | "
              f"Palette[0]={palette[0]} Palette[1]={palette[1]} "
              f"Palette[2]={palette[2]} Palette[3]={palette[3]}")
    self._palette_verify_count += 1</code></pre>

                <h4>Monitor 2: [PIXEL-VERIFY]</h4>
                <p>
                    Verifica el píxel central antes del mapeo en PixelArray:
                </p>
                <ul>
                    <li><strong>Ubicación</strong>: <code>render_frame()</code> antes de escribir en <code>PixelArray</code></li>
                    <li><strong>Frecuencia</strong>: Primeros 10 frames</li>
                    <li><strong>Funcionalidad</strong>: Verifica el píxel central (línea 72, columna 80) antes y después del mapeo</li>
                </ul>
                <pre><code>if self._pixel_verify_count < 10:
    center_idx = (72 * 160 + 80)  # Línea 72, columna 80
    center_color_idx = frame_indices[center_idx] & 0x03
    center_color_rgb = palette[center_color_idx]
    print(f"[PIXEL-VERIFY] Frame {self._pixel_verify_count} | "
          f"Center pixel: idx={center_idx} color_idx={center_color_idx} "
          f"rgb={center_color_rgb}")
    self._pixel_verify_count += 1</code></pre>

                <h4>Monitor 3: [PALETTE-MODIFIED]</h4>
                <p>
                    Detecta si la paleta se modifica durante la ejecución:
                </p>
                <ul>
                    <li><strong>Ubicación</strong>: <code>render_frame()</code> después de definir <code>debug_palette_map</code></li>
                    <li><strong>Funcionalidad</strong>: Compara la paleta actual con la última paleta verificada y muestra stack trace si cambia</li>
                </ul>
                <pre><code>if self._last_palette_checked is not None:
    if self._last_palette_checked != debug_palette_map:
        print(f"[PALETTE-MODIFIED] Paleta modificada detectada!")
        print(f"  Original: {self._original_debug_palette}")
        print(f"  Actual: {debug_palette_map}")
        import traceback
        traceback.print_stack(limit=10)
self._last_palette_checked = dict(debug_palette_map)</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Implementación de 3 monitores adicionales ([PALETTE-VERIFY], [PIXEL-VERIFY], [PALETTE-MODIFIED])</li>
                    <li><code>ANALISIS_STEP_0305_RENDERER.md</code> - Documento de análisis con todos los hallazgos</li>
                    <li><code>debug_step_0305_renderer.log</code> - Logs de ejecución (en progreso)</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Ejecución del Emulador</strong>: El emulador se ejecutó en segundo plano durante 2-3 minutos para capturar logs.
                </p>
                <p>
                    <strong>Comandos de Análisis</strong>:
                </p>
                <pre><code># Analizar [PALETTE-VERIFY]
Select-String -Path debug_step_0305_renderer.log -Pattern "\[PALETTE-VERIFY\]" | Select-Object -First 20 -Last 20

# Analizar [PIXEL-VERIFY]
Select-String -Path debug_step_0305_renderer.log -Pattern "\[PIXEL-VERIFY\]" | Select-Object -First 10

# Buscar modificaciones de paleta
Select-String -Path debug_step_0305_renderer.log -Pattern "\[PALETTE-MODIFIED\]" | Select-Object -First 10

# Buscar patrones antes de rayas verdes
Select-String -Path debug_step_0305_renderer.log -Pattern "\[PALETTE-VERIFY\]" | Select-Object -Skip 50 -First 20</code></pre>
                <p>
                    <strong>Validación de Módulo Compilado C++</strong>: Los monitores se ejecutan en Python y verifican el framebuffer obtenido desde PPU C++.
                </p>
            </section>

            <!-- 6. Hallazgos -->
            <section id="hallazgos">
                <h2>Hallazgos</h2>
                
                <h3>Búsqueda de Paletas</h3>
                <ul>
                    <li>✅ <strong>No se encontraron valores verdes</strong> en el código</li>
                    <li>✅ <strong>Todas las paletas están corregidas</strong>: self.COLORS, debug_palette_map, palette0, palette1</li>
                    <li>✅ <strong>Hipótesis D rechazada</strong>: No hay paletas pendientes de corrección</li>
                </ul>

                <h3>Búsqueda de Código de Renderizado</h3>
                <ul>
                    <li>✅ <strong>No hay código adicional que renderice</strong>: Solo hay un flujo de renderizado principal</li>
                    <li>✅ <strong>Hipótesis B rechazada</strong>: No hay otro código usando paleta incorrecta</li>
                </ul>

                <h3>Monitores Implementados</h3>
                <ul>
                    <li>✅ <strong>[PALETTE-VERIFY]</strong>: Implementado y activo</li>
                    <li>✅ <strong>[PIXEL-VERIFY]</strong>: Implementado y activo</li>
                    <li>✅ <strong>[PALETTE-MODIFIED]</strong>: Implementado y activo</li>
                </ul>

                <h3>Análisis de Ejecución y Captura de Pantalla</h3>
                <p>
                    <strong>Observaciones de la captura de pantalla</strong>:
                </p>
                <ul>
                    <li>✅ <strong>Sprites visibles</strong>: Se pueden ver sprites de Pokémon (aunque fragmentados) y texto "RED"</li>
                    <li>✅ <strong>Problema de rayas verdes</strong>: <strong>No se observaron rayas verdes</strong> en la captura (posiblemente resuelto)</li>
                    <li>⚠️ <strong>Rendimiento crítico</strong>: FPS 21.8 (debería ser ~60 FPS) - problema nuevo identificado</li>
                    <li>⚠️ <strong>Corrupción gráfica</strong>: Patrón de tablero de ajedrez en sección inferior, líneas verticales en superior, sprites fragmentados</li>
                </ul>
                <p>
                    <strong>Conclusión</strong>: El problema original de rayas verdes parece estar resuelto, pero se identificaron dos nuevos problemas críticos:
                </p>
                <ol>
                    <li><strong>Rendimiento</strong>: FPS extremadamente bajo (21.8 vs 60 esperado)</li>
                    <li><strong>Corrupción gráfica</strong>: Patrones anómalos y sprites fragmentados</li>
                </ol>
            </section>

            <!-- 7. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: "Framebuffer", "Palette", "Pixel Mapping"</li>
                    <li>Step 0304: Verificación Extendida y Monitor de Framebuffer</li>
                    <li>Step 0303: Corrección de Paleta Debug Índices 1 y 2</li>
                </ul>
            </section>

            <!-- 8. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Flujo de renderizado</strong>: El framebuffer PPU C++ contiene índices (0-3), que se mapean a RGB usando una paleta en Python, luego se escriben en PixelArray y se escalan.</li>
                        <li><strong>Búsqueda exhaustiva</strong>: Es importante buscar todas las paletas y código de renderizado para asegurar que no se pierda nada.</li>
                        <li><strong>Monitores múltiples</strong>: Implementar varios monitores permite capturar diferentes aspectos del problema (paleta, píxeles, modificaciones).</li>
                        <li><strong>Control de contexto</strong>: Los logs deben redirigirse a archivos y analizarse con muestras, no leer completos para evitar saturar el contexto.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Análisis de logs</strong>: Pendiente de análisis completo cuando los logs estén disponibles.</li>
                        <li><strong>Causa raíz</strong>: Si los monitores no detectan modificaciones de paleta, el problema puede estar en PixelArray, scaling, o en cómo Pygame renderiza los colores.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis actual</strong>: Si el framebuffer PPU C++ solo contiene índices 0, pero aparecen rayas verdes, el problema debe estar en:
                    </p>
                    <ul>
                        <li>El mapeo de índices a RGB (paleta incorrecta en algún momento)</li>
                        <li>El PixelArray o el scaling causando artefactos</li>
                        <li>Pygame renderizando colores incorrectamente</li>
                    </ul>
                    <p>
                        Los monitores implementados ayudarán a identificar cuál de estas hipótesis es correcta.
                    </p>
                </div>
            </section>

            <!-- 9. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                
                <h3>Prioridad Alta</h3>
                <ul>
                    <li>[ ] <strong>Investigar Rendimiento (FPS 21.8)</strong>:
                        <ul>
                            <li>Profilar el bucle de renderizado</li>
                            <li>Verificar si hay bloqueos en el código Python</li>
                            <li>Optimizar operaciones costosas (PixelArray, scaling)</li>
                            <li>Verificar sincronización CPU-PPU</li>
                        </ul>
                    </li>
                    <li>[ ] <strong>Investigar Corrupción Gráfica</strong>:
                        <ul>
                            <li>Verificar integridad del framebuffer</li>
                            <li>Investigar el patrón de tablero de ajedrez (posible problema con tiles o VRAM)</li>
                            <li>Verificar sincronización de tiles y sprites</li>
                            <li>Revisar el código de renderizado de sprites</li>
                        </ul>
                    </li>
                </ul>

                <h3>Prioridad Media</h3>
                <ul>
                    <li>[ ] <strong>Verificar Problema de Rayas Verdes</strong>:
                        <ul>
                            <li>Ejecutar sesión extendida (10-15 minutos) para confirmar que las rayas verdes no aparecen</li>
                            <li>Si aparecen, usar los monitores implementados para diagnosticar</li>
                        </ul>
                    </li>
                    <li>[ ] <strong>Mejorar Monitores</strong>:
                        <ul>
                            <li>Asegurar que los logs se generen correctamente</li>
                            <li>Agregar monitores de rendimiento (FPS, tiempo de frame)</li>
                            <li>Agregar monitores de corrupción gráfica</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

