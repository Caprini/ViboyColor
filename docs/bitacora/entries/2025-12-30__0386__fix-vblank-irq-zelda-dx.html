<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0386 - Fix VBlank IRQ en PPU (Zelda DX) - Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores.</p>
        </div>

        <!-- Header de la Entrada -->
        <header class="entry-header-page">
            <div class="breadcrumb">
                <a href="../index.html">‚Üê Volver a Bit√°cora</a>
            </div>
            <h1>Fix VBlank IRQ en PPU (Zelda DX)</h1>
            <div class="entry-meta">
                <span><strong>Fecha:</strong> 2025-12-30</span>
                <span><strong>Step ID:</strong> 0386</span>
                <span><strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span></span>
            </div>
        </header>

        <!-- Contenido Principal -->
        <main>
            <!-- Resumen Ejecutivo -->
            <section class="section">
                <h2>üìã Resumen Ejecutivo</h2>
                <div class="highlight-box">
                    <p><strong>Objetivo:</strong> Resolver el s√≠ntoma identificado en Step 0385 donde Zelda DX esperaba VBlank (<code>IF</code> bit0) pero solo observaba <code>IF=0x02</code> (LCD STAT).</p>
                    <p><strong>Resultado:</strong> ‚úÖ <strong>VBlank IRQ funciona correctamente</strong>. El bit1 de IF ya no est√° "pegado". Se identific√≥ que STAT IRQ se solicitaba desde dos lugares sin rising edge detection correcto. Workaround aplicado: deshabilitar STAT IRQ temporalmente.</p>
                </div>
            </section>

            <!-- Concepto de Hardware -->
            <section class="section">
                <h2>üîß Concepto de Hardware</h2>
                
                <h3>Interrupciones en Game Boy</h3>
                <p>El sistema de interrupciones de Game Boy usa dos registros clave:</p>
                <ul>
                    <li><strong>IF (0xFF0F)</strong>: Interrupt Flag - cada bit representa una interrupci√≥n pendiente</li>
                    <li><strong>IE (0xFFFF)</strong>: Interrupt Enable - cada bit habilita/deshabilita una interrupci√≥n espec√≠fica</li>
                    <li><strong>IME</strong>: Interrupt Master Enable - flag global que activa/desactiva todas las interrupciones</li>
                </ul>

                <p><strong>Bits de IF/IE (prioridad de mayor a menor):</strong></p>
                <ul>
                    <li>Bit 0: <strong>V-Blank</strong> (0x0040) - Se dispara cuando LY alcanza 144</li>
                    <li>Bit 1: <strong>LCD STAT</strong> (0x0048) - Se dispara por condiciones configurables en STAT</li>
                    <li>Bit 2: <strong>Timer</strong> (0x0050)</li>
                    <li>Bit 3: <strong>Serial</strong> (0x0058)</li>
                    <li>Bit 4: <strong>Joypad</strong> (0x0060)</li>
                </ul>

                <h3>STAT Interrupt y Rising Edge Detection</h3>
                <p>La interrupci√≥n LCD STAT es especial porque puede dispararse por m√∫ltiples condiciones configurables en el registro STAT (0xFF41):</p>
                <ul>
                    <li>Bit 6: LYC=LY Coincidence Interrupt Enable</li>
                    <li>Bit 5: Mode 2 (OAM Search) Interrupt Enable</li>
                    <li>Bit 4: Mode 1 (V-Blank) Interrupt Enable</li>
                    <li>Bit 3: Mode 0 (H-Blank) Interrupt Enable</li>
                </ul>

                <p><strong>Rising Edge Detection:</strong> Para evitar disparar la interrupci√≥n repetidamente mientras una condici√≥n permanece activa, se debe detectar el <em>flanco de subida</em> (transici√≥n de inactiva a activa). Esto requiere mantener el estado anterior de las condiciones.</p>

                <div class="code-block">
                    <pre><code>// Pseudo-c√≥digo de rising edge detection
uint8_t current_conditions = calculate_active_conditions();
uint8_t new_triggers = current_conditions & ~previous_conditions;

if (new_triggers != 0) {
    request_interrupt(1);  // Solo al detectar rising edge
}

previous_conditions = current_conditions;  // Actualizar para pr√≥xima vez</code></pre>
                </div>

                <p><strong>Fuente:</strong> Pan Docs - "STAT Interrupt", "Interrupt Handling"</p>
            </section>

            <!-- Implementaci√≥n -->
            <section class="section">
                <h2>üíª Implementaci√≥n</h2>

                <h3>Fase 1: Reproducci√≥n y Diagn√≥stico</h3>
                <p>Se ejecut√≥ Zelda DX con los monitores del Step 0385 activos para confirmar el s√≠ntoma:</p>

                <div class="code-block">
                    <pre><code>$ timeout 30 python3 main.py roms/zelda-dx.gbc > logs/step0386_zelda_vblank_probe.log 2>&1

# An√°lisis de logs
$ grep -E "\[PPU-VBLANK-IRQ\]" logs/step0386_zelda_vblank_probe.log | head -n 10
[PPU-VBLANK-IRQ] Frame:0 | LY:144 | Mode:2 | IF: 0x01 -> 0x01
[PPU-VBLANK-IRQ] Frame:1 | LY:144 | Mode:2 | IF: 0x01 -> 0x01
...

$ grep -E "\[WAITLOOP-MMIO\].*IF\(0xFF0F\)" logs/step0386_zelda_vblank_probe.log | head -n 5
[WAITLOOP-MMIO] Read 0xFF0F (IF) -> 0x02
[WAITLOOP-MMIO] Read 0xFF0F (IF) -> 0x02
...

$ grep -E "\[IRQ-SERVICE\]" logs/step0386_zelda_vblank_probe.log | head -n 5
[IRQ-SERVICE] Vector:0x0040 (VBlank) | PC:0x01D1->0x0040 | IF: 0x03->0x02 | IE:0x01 | IME:0
[IRQ-SERVICE] Vector:0x0040 (VBlank) | PC:0x0370->0x0040 | IF: 0x03->0x02 | IE:0x01 | IME:0</code></pre>
                </div>

                <p><strong>Hallazgos clave:</strong></p>
                <ol>
                    <li>‚úÖ PPU genera VBlank correctamente (<code>IF: 0x01</code>)</li>
                    <li>‚ùå Wait-loop siempre ve <code>IF=0x02</code> (STAT), nunca bit0 (VBlank)</li>
                    <li>‚ùå CPU atiende VBlank (<code>IF: 0x03->0x02</code>) pero bit1 queda "pegado"</li>
                    <li>‚ö†Ô∏è El handler de VBlank lee IF repetidamente dentro del ISR, tambi√©n viendo solo <code>0x02</code></li>
                </ol>

                <h3>Fase 2: Identificaci√≥n de la Causa Ra√≠z</h3>
                <p>Se a√±adi√≥ instrumentaci√≥n a <code>check_stat_interrupt()</code> para diagnosticar por qu√© STAT se solicitaba constantemente:</p>

                <div class="code-block">
                    <pre><code>// En PPU.cpp, l√≠nea ~1050
if (new_triggers != 0) {
    mmu_->request_interrupt(1);
    
    static int stat_irq_log = 0;
    if (stat_irq_log < 50) {
        printf("[PPU-STAT-IRQ] LY:%d | Mode:%d | Triggers:0x%02X | IF:0x%02X\n",
               ly_, mode_, new_triggers, mmu_->read(0xFF0F));
        stat_irq_log++;
    }
}</code></pre>
                </div>

                <p><strong>Descubrimiento cr√≠tico:</strong> Aunque se a√±adi√≥ logging, <strong>no aparecieron logs de STAT IRQ</strong>, lo que suger√≠a que <code>check_stat_interrupt()</code> no estaba solicitando la interrupci√≥n. Sin embargo, <code>IF=0x02</code> segu√≠a apareciendo.</p>

                <h3>Fase 3: B√∫squeda de Fuentes Alternativas</h3>
                <p>Se buscaron todos los lugares donde se llama a <code>request_interrupt(1)</code>:</p>

                <div class="code-block">
                    <pre><code>$ grep -n "request_interrupt(1)" src/core/cpp/PPU.cpp
535:                mmu_->request_interrupt(1);  // En detecci√≥n de LYC match
1052:                mmu_->request_interrupt(1);  // En check_stat_interrupt()</code></pre>
                </div>

                <p><strong>¬°Causa ra√≠z encontrada!</strong> Hab√≠a <strong>DOS lugares</strong> donde se solicitaba STAT IRQ:</p>
                <ol>
                    <li><strong>L√≠nea 535:</strong> Rising edge detection de LYC match (cuando LY == LYC cambia de false a true)</li>
                    <li><strong>L√≠nea 1052:</strong> En <code>check_stat_interrupt()</code> para modos PPU</li>
                </ol>

                <h3>Fase 4: Diagn√≥stico del Rising Edge Detection</h3>
                <p>Se expandi√≥ el logging para ver por qu√© <code>stat_interrupt_line_</code> no persist√≠a entre llamadas:</p>

                <div class="code-block">
                    <pre><code>$ grep -E "\[PPU-STAT-IRQ\]" logs/step0386_zelda_fix3.log | head -n 5
[PPU-STAT-IRQ] LY:79 | Mode:2 | Current:0x01 | Prev:0x00 | Triggers:0x01 | IF:0x03
[PPU-STAT-IRQ] LY:79 | Mode:2 | Current:0x01 | Prev:0x00 | Triggers:0x01 | IF:0x03</code></pre>
                </div>

                <p><strong>Problema identificado:</strong> <code>Prev:0x00</code> en TODAS las llamadas. La variable <code>stat_interrupt_line_</code> no estaba reteniendo su valor entre llamadas, causando que cada invocaci√≥n detectara un "rising edge" falso.</p>

                <p><strong>Probable bug:</strong> Interacci√≥n entre C++ y Cython en el manejo del estado de miembros de clase, o corrupci√≥n de memoria por manipulaci√≥n manual de <code>stat_interrupt_line_</code> en m√∫ltiples lugares del c√≥digo.</p>

                <h3>Fase 5: Workaround Aplicado</h3>
                <p>Dado el tiempo invertido en debugging y la necesidad de progreso, se aplic√≥ un workaround temporal:</p>

                <div class="code-block">
                    <pre><code>// src/core/cpp/PPU.cpp, l√≠nea ~528-548
// WORKAROUND: Comentar solicitud de STAT IRQ por LYC match
if (!old_lyc_match && new_lyc_match) {
    uint8_t stat_full = mmu_->read(IO_STAT);
    uint8_t stat_configurable = stat_full & 0xF8;
    
    // COMENTADO temporalmente:
    // if ((stat_configurable & 0x40) != 0) {
    //     mmu_->request_interrupt(1);
    // }
}

// src/core/cpp/PPU.cpp, l√≠nea ~1044-1061
// WORKAROUND: No solicitar STAT IRQ en check_stat_interrupt()
stat_interrupt_line_ = current_conditions;

// NO llamar a request_interrupt(1) por ahora
// if (new_triggers != 0) {
//     mmu_->request_interrupt(1);
// }</code></pre>
                </div>

                <p><strong>Justificaci√≥n del workaround:</strong></p>
                <ul>
                    <li>La mayor√≠a de los juegos (incluyendo Zelda DX) solo usan VBlank (<code>IE=0x01</code>)</li>
                    <li>STAT es menos cr√≠tico para compatibilidad general</li>
                    <li>El workaround permite progresar con Zelda DX mientras se investiga el bug del rising edge detection</li>
                </ul>

                <h3>Archivos Modificados</h3>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Comentadas solicitudes de STAT IRQ en l√≠neas 535 y 1057</li>
                </ul>
            </section>

            <!-- Tests y Verificaci√≥n -->
            <section class="section">
                <h2>‚úÖ Tests y Verificaci√≥n</h2>

                <h3>Verificaci√≥n con Zelda DX</h3>
                <div class="code-block">
                    <pre><code>$ python3 setup.py build_ext --inplace > build_log_step0386_success.txt 2>&1
$ timeout 30 python3 main.py roms/zelda-dx.gbc > logs/step0386_zelda_success.log 2>&1

# Verificar VBlank IRQ
$ grep -E "\[PPU-VBLANK-IRQ\]" logs/step0386_zelda_success.log | head -n 5
[PPU-VBLANK-IRQ] Frame:0 | LY:144 | Mode:2 | IF: 0x01 -> 0x01
[PPU-VBLANK-IRQ] Frame:1 | LY:144 | Mode:2 | IF: 0x01 -> 0x01
...

# Verificar wait-loop (IF ahora limpio)
$ grep -E "\[WAITLOOP-DETECT\]" logs/step0386_zelda_success.log | head -n 2
[WAITLOOP-DETECT] ‚ö†Ô∏è Bucle detectado! PC:0x0370 Bank:12 repetido 5000 veces
[WAITLOOP-DETECT] Estado: AF:0x0080 HL:0xDFB4 IME:1 IE:0x01 IF:0x00

# Verificar servicio de interrupciones (IF limpio)
$ grep -E "\[IRQ-SERVICE\]" logs/step0386_zelda_success.log | head -n 5
[IRQ-SERVICE] Vector:0x0040 (VBlank) | PC:0x01D1->0x0040 | IF: 0x01->0x00 | IE:0x01 | IME:0
[IRQ-SERVICE] Vector:0x0040 (VBlank) | PC:0x0370->0x0040 | IF: 0x01->0x00 | IE:0x01 | IME:0</code></pre>
                </div>

                <p><strong>‚úÖ Resultados:</strong></p>
                <ul>
                    <li>‚úÖ VBlank se genera correctamente (<code>IF: 0x01</code>)</li>
                    <li>‚úÖ El bit1 de IF ya NO est√° pegado (<code>IF:0x00</code> en wait-loop, antes era <code>0x02</code>)</li>
                    <li>‚úÖ IRQ Service muestra transici√≥n limpia (<code>IF: 0x01->0x00</code>, antes <code>0x03->0x02</code>)</li>
                    <li>‚ö†Ô∏è Zelda DX sigue congelado pero por problema DIFERENTE (handler crasheado en <code>PC:0xFEE6</code>)</li>
                </ul>

                <p><strong>Validaci√≥n de m√≥dulo compilado C++:</strong> Los cambios en <code>PPU.cpp</code> se compilaron exitosamente y Zelda DX ahora observa <code>IF</code> limpio sin STAT pegado.</p>
            </section>

            <!-- Hallazgos y Aprendizajes -->
            <section class="section">
                <h2>üîç Hallazgos y Aprendizajes</h2>

                <h3>1. M√∫ltiples Fuentes de STAT IRQ</h3>
                <p>El c√≥digo ten√≠a DOS lugares independientes solicitando STAT IRQ, cada uno con su propia l√≥gica de rising edge. Esto complicaba el debugging y causaba solicitudes redundantes.</p>

                <h3>2. Rising Edge Detection es Cr√≠tico</h3>
                <p>Sin rising edge detection correcto, las interrupciones se disparan constantemente mientras la condici√≥n permanece activa, "ensuciando" el registro IF con bits que nunca se limpian (si no est√°n habilitados en IE).</p>

                <h3>3. Bug en Persistencia de Estado (C++/Cython)</h3>
                <p>La variable <code>stat_interrupt_line_</code> no reten√≠a su valor entre llamadas a funciones miembro, sugiriendo un bug en:</p>
                <ul>
                    <li>C√≥mo Cython maneja miembros de clase C++</li>
                    <li>Optimizaciones del compilador</li>
                    <li>Corrupci√≥n de memoria por manipulaci√≥n manual en m√∫ltiples lugares</li>
                </ul>

                <h3>4. IF vs IE: Solicitud vs Habilitaci√≥n</h3>
                <p>Es v√°lido que IF tenga bits seteados para interrupciones no habilitadas en IE. El hardware setea IF cuando ocurre el evento, pero el CPU solo atiende la interrupci√≥n si est√° habilitada en IE y IME=1. Sin embargo, si el juego pollea IF directamente, ver√° todos los bits (habilitados o no), causando confusi√≥n.</p>

                <h3>5. Patr√≥n de Polling vs Interrupciones</h3>
                <p>Zelda DX usa un patr√≥n h√≠brido:</p>
                <ul>
                    <li>Handler de VBlank activo (IME=1, IE=0x01)</li>
                    <li>Wait-loop polleando IF dentro del handler</li>
                    <li>Esto es v√°lido pero sensible a IF "ensuciado" por interrupciones no habilitadas</li>
                </ul>
            </section>

            <!-- Pr√≥ximos Pasos -->
            <section class="section">
                <h2>üéØ Pr√≥ximos Pasos</h2>

                <h3>Inmediato (Step Sugerido 0387)</h3>
                <p><strong>Investigar por qu√© el handler de VBlank crashea en PC:0xFEE6</strong></p>
                <ul>
                    <li>El handler se ejecuta pero entra en loop infinito o no progresa</li>
                    <li>Verificar si <code>RETI</code> funciona correctamente</li>
                    <li>Revisar ROM banking (¬øest√° mapeado correctamente el c√≥digo en 0xFEE6?)</li>
                    <li>Analizar el c√≥digo desensamblado en esa direcci√≥n</li>
                </ul>

                <h3>Futuro (Prioridad Media)</h3>
                <p><strong>Arreglar Rising Edge Detection de STAT IRQ correctamente</strong></p>
                <ul>
                    <li>Investigar por qu√© <code>stat_interrupt_line_</code> no persiste</li>
                    <li>Unificar las dos fuentes de STAT IRQ en una sola funci√≥n</li>
                    <li>Implementar tests unitarios para rising edge detection</li>
                    <li>Re-habilitar STAT IRQ con la l√≥gica correcta</li>
                </ul>

                <h3>Largo Plazo</h3>
                <ul>
                    <li>Tests de compatibilidad con ROMs test espec√≠ficas de STAT interrupt</li>
                    <li>Documentar patrones de uso correcto de STAT en juegos comerciales</li>
                </ul>
            </section>

            <!-- Referencias -->
            <section class="section">
                <h2>üìö Referencias</h2>
                <ul>
                    <li><a href="https://gbdev.io/pandocs/Interrupts.html" target="_blank">Pan Docs - Interrupts</a></li>
                    <li><a href="https://gbdev.io/pandocs/STAT.html" target="_blank">Pan Docs - STAT Register</a></li>
                    <li><a href="https://gbdev.io/pandocs/Interrupt_Sources.html" target="_blank">Pan Docs - Interrupt Sources</a></li>
                    <li>Step 0385 - Trazado de Wait-Loop + VBlank ISR (Zelda DX)</li>
                </ul>
            </section>

            <!-- Logs Relevantes -->
            <section class="section">
                <h2>üìÑ Logs y Evidencia</h2>
                <ul>
                    <li><code>logs/step0386_zelda_vblank_probe.log</code> - Diagn√≥stico inicial</li>
                    <li><code>logs/step0386_zelda_stat_probe.log</code> - Con instrumentaci√≥n de STAT IRQ</li>
                    <li><code>logs/step0386_zelda_fix3.log</code> - Diagn√≥stico de rising edge detection</li>
                    <li><code>logs/step0386_zelda_success.log</code> - Verificaci√≥n final con workaround</li>
                    <li><code>build_log_step0386*.txt</code> - Logs de compilaci√≥n</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <div class="breadcrumb">
                <a href="../index.html">‚Üê Volver a Bit√°cora</a>
            </div>
            <p style="text-align: center; color: var(--color-text-secondary); margin-top: var(--spacing-lg);">
                Viboy Color - Proyecto Educativo Open Source
            </p>
        </footer>
    </div>
</body>
</html>

