<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0431: Triage PPU/GPU 10 Fails + Split Clusters - Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- NavegaciÃ³n -->
        <nav class="breadcrumb">
            <a href="../index.html">â† Volver a la BitÃ¡cora</a>
        </nav>

        <!-- Header -->
        <header class="entry-header-page">
            <h1>Step 0431: Triage PPU/GPU 10 Fails + Split Clusters</h1>
            <div class="entry-meta">
                <span><strong>Fecha:</strong> 2026-01-02</span>
                <span><strong>Step ID:</strong> 0431</span>
                <span><strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span></span>
            </div>
        </header>

        <!-- Contenido Principal -->
        <main>
            <section>
                <h2>ğŸ“‹ Resumen Ejecutivo</h2>
                <p>
                    Step de <strong>anÃ¡lisis puro (0 cambios de cÃ³digo)</strong> para clasificar los 10 tests fallidos de PPU/GPU en 2 clusters aislados con estrategias de correcciÃ³n distintas. Se establece la decisiÃ³n arquitectÃ³nica de priorizar el <strong>C++ PPU como "verdad"</strong> y deprecar tests legacy de GPU Python incompatibles con el core nativo.
                </p>
                
                <div class="info-box">
                    <strong>ğŸ¯ Objetivo</strong>: Convertir "10 fallos PPU/GPU" en un plan claro separando:
                    <ul>
                        <li><strong>Cluster A</strong>: PPU C++ sprites (3 tests) â†’ Fix tÃ©cnico en <code>PPU.cpp</code></li>
                        <li><strong>Cluster B</strong>: GPU Python background/scroll (7 tests) â†’ Reescribir o marcar legacy</li>
                    </ul>
                </div>

                <h3>Resultado del Triage</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Cluster</th>
                            <th>Tests</th>
                            <th>Naturaleza del Fallo</th>
                            <th>Estrategia</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>A</strong> (C++ PPU)</td>
                            <td>3</td>
                            <td>Sprites NO se renderizan (funcionalidad incompleta)</td>
                            <td>Step 0432: Fix <code>render_sprites()</code> (X-Flip, paletas, swap)</td>
                        </tr>
                        <tr>
                            <td><strong>B</strong> (GPU Python)</td>
                            <td>7</td>
                            <td>Tests mal diseÃ±ados (mockean MMU C++ read-only)</td>
                            <td>Step 0433: Reescribir con core C++ o marcar legacy/skip</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h2>ğŸ” Concepto de Hardware: Arquitectura Dual (Core vs Legacy)</h2>
                
                <h3>Arquitectura HÃ­brida v0.0.2</h3>
                <p>
                    En la migraciÃ³n a C++/Cython, existen <strong>dos sistemas de renderizado</strong>:
                </p>
                
                <div class="code-box">
                    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CORE C++ (src/core/cpp/PPU.cpp)            â”‚
â”‚ - Renderiza BG/Window/Sprites al framebufferâ”‚
â”‚ - SincronizaciÃ³n ciclo-precisa (456/lÃ­nea) â”‚
â”‚ - Expuesto vÃ­a Cython: PyPPU               â”‚
â”‚ - âœ… Verdad para emulaciÃ³n                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ (framebuffer[23040])
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GPU PYTHON (src/gpu/renderer.py)            â”‚
â”‚ - Legacy de v0.0.1 (Python puro)           â”‚
â”‚ - Adaptador Pygame (blit, draw.rect)       â”‚
â”‚ - Tests antiguos (test_gpu_*.py)           â”‚
â”‚ - âš ï¸ Duplica lÃ³gica LCDC/scroll/paletas    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                </div>

                <h3>Problema de Dualidad</h3>
                <ul>
                    <li><strong>Cluster A (Sprites C++)</strong>: Tests correctos, <code>PPU.cpp::render_sprites()</code> incompleto.</li>
                    <li><strong>Cluster B (GPU Python)</strong>: Tests legacy incompatibles con core C++ (intentan mockear mÃ©todos Cython read-only).</li>
                </ul>

                <p>
                    <strong>DecisiÃ³n arquitectÃ³nica</strong>: Priorizar <code>PPU.cpp</code> como Ãºnica fuente de verdad. <code>renderer.py</code> debe consumir el framebuffer C++, no reimplementar reglas de hardware.
                </p>
            </section>

            <section>
                <h2>ğŸ§ª ImplementaciÃ³n: AnÃ¡lisis de Evidencia</h2>

                <h3>Cluster A: C++ PPU Sprites (3 tests)</h3>

                <h4>A1: <code>test_sprite_rendering_simple</code> âŒ</h4>
                <div class="code-box">
                    <pre><code>Assertion: "El sprite debe estar renderizado en la lÃ­nea 4"

Evidencia del log:
[PPU-FRAMEBUFFER-WRITE] Frame 1 | LY: 0 | Non-zero pixels written: 80/160
[PPU-FRAMEBUFFER-AFTER-SWAP] Frame 1 | Total non-zero pixels: 320/23040

Causa: El test avanza hasta LY=4 pero NO completa el frame,
       asÃ­ que swap_buffers() no se ejecuta automÃ¡ticamente.
       El sprite SÃ se renderiza en back buffer.

Fix: Exponer swap_buffers() vÃ­a Cython o completar frame completo.</code></pre>
                </div>

                <h4>A2: <code>test_sprite_x_flip</code> âŒ</h4>
                <div class="code-box">
                    <pre><code>Assertion: assert 0xFFFFFFFF == 0xFF000000
           (blanco != negro)

Causa: X-Flip NO estÃ¡ implementado en render_sprites().
       El sprite se dibuja sin invertir los pÃ­xeles horizontalmente.

Fix: Implementar lÃ³gica de flip (attributes & 0x20) en PPU.cpp lÃ­nea ~4280.</code></pre>
                </div>

                <h4>A3: <code>test_sprite_palette_selection</code> âŒ</h4>
                <div class="code-box">
                    <pre><code>Assertion: assert 0xFFFFFFFF == 0xFFAAAAAAA
           (blanco != gris claro con OBP1)

Causa: La paleta OBP1 (0xFF49) NO se aplica correctamente.
       render_sprites() siempre usa OBP0 (0xFF48).

Fix: Verificar (attributes & 0x10) y usar OBP1 si bit 4 estÃ¡ activo.</code></pre>
                </div>

                <h3>Cluster B: GPU Python Background/Scroll (7 tests)</h3>

                <h4>B1: <code>test_lcdc_control_tile_map_area</code> âŒ</h4>
                <div class="code-box">
                    <pre><code>Error: AttributeError: 'MMU' object attribute 'read_byte' is read-only

LÃ­nea 60: mmu.read_byte = tracked_read  # âŒ Cython no permite reasignar

Causa: El test intenta mockear un mÃ©todo C++ (MMU compilado)
       para verificar que se lee del tilemap correcto (0x9800 vs 0x9C00).

Fix: Reescribir test usando core C++ (PyMMU + PyPPU) sin mocks,
     o usar unittest.mock.patch.object() si es necesario.</code></pre>
                </div>

                <h4>B2: <code>test_scroll_x</code> âŒ</h4>
                <div class="code-box">
                    <pre><code>Assertion: "Debe llamar a pygame.draw.rect para dibujar pÃ­xeles"

Causa: El test mockea pygame.draw.rect, pero renderer.py usa
       renderizado vectorizado con NumPy (blit de surface preallocada).

Fix: Reescribir test para verificar el framebuffer del core C++
     (pÃ­xeles esperados segÃºn SCX), no llamadas internas de Pygame.</code></pre>
                </div>

                <p><strong>Resto de tests (5)</strong>: Mismo patrÃ³n (mocks incompatibles o expectativas incorrectas).</p>
            </section>

            <section>
                <h2>âœ… Tests y VerificaciÃ³n</h2>

                <h3>Comandos Ejecutados</h3>
                <div class="code-box">
                    <pre><code># Cluster A: C++ PPU Sprites
pytest -vv tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_rendering_simple --maxfail=1 -x
# EXIT: 1 (FAILED)

pytest -vv tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_x_flip --maxfail=1 -x
# EXIT: 1 (FAILED)

pytest -vv tests/test_core_ppu_sprites.py::TestCorePPUSprites::test_sprite_palette_selection --maxfail=1 -x
# EXIT: 1 (FAILED)

# Cluster B: GPU Python Background/Scroll
pytest -vv tests/test_gpu_background.py --maxfail=1 -x
# EXIT: 1 (AttributeError: 'MMU' object attribute 'read_byte' is read-only)

pytest -vv tests/test_gpu_scroll.py::TestScroll::test_scroll_x --maxfail=1 -x
# EXIT: 1 (AssertionError: Debe llamar a pygame.draw.rect)</code></pre>
                </div>

                <h3>Tabla de Mapeo: Tests â†’ MÃ³dulo Real</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Test</th>
                            <th>MÃ³dulo que deberÃ­a renderizar</th>
                            <th>Comentario</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>test_sprite_rendering_simple</code></td>
                            <td><code>PPU.cpp::render_sprites()</code></td>
                            <td>âœ… Correcto, pero sin swap automÃ¡tico</td>
                        </tr>
                        <tr>
                            <td><code>test_sprite_x_flip</code></td>
                            <td><code>PPU.cpp::render_sprites()</code></td>
                            <td>âœ… Correcto, flip no implementado</td>
                        </tr>
                        <tr>
                            <td><code>test_sprite_palette_selection</code></td>
                            <td><code>PPU.cpp::render_sprites()</code></td>
                            <td>âœ… Correcto, OBP1 no aplicado</td>
                        </tr>
                        <tr>
                            <td><code>test_lcdc_control_tile_map_area</code></td>
                            <td><code>renderer.py::render_frame()</code></td>
                            <td>âŒ Test mal diseÃ±ado (mock read-only)</td>
                        </tr>
                        <tr>
                            <td><code>test_scroll_x</code></td>
                            <td><code>renderer.py::render_frame()</code></td>
                            <td>âŒ Test mal diseÃ±ado (mock pygame)</td>
                        </tr>
                        <tr>
                            <td>Resto <code>test_gpu_*</code></td>
                            <td><code>renderer.py</code></td>
                            <td>âŒ Mismo problema</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Resultado del Triage</h3>
                <div class="code-box">
                    <pre><code>âœ… Reporte generado: STEP_0431_TRIAGE_REPORT.md
âœ… Evidencia completa capturada en /tmp/viboy_0431_*.log
âœ… DecisiÃ³n arquitectÃ³nica documentada: Priorizar C++ PPU
âœ… Plan de Steps siguientes:
   â†’ Step 0432: Fix sprites C++ (render_sprites, flip, paletas)
   â†’ Step 0433: Migrar tests GPU Python â†’ Core C++ (o marcar legacy)</code></pre>
                </div>
            </section>

            <section>
                <h2>ğŸ“ Archivos Afectados (AnÃ¡lisis)</h2>
                <ul>
                    <li><code>tests/test_core_ppu_sprites.py</code> â†’ Cluster A (3 tests)</li>
                    <li><code>tests/test_gpu_background.py</code> â†’ Cluster B (6 tests)</li>
                    <li><code>tests/test_gpu_scroll.py</code> â†’ Cluster B (1 test)</li>
                    <li><code>src/core/cpp/PPU.cpp</code> â†’ AnÃ¡lisis de <code>render_sprites()</code> (lÃ­nea 4165+)</li>
                    <li><code>src/gpu/renderer.py</code> â†’ AnÃ¡lisis de <code>render_frame()</code> (legacy)</li>
                    <li><strong>Reporte generado</strong>: <code>STEP_0431_TRIAGE_REPORT.md</code></li>
                </ul>

                <div class="warning-box">
                    <strong>âš ï¸ NOTA IMPORTANTE</strong>: Este Step NO modifica cÃ³digo. Solo anÃ¡lisis y decisiÃ³n.
                </div>
            </section>

            <section>
                <h2>ğŸ¯ DecisiÃ³n ArquitectÃ³nica (CRÃTICA)</h2>

                <h3>OpciÃ³n 1: Priorizar C++ PPU como "verdad" (ELEGIDA)</h3>
                <div class="success-box">
                    <strong>âœ… DECISIÃ“N FINAL</strong>
                    <ul>
                        <li><code>PPU.cpp</code> es la Ãºnica fuente de verdad para renderizado.</li>
                        <li><code>renderer.py</code> (GPU Python) es legacy/adaptador Pygame.</li>
                        <li>Tests futuros deben usar <code>PyPPU</code> (core C++) y leer <code>framebuffer</code>.</li>
                        <li>Tests <code>test_gpu_*</code> se reescriben o marcan como legacy/skip.</li>
                    </ul>
                </div>

                <h3>JustificaciÃ³n</h3>
                <ol>
                    <li>El core C++ ya renderiza background, window y sprites al framebuffer.</li>
                    <li>Mantener 2 motores (C++ y Python) duplica lÃ³gica LCDC/scroll/paletas â†’ bug-prone.</li>
                    <li>Tests <code>test_gpu_*</code> estÃ¡n desactualizados (intentan mockear MMU C++ read-only).</li>
                    <li>Objetivo v0.0.2: Migrar TODA la emulaciÃ³n al core C++, no mantener Python puro.</li>
                </ol>

                <h3>OpciÃ³n 2: Mantener GPU Python independiente (RECHAZADA)</h3>
                <div class="warning-box">
                    <strong>âŒ RECHAZADA</strong>: DuplicaciÃ³n de lÃ³gica, tests incompatibles con core C++, contrario al objetivo de v0.0.2.
                </div>
            </section>

            <section>
                <h2>ğŸ“ PrÃ³ximos Pasos</h2>

                <h3>Step 0432: Fix C++ PPU Sprites (Cluster A)</h3>
                <div class="code-box">
                    <pre><code>Archivos:
- src/core/cpp/PPU.cpp::render_sprites() (lÃ­neas 4165-4350)
- src/core/wrappers/ppu_wrapper.pyx (si hace falta exponer swap_buffers())
- tests/test_core_ppu_sprites.py (aÃ±adir swap antes de leer framebuffer)

Tareas:
1. Verificar que render_sprites() se ejecuta en render_scanline()
2. Implementar X-Flip/Y-Flip (attributes & 0x20, 0x40)
3. Aplicar paleta OBP0/OBP1 segÃºn (attributes & 0x10)
4. Exponer swap_buffers() vÃ­a Cython si tests lo necesitan

Entregable: 3/3 tests de sprites pasan.</code></pre>
                </div>

                <h3>Step 0433: Migrar tests GPU Python â†’ Framebuffer C++ (Cluster B)</h3>
                <div class="code-box">
                    <pre><code>Archivos:
- tests/test_gpu_background.py
- tests/test_gpu_scroll.py
- src/gpu/renderer.py (marcar como legacy si no se usa mÃ¡s)

OpciÃ³n A (Reescribir tests):
- Cambiar tests para usar PyMMU + PyPPU (core C++)
- Leer framebuffer del core directamente (sin mockear read_byte)
- Verificar pÃ­xeles esperados segÃºn LCDC/SCX/SCY

OpciÃ³n B (Marcar legacy/skip) âœ… RECOMENDADA:
- Documentar que test_gpu_* son legacy de v0.0.1
- Skip con mensaje: "Tests legacy - usar test_core_ppu_*"
- Mantener renderer.py solo para Pygame UI

Entregable: 7 tests marcados legacy o reescritos.</code></pre>
                </div>
            </section>

            <section>
                <h2>ğŸ† ConclusiÃ³n</h2>
                <p>
                    Step 0431 es un <strong>paso de anÃ¡lisis puro</strong> que divide los 10 fallos PPU/GPU en 2 problemas distintos con estrategias claras:
                </p>
                <ol>
                    <li><strong>Cluster A (3 tests)</strong>: Fix tÃ©cnico en <code>PPU.cpp::render_sprites()</code> â†’ Step 0432.</li>
                    <li><strong>Cluster B (7 tests)</strong>: Reescribir o deprecar tests legacy incompatibles con core C++ â†’ Step 0433.</li>
                </ol>
                <p>
                    <strong>DecisiÃ³n arquitectÃ³nica crÃ­tica</strong>: Priorizar C++ PPU como Ãºnica fuente de verdad, deprecando GPU Python como motor de renderizado (solo adaptador Pygame).
                </p>
                <div class="success-box">
                    <strong>âœ… VERIFICADO</strong>: Reporte completo generado en <code>STEP_0431_TRIAGE_REPORT.md</code> (5.4KB, 220 lÃ­neas).
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <nav class="breadcrumb">
                <a href="../index.html">â† Volver a la BitÃ¡cora</a>
            </nav>
        </footer>
    </div>
</body>
</html>

