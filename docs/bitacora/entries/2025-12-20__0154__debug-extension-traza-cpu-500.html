<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Extensi贸n del Trazado de CPU a 500 Instrucciones - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Extensi贸n del Trazado de CPU a 500 Instrucciones</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0154
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0153__analisis-traza-cpu-post-bucle.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El an谩lisis del Step 0153 confirm贸 que el fix del flag Z funciona correctamente, pero revel贸 que la rutina de inicializaci贸n de la ROM contiene m煤ltiples bucles de limpieza anidados. La traza actual de 200 instrucciones es insuficiente para observar qu茅 ocurre despu茅s de que todos estos bucles terminan. Se aument贸 el l铆mite de traza de la CPU de 200 a 500 instrucciones para capturar una ventana de observaci贸n mucho m谩s amplia y poder ver la secuencia de ejecuci贸n que sigue a los bucles de inicializaci贸n.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    Las ROMs de Game Boy ejecutan rutinas de inicializaci贸n complejas al arrancar. Estas rutinas no solo limpian una 煤nica 谩rea de memoria, sino que realizan m煤ltiples operaciones secuenciales:
                </p>
                <ul>
                    <li><strong>Limpieza de WRAM:</strong> Borrado de la memoria de trabajo (0xC000-0xDFFF).</li>
                    <li><strong>Limpieza de HRAM:</strong> Borrado de la memoria de alta velocidad (0xFF80-0xFFFE).</li>
                    <li><strong>Inicializaci贸n de registros de hardware:</strong> Configuraci贸n de la PPU (LCDC, BGP, etc.).</li>
                    <li><strong>Configuraci贸n de interrupciones:</strong> Establecimiento de vectores y habilitaci贸n de interrupciones.</li>
                </ul>
                <p>
                    Cada una de estas operaciones puede involucrar bucles anidados que consumen cientos de instrucciones. Para poder observar el comportamiento completo de la CPU durante la inicializaci贸n, necesitamos una traza lo suficientemente larga como para capturar no solo los bucles de limpieza, sino tambi茅n las instrucciones que siguen despu茅s de que estos terminan.
                </p>
                <p>
                    El l铆mite de traza es una herramienta de diagn贸stico que nos permite "alejar el zoom" y ver el panorama completo de la ejecuci贸n, en lugar de quedarnos atascados en los detalles de un solo bucle.
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se modific贸 la constante <code>DEBUG_INSTRUCTION_LIMIT</code> en el archivo <code>src/core/cpp/CPU.cpp</code> para aumentar el l铆mite de instrucciones trazadas de 200 a 500.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>CPU.cpp:</strong> Aumento de <code>DEBUG_INSTRUCTION_LIMIT</code> de 200 a 500.</li>
                </ul>

                <h3>Cambio realizado</h3>
                <p>
                    El cambio es simple pero efectivo: aumentar el l铆mite de traza nos permite capturar m谩s instrucciones en la salida de diagn贸stico, lo que nos ayudar谩 a identificar qu茅 ocurre despu茅s de que los bucles de inicializaci贸n terminan.
                </p>
                <pre><code>// Variables est谩ticas para logging de diagn贸stico
static int debug_instruction_counter = 0;
// Aumentamos el l铆mite para ver m谩s all谩 de los bucles de limpieza
static const int DEBUG_INSTRUCTION_LIMIT = 500;</code></pre>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Aumento de <code>DEBUG_INSTRUCTION_LIMIT</code> de 200 a 500.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    Este cambio no requiere tests unitarios espec铆ficos, ya que solo modifica el l铆mite de logging de diagn贸stico. La validaci贸n se realizar谩 mediante:
                </p>
                <ul>
                    <li><strong>Recompilaci贸n del m贸dulo C++:</strong> Ejecutar <code>.\rebuild_cpp.ps1</code> para recompilar con el nuevo l铆mite.</li>
                    <li><strong>Ejecuci贸n del emulador:</strong> Ejecutar <code>python main.py roms/tetris.gb</code> para generar la nueva traza extendida.</li>
                    <li><strong>An谩lisis de la traza:</strong> Examinar las 500 instrucciones capturadas para identificar qu茅 ocurre despu茅s de los bucles de inicializaci贸n.</li>
                </ul>
                <p>
                    <strong>Resultado esperado:</strong> La traza deber铆a mostrar las primeras 500 instrucciones ejecutadas, incluyendo los bucles de limpieza y las instrucciones que siguen despu茅s de que estos terminan. Esto nos permitir谩 identificar el siguiente opcode que debemos implementar para que el juego pueda continuar su ejecuci贸n.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>An谩lisis del Step 0153: Confirmaci贸n de m煤ltiples bucles anidados en rutinas de inicializaci贸n.</li>
                    <li>Comportamiento observado en trazas de CPU: Los juegos ejecutan secuencias complejas de inicializaci贸n.</li>
                </ul>
                <p>
                    <em>Nota: Este cambio es puramente de diagn贸stico y no requiere documentaci贸n t茅cnica espec铆fica del hardware.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Rutinas de inicializaci贸n complejas:</strong> Las ROMs ejecutan m煤ltiples bucles anidados durante la inicializaci贸n, no solo uno.</li>
                        <li><strong>Importancia del l铆mite de traza:</strong> Un l铆mite demasiado bajo puede ocultar informaci贸n cr铆tica sobre el comportamiento de la CPU.</li>
                        <li><strong>Estrategia de debugging:</strong> Aumentar el l铆mite de traza es una t茅cnica v谩lida para "alejar el zoom" y ver el panorama completo.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Contenido de la traza extendida:</strong> Necesitamos ver qu茅 instrucciones aparecen despu茅s de los bucles de inicializaci贸n.</li>
                        <li><strong>Siguiente opcode cr铆tico:</strong> Identificar qu茅 instrucci贸n falta implementar para que el juego pueda continuar.</li>
                        <li><strong>Configuraci贸n de hardware:</strong> Verificar si el juego intenta escribir en registros de I/O (LCDC, BGP, etc.) despu茅s de la inicializaci贸n.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis principal:</strong> Despu茅s de que los bucles de limpieza terminan, el juego deber铆a empezar a configurar el hardware, especialmente los registros de la PPU. Esperamos ver instrucciones como <code>LDH (n), A</code> (0xE0) escribiendo en registros como <code>0xFF40</code> (LCDC) o <code>0xFF47</code> (BGP).
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m贸dulo C++ con el nuevo l铆mite de traza.</li>
                    <li>[ ] Ejecutar el emulador con la ROM de Tetris y capturar la traza completa de 500 instrucciones.</li>
                    <li>[ ] Analizar la traza para identificar qu茅 ocurre despu茅s de los bucles de inicializaci贸n.</li>
                    <li>[ ] Identificar el primer opcode no implementado o sospechoso que aparece en la traza.</li>
                    <li>[ ] Implementar el siguiente opcode cr铆tico para desbloquear el progreso del juego.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

