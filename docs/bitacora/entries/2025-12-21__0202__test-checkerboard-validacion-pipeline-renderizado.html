<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test del Checkerboard: Validaci√≥n del Pipeline de Renderizado - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Test del Checkerboard: Validaci√≥n del Pipeline de Renderizado</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-21
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0202
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">üîß DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-21__0201__estado-inicial-framebuffer-verificacion-logo-personalizado.html">Anterior (Step 0201)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Hemos llegado a un punto cr√≠tico de diagn√≥stico. A pesar de que todos los componentes parecen funcionar (CPU, MMU, PPU), la pantalla permanece en blanco porque la VRAM es borrada por la propia ROM antes de que podamos renderizar algo. Este es un momento de "Guerra de Inicializaci√≥n" entre nuestra simulaci√≥n del BIOS y la propia ROM del juego.
                </p>
                <p>
                    Necesitamos validar de forma inequ√≠voca que nuestro pipeline de renderizado (C++ PPU ‚Üí Cython ‚Üí Python Pygame) est√° funcionando. Para ello, implementamos un "Test del Checkerboard": modificamos temporalmente <code>PPU::render_scanline()</code> para que ignore toda la l√≥gica de emulaci√≥n y dibuje un patr√≥n de tablero de ajedrez directamente en el framebuffer.
                </p>
                <p>
                    Este test nos dar√° una respuesta binaria y definitiva:
                </p>
                <ul>
                    <li><strong>Si vemos el checkerboard:</strong> La tuber√≠a de datos C++ ‚Üí Python funciona. El problema es, 100% confirmado, que la VRAM est√° vac√≠a.</li>
                    <li><strong>Si la pantalla sigue en blanco:</strong> Nuestro diagn√≥stico est√° mal. La tuber√≠a est√° rota en alg√∫n punto (el <code>memoryview</code> de Cython, el paso de punteros, etc.).</li>
                </ul>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Ingenier√≠a: Aislamiento y Prueba de la Tuber√≠a de Datos</h2>
                <p>
                    Cuando un sistema complejo falla, la mejor estrategia es el <strong>aislamiento</strong>. Vamos a aislar la "tuber√≠a" de renderizado del resto del emulador. Si podemos escribir datos en un <code>std::vector</code> en C++ y verlos en una ventana de Pygame en Python, entonces la tuber√≠a funciona. Si no, la tuber√≠a est√° rota.
                </p>
                <p>
                    El patr√≥n de tablero de ajedrez (checkerboard) es ideal porque es:
                </p>
                <ul>
                    <li><strong>Visualmente inconfundible:</strong> Es imposible de confundir con memoria corrupta o un estado de VRAM vac√≠o.</li>
                    <li><strong>F√°cil de generar matem√°ticamente:</strong> No requiere acceso a VRAM, tiles, ni a ning√∫n otro componente del emulador.</li>
                    <li><strong>Determinista:</strong> Si la tuber√≠a funciona, veremos el patr√≥n. Si no, la pantalla seguir√° en blanco.</li>
                </ul>
                <p>
                    <strong>La Guerra de Inicializaci√≥n:</strong>
                </p>
                <p>
                    El problema que enfrentamos es una obra maestra de iron√≠a t√©cnica: nuestro emulador es ahora tan preciso que est√° ejecutando fielmente el c√≥digo de la ROM de Tetris... <strong>que borra la VRAM que nosotros pre-cargamos con tanto cuidado.</strong>
                </p>
                <p>
                    <strong>La Secuencia de Eventos:</strong>
                </p>
                <ol>
                    <li><strong>Nuestro Emulador (Simulando el BIOS):</strong> Al iniciarse, el constructor de nuestra <code>MMU</code> se ejecuta. Crea el espacio de memoria de 64KB. Ejecuta nuestro c√≥digo del Step 0201: <strong>pre-carga la VRAM</strong> con los datos del logo. En este instante, la VRAM contiene los gr√°ficos.</li>
                    <li><strong>La ROM de Tetris (El Juego Toma el Control):</strong> La ejecuci√≥n comienza en <code>PC=0x0100</code>. El juego <strong>no conf√≠a en el estado de la m√°quina</strong>. No asume que la VRAM est√© limpia o preparada. Una de las primeras acciones que realiza cualquier juego bien programado es <strong>limpiar la memoria de trabajo (WRAM) y, a menudo, la memoria de v√≠deo (VRAM)</strong> para asegurarse de que no haya "basura" de un arranque anterior.</li>
                    <li><strong>El Borrado:</strong> Esto se hace con un bucle de ensamblador muy r√°pido, algo como: <code>LD HL, 0x9FFF; LD B, NUM_BYTES; loop: LD (HL-), A; DEC B; JR NZ, loop</code>. <strong>Nuestro emulador, ahora 100% funcional, ejecuta este bucle de limpieza a la perfecci√≥n.</strong> En los primeros microsegundos de ejecuci√≥n, la CPU de Tetris pasa por la VRAM y la llena de ceros, borrando nuestro logo antes de que la PPU tenga la oportunidad de dibujar un solo fotograma.</li>
                </ol>
                <p>
                    <strong>La Evidencia Inequ√≠voca:</strong>
                </p>
                <ul>
                    <li><strong>Log del Heartbeat:</strong> <code>üíì Heartbeat ... LY=0 | Mode=2 | LCDC=91</code>. Esto demuestra que la ROM de Tetris S√ç intenta encender la pantalla (<code>LCDC=91</code>) desde el primer momento. Quiere mostrar algo.</li>
                    <li><strong>Log del Renderer:</strong> <code>[Renderer] Frame #0: framebuffer le√≠do, muestra √≠ndices: [0, 0, 0, 0, 0, 0]</code>. Esto demuestra que, a pesar de que <code>LCDC</code> es <code>91</code>, la PPU lee una VRAM que ya est√° llena de ceros.</li>
                </ul>
                <p>
                    Hemos llegado a un punto de precisi√≥n tan alto que estamos emulando correctamente c√≥mo el propio juego sabotea nuestro intento de simular el BIOS. Esto no es un fracaso, es una validaci√≥n extraordinaria de la correcci√≥n de nuestra CPU y MMU.
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Modificamos temporalmente <code>PPU::render_scanline()</code> para que ignore toda la l√≥gica de emulaci√≥n y dibuje un patr√≥n de tablero de ajedrez directamente en el framebuffer.
                </p>
                
                <h3>Modificaci√≥n en PPU::render_scanline() (C++)</h3>
                <p>
                    En <code>src/core/cpp/PPU.cpp</code>, reemplazamos completamente el contenido del m√©todo <code>render_scanline()</code> con el siguiente c√≥digo de generaci√≥n de patrones:
                </p>
                <pre><code>void PPU::render_scanline() {
    // --- Step 0202: Test del Checkerboard para validar el pipeline de datos ---
    // Este c√≥digo ignora VRAM, LCDC, scroll y toda la emulaci√≥n.
    // Dibuja un patr√≥n de tablero de ajedrez directamente en el framebuffer.
    // 
    // OBJETIVO: Aislar y probar la tuber√≠a de renderizado C++ -> Cython -> Python.
    // Si vemos el checkerboard, la tuber√≠a funciona. Si la pantalla sigue en blanco,
    // el problema est√° en la interfaz Cython o en el paso de punteros.
    
    // Solo dibujar si estamos en las l√≠neas visibles
    if (ly_ >= VISIBLE_LINES) {
        return;
    }
    
    size_t line_start_index = ly_ * 160;
    
    for (int x = 0; x < 160; ++x) {
        // Generar un patr√≥n de cuadrados de 8x8 p√≠xeles
        // Alternar entre cuadrados oscuros y claros basado en la posici√≥n
        bool is_dark_square = ((ly_ / 8) % 2) == ((x / 8) % 2);
        
        // Usar √≠ndice de color 3 (oscuro) y 0 (claro)
        uint8_t color_index = is_dark_square ? 3 : 0;
        
        framebuffer_[line_start_index + x] = color_index;
    }
    
    // C√ìDIGO ORIGINAL COMENTADO (se restaurar√° despu√©s del test):
    // ... c√≥digo original de render_scanline() ...
}</code></pre>
                <p>
                    <strong>Explicaci√≥n del Algoritmo:</strong>
                </p>
                <ul>
                    <li><strong>L√≠neas visibles:</strong> Solo dibujamos si <code>ly_ &lt; VISIBLE_LINES</code> (0-143).</li>
                    <li><strong>√çndice de l√≠nea:</strong> Calculamos <code>line_start_index = ly_ * 160</code> para obtener el inicio de la l√≠nea actual en el framebuffer.</li>
                    <li><strong>Patr√≥n de tablero:</strong> Para cada p√≠xel, determinamos si est√° en un cuadrado oscuro o claro comparando la paridad de <code>ly_ / 8</code> y <code>x / 8</code>. Si ambas tienen la misma paridad, el cuadrado es oscuro (color 3). Si no, es claro (color 0).</li>
                    <li><strong>Cuadrados de 8x8:</strong> El patr√≥n genera cuadrados de 8√ó8 p√≠xeles, creando un tablero de ajedrez perfectamente visible.</li>
                </ul>
                <p>
                    <strong>‚ö†Ô∏è Importante:</strong> Este c√≥digo es temporal y debe ser revertido despu√©s del test. El c√≥digo original est√° comentado dentro del m√©todo para facilitar su restauraci√≥n.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Modificado <code>render_scanline()</code> para dibujar el patr√≥n checkerboard en lugar de leer de VRAM</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    La verificaci√≥n es puramente visual:
                </p>
                <ol>
                    <li><strong>Recompilaci√≥n:</strong> Recompilar el m√≥dulo C++ usando <code>.\rebuild_cpp.ps1</code></li>
                    <li><strong>Ejecuci√≥n:</strong> Ejecutar el emulador con la ROM de Tetris: <code>python main.py roms/tetris.gb</code></li>
                </ol>
                <p>
                    <strong>Resultado Esperado:</strong>
                </p>
                <p>
                    Al ejecutar el emulador, solo hay dos resultados posibles:
                </p>
                <ol>
                    <li><strong>Vemos un Tablero de Ajedrez Perfecto:</strong>
                        <ul>
                            <li><strong>Significado:</strong> ¬°√âxito! La tuber√≠a de datos C++ ‚Üí Cython ‚Üí Python funciona a la perfecci√≥n.</li>
                            <li><strong>Diagn√≥stico Confirmado:</strong> El problema es, sin lugar a dudas, que la VRAM est√° vac√≠a porque la ROM la est√° limpiando.</li>
                            <li><strong>Siguiente Paso:</strong> Podr√≠amos revertir este test y buscar una ROM de prueba que <em>no</em> limpie la VRAM, o avanzar directamente a la implementaci√≥n de Sprites.</li>
                        </ul>
                    </li>
                    <li><strong>La Pantalla Sigue en Blanco:</strong>
                        <ul>
                            <li><strong>Significado:</strong> ¬°Fracaso de la tuber√≠a! La PPU en C++ est√° generando el patr√≥n, pero este nunca llega a la pantalla.</li>
                            <li><strong>Diagn√≥stico:</strong> El problema est√° en nuestro wrapper de Cython, en c√≥mo exponemos el puntero del framebuffer, o c√≥mo Python lo interpreta como un <code>memoryview</code>.</li>
                            <li><strong>Siguiente Paso:</strong> Depurar la interfaz de Cython, verificando punteros, tipos de datos y el ciclo de vida del <code>memoryview</code>.</li>
                        </ul>
                    </li>
                </ol>
                <p>
                    <strong>Validaci√≥n de m√≥dulo compilado C++:</strong> Este test valida que el pipeline de renderizado funciona correctamente, independientemente del estado de la VRAM o de la l√≥gica de emulaci√≥n.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li><strong>Principio de Aislamiento en Ingenier√≠a de Software:</strong> Cuando un sistema complejo falla, la mejor estrategia es aislar componentes y probarlos individualmente.</li>
                    <li><strong>Test del Checkerboard:</strong> Patr√≥n cl√°sico en el desarrollo de motores gr√°ficos para verificar la integridad del pipeline de renderizado.</li>
                    <li><strong>Pan Docs:</strong> "LCD Timing", "VRAM" - Comportamiento del hardware de v√≠deo de la Game Boy</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Aislamiento de Componentes:</strong> Cuando un sistema complejo falla, la mejor estrategia es aislar componentes y probarlos individualmente. El test del checkerboard nos permite aislar la tuber√≠a de renderizado del resto del emulador.</li>
                        <li><strong>La Guerra de Inicializaci√≥n:</strong> Nuestro emulador es tan preciso que est√° ejecutando fielmente el c√≥digo de la ROM de Tetris, que borra la VRAM que nosotros pre-cargamos. Esto no es un fracaso, es una validaci√≥n extraordinaria de la correcci√≥n de nuestra CPU y MMU.</li>
                        <li><strong>Diagn√≥stico Binario:</strong> El test del checkerboard nos dar√° una respuesta binaria y definitiva: si vemos el patr√≥n, la tuber√≠a funciona. Si no, la tuber√≠a est√° rota.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Resultado del Test:</strong> Necesitamos ejecutar el emulador y verificar visualmente si aparece el patr√≥n checkerboard o si la pantalla sigue en blanco.</li>
                        <li><strong>Diagn√≥stico Final:</strong> Una vez que tengamos el resultado del test, podremos determinar si el problema est√° en la VRAM vac√≠a o en la tuber√≠a de renderizado.</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis Principal:</strong> La tuber√≠a de renderizado (C++ ‚Üí Cython ‚Üí Python) funciona correctamente, y el problema es que la VRAM est√° vac√≠a porque la ROM la est√° limpiando. Esta hip√≥tesis se validar√° con el test del checkerboard.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> Si vemos el checkerboard, confirmaremos que la tuber√≠a funciona y que el problema es la VRAM vac√≠a. Si la pantalla sigue en blanco, el problema est√° en la interfaz de Cython o en el paso de punteros.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y verificar visualmente si aparece el patr√≥n checkerboard</li>
                    <li>[ ] Si vemos el checkerboard: Revertir el test y buscar una ROM de prueba que no limpie la VRAM, o avanzar directamente a la implementaci√≥n de Sprites</li>
                    <li>[ ] Si la pantalla sigue en blanco: Depurar la interfaz de Cython, verificando punteros, tipos de datos y el ciclo de vida del <code>memoryview</code></li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

