<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigación y Corrección del Renderizado de Framebuffer - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Investigación y Corrección del Renderizado de Framebuffer</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0332
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-29__0331__correccion-sincronizacion-framebuffer.html">Anterior (0331)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Investigación detallada del problema de renderizado donde el framebuffer contiene datos correctos (80/160 píxeles no-blancos según logs de C++) pero la pantalla se muestra completamente blanca. Se agregaron logs de diagnóstico en tres puntos críticos del pipeline de renderizado: (1) diagnóstico del framebuffer recibido en el renderizador, (2) verificación de aplicación de paleta a píxeles específicos, y (3) verificación detallada de la copia del framebuffer en Python. Estos logs permitirán identificar exactamente dónde se pierde la información de color en el pipeline de renderizado.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>Pipeline de Renderizado: De Índices a RGB</h3>
                <p>
                    El framebuffer de la PPU contiene <strong>índices de color (0-3)</strong>, no colores RGB directos. Estos índices deben convertirse a colores RGB usando la paleta BGP (Background Palette) antes de mostrarse en pantalla.
                </p>
                <p>
                    El pipeline completo es:
                </p>
                <ol>
                    <li><strong>C++ (PPU):</strong> Escribe índices de color (0-3) en el framebuffer durante el renderizado de cada scanline</li>
                    <li><strong>Cython:</strong> Expone el framebuffer como <code>memoryview</code> para acceso desde Python</li>
                    <li><strong>Python (viboy.py):</strong> Copia el framebuffer a <code>bytearray</code> para protegerlo de cambios en C++</li>
                    <li><strong>Python (renderer.py):</strong> Convierte índices a RGB usando la paleta de debug:
                        <ul>
                            <li>Índice 0 → (255, 255, 255) - Blanco</li>
                            <li>Índice 1 → (170, 170, 170) - Gris Claro</li>
                            <li>Índice 2 → (85, 85, 85) - Gris Oscuro</li>
                            <li>Índice 3 → (8, 24, 32) - Negro</li>
                        </ul>
                    </li>
                    <li><strong>Pygame:</strong> Dibuja los píxeles RGB en la pantalla</li>
                </ol>
                
                <h3>Problema Identificado: Discrepancia entre Framebuffer y Renderizado</h3>
                <p>
                    Los logs del Step 0331 muestran que:
                </p>
                <ul>
                    <li><strong>Framebuffer (C++):</strong> 80/160 píxeles no-blancos, distribución: 0=80, 1=0, 2=0, 3=80</li>
                    <li><strong>Renderizado (Python/Pygame):</strong> Pantalla completamente blanca</li>
                </ul>
                <p>
                    Esto sugiere que el problema está en algún punto del pipeline entre C++ y Pygame. Las posibles causas son:
                </p>
                <ul>
                    <li>El framebuffer se corrompe durante la copia en Python</li>
                    <li>El renderizador no está recibiendo los datos correctos</li>
                    <li>Hay un problema con la conversión de índices a RGB</li>
                    <li>El renderizador está usando una paleta incorrecta o no la está aplicando</li>
                </ul>
                
                <p>
                    <strong>Fuente:</strong> Pan Docs - Background Palette (BGP), Pixel Rendering, Pipeline de Renderizado
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Logs de Diagnóstico Agregados</h3>
                <p>
                    Se agregaron tres sistemas de logs de diagnóstico para rastrear el framebuffer a través del pipeline:
                </p>
                
                <h4>1. Diagnóstico del Framebuffer Recibido (renderer.py)</h4>
                <p>
                    En <code>renderer.py</code>, después de recibir <code>framebuffer_data</code>, se agregan logs que:
                </p>
                <ul>
                    <li>Cuentan los índices en los primeros 100 píxeles del framebuffer</li>
                    <li>Muestran los primeros 20 índices para verificar el patrón checkerboard</li>
                    <li>Verifican que el índice 3 se convierte correctamente a negro (8, 24, 32)</li>
                </ul>
                <pre><code># --- STEP 0332: Diagnóstico de Framebuffer Recibido ---
if framebuffer_data is not None and len(framebuffer_data) > 0:
    if not hasattr(self, '_framebuffer_diagnostic_count'):
        self._framebuffer_diagnostic_count = 0
    if self._framebuffer_diagnostic_count < 5:
        self._framebuffer_diagnostic_count += 1
        
        # Contar índices en el framebuffer
        index_counts = {0: 0, 1: 0, 2: 0, 3: 0}
        for idx in range(min(100, len(framebuffer_data))):
            color_idx = framebuffer_data[idx] & 0x03
            if color_idx in index_counts:
                index_counts[color_idx] += 1
        
        logger.info(f"[Renderer-Framebuffer-Diagnostic] Frame {self._framebuffer_diagnostic_count} | "
                   f"Index counts (first 100): 0={index_counts[0]} 1={index_counts[1]} "
                   f"2={index_counts[2]} 3={index_counts[3]}")
        
        # Verificar primeros 20 píxeles
        first_20 = [framebuffer_data[i] & 0x03 for i in range(min(20, len(framebuffer_data)))]
        logger.info(f"[Renderer-Framebuffer-Diagnostic] First 20 indices: {first_20}")
        
        # Verificar que el índice 3 se convierte a negro
        if index_counts[3] > 0:
            test_index = 3
            test_color = palette[test_index]
            logger.info(f"[Renderer-Framebuffer-Diagnostic] Index 3 -> RGB: {test_color} (should be black: (8, 24, 32))")
            if test_color != (8, 24, 32):
                logger.warning(f"[Renderer-Framebuffer-Diagnostic] ⚠️ PROBLEMA: Index 3 no se convierte a negro!")
# -------------------------------------------</code></pre>
                
                <h4>2. Verificación de Aplicación de Paleta (renderer.py)</h4>
                <p>
                    Se agregaron logs que verifican que la paleta se aplica correctamente a píxeles específicos:
                </p>
                <ul>
                    <li>Esquina superior izquierda (0, 0)</li>
                    <li>Centro de pantalla (80, 72)</li>
                    <li>Esquina inferior derecha (159, 143)</li>
                </ul>
                <p>
                    Estos logs muestran el índice de color y el RGB resultante para cada píxel, permitiendo verificar que la conversión funciona correctamente.
                </p>
                <pre><code># --- STEP 0332: Verificación de Aplicación de Paleta ---
if not hasattr(self, '_palette_apply_check_count'):
    self._palette_apply_check_count = 0
if self._palette_apply_check_count < 5:
    self._palette_apply_check_count += 1
    
    test_pixels = [
        (0, 0),    # Esquina superior izquierda
        (80, 72),  # Centro de pantalla
        (159, 143) # Esquina inferior derecha
    ]
    
    for x, y in test_pixels:
        idx = y * 160 + x
        if idx < len(frame_indices):
            color_index = frame_indices[idx] & 0x03
            rgb_color = palette[color_index]
            logger.info(f"[Renderer-Palette-Apply] Pixel ({x}, {y}): index={color_index} -> RGB={rgb_color}")
            
            if color_index == 3 and rgb_color != (8, 24, 32):
                logger.warning(f"[Renderer-Palette-Apply] ⚠️ PROBLEMA: Index 3 no se convierte a negro en ({x}, {y})!")
# -------------------------------------------</code></pre>
                
                <h4>3. Verificación Detallada de Copia del Framebuffer (viboy.py)</h4>
                <p>
                    Se mejoraron los logs en <code>viboy.py</code> para verificar que la copia del framebuffer es idéntica al original:
                </p>
                <ul>
                    <li>Muestra los primeros 20 índices antes y después de copiar</li>
                    <li>Verifica que la copia es idéntica al original</li>
                    <li>Cuenta los índices en la copia para comparar con los logs de C++</li>
                </ul>
                <pre><code># --- Step 0332: Verificación Detallada de Copia del Framebuffer ---
# Verificar primeros 20 píxeles antes de copiar
first_20_before = [raw_view[i] & 0x03 for i in range(min(20, len(raw_view)))]

if not hasattr(self, '_framebuffer_copy_detailed_count'):
    self._framebuffer_copy_detailed_count = 0
if self._framebuffer_copy_detailed_count < 5:
    self._framebuffer_copy_detailed_count += 1
    logger.info(f"[Viboy-Framebuffer-Copy-Detailed] Frame {self._framebuffer_copy_detailed_count} | "
               f"First 20 indices before copy: {first_20_before}")

# Hacer copia profunda
fb_data = bytearray(raw_view)

# Verificar primeros 20 píxeles después de copiar
first_20_after = [fb_data[i] & 0x03 for i in range(min(20, len(fb_data)))]

# Verificar que la copia es idéntica
if first_20_before != first_20_after:
    logger.warning(f"[Viboy-Framebuffer-Copy-Detailed] ⚠️ DISCREPANCIA: "
                  f"Before={first_20_before}, After={first_20_after}")

# Contar índices en la copia
index_counts = {0: 0, 1: 0, 2: 0, 3: 0}
for idx in range(len(fb_data)):
    color_idx = fb_data[idx] & 0x03
    if color_idx in index_counts:
        index_counts[color_idx] += 1

logger.info(f"[Viboy-Framebuffer-Copy-Detailed] Index counts in copy: "
           f"0={index_counts[0]} 1={index_counts[1]} "
           f"2={index_counts[2]} 3={index_counts[3]}")
# -------------------------------------------</code></pre>
                
                <h3>Decisiones de Diseño</h3>
                <ul>
                    <li><strong>Límite de logs:</strong> Los logs solo se muestran en los primeros 5 frames para evitar saturación del contexto y mantener el rendimiento</li>
                    <li><strong>Verificación de píxeles específicos:</strong> Se verifican píxeles en posiciones conocidas (esquinas y centro) para tener puntos de referencia claros</li>
                    <li><strong>Comparación antes/después:</strong> Se comparan los datos antes y después de la copia para detectar corrupción durante la transferencia</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Agregados logs de diagnóstico del framebuffer recibido y verificación de aplicación de paleta</li>
                    <li><code>src/viboy.py</code> - Mejorados logs de verificación detallada de copia del framebuffer</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Los logs de diagnóstico se ejecutarán automáticamente cuando se ejecute el emulador con cualquier ROM. Para analizar los resultados:
                </p>
                <pre><code># Ejecutar pruebas con las 5 ROMs (2.5 minutos cada una)
timeout 150 python3 main.py roms/pkmn.gb 2>&1 | tee logs/test_pkmn_step0332.log
timeout 150 python3 main.py roms/tetris.gb 2>&1 | tee logs/test_tetris_step0332.log
timeout 150 python3 main.py roms/mario.gbc 2>&1 | tee logs/test_mario_step0332.log
timeout 150 python3 main.py roms/pkmn-amarillo.gb 2>&1 | tee logs/test_pkmn_amarillo_step0332.log
timeout 150 python3 main.py roms/Oro.gbc 2>&1 | tee logs/test_oro_step0332.log

# Analizar los logs (usar comandos que no saturan el contexto)
grep "\[Renderer-Framebuffer-Diagnostic\]" logs/test_*_step0332.log | head -n 15
grep "\[Renderer-Palette-Apply\]" logs/test_*_step0332.log | head -n 15
grep "\[Viboy-Framebuffer-Copy-Detailed\]" logs/test_*_step0332.log | head -n 20</code></pre>
                <p>
                    <strong>Validación esperada:</strong>
                </p>
                <ul>
                    <li>Los logs muestran qué índices recibe el renderizador del framebuffer</li>
                    <li>Los logs muestran cómo se convierten los índices a RGB</li>
                    <li>Se identifica la causa del problema (dónde se pierde la información de color)</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: Background Palette (BGP) - Conversión de índices a colores</li>
                    <li>Pan Docs: Pixel Rendering - Pipeline de renderizado</li>
                    <li>Documentación de Python: <code>bytearray</code> y <code>memoryview</code> para transferencia de datos binarios</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Pipeline de renderizado:</strong> El framebuffer contiene índices (0-3), no colores RGB. La conversión a RGB debe hacerse en el renderizador usando la paleta.</li>
                        <li><strong>Diagnóstico sistemático:</strong> Para encontrar problemas en un pipeline complejo, es necesario agregar logs en cada etapa para ver dónde se pierde la información.</li>
                        <li><strong>Verificación de copia:</strong> Cuando se copian datos entre C++ y Python, es crítico verificar que la copia es idéntica al original para detectar corrupción.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Causa del problema:</strong> Los logs de diagnóstico revelarán exactamente dónde se pierde la información de color en el pipeline</li>
                        <li><strong>Corrección:</strong> Una vez identificada la causa, se implementará la corrección en el Step 0333</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis principal:</strong> El problema está en la conversión de índices a RGB en el renderizador. Es posible que:
                    </p>
                    <ul>
                        <li>La paleta no se esté aplicando correctamente a todos los píxeles</li>
                        <li>Hay algún código que sobrescribe los colores RGB después de la conversión</li>
                        <li>El framebuffer se corrompe durante la copia (aunque los logs del Step 0331 sugieren que esto no es el caso)</li>
                    </ul>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar pruebas con las 5 ROMs y recopilar logs de diagnóstico</li>
                    <li>[ ] Analizar los logs para identificar dónde se pierde la información de color</li>
                    <li>[ ] <strong>Step 0333:</strong> Implementar corrección basada en los hallazgos de los logs</li>
                    <li>[ ] <strong>Step 0334:</strong> Verificación final de renderizado después de la corrección</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

