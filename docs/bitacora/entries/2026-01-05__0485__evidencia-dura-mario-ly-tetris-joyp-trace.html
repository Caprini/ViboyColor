<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evidencia Dura - Mario LY==0x91 Count + Tetris DX JOYP Trace Secuencial - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Evidencia Dura - Mario LY==0x91 Count + Tetris DX JOYP Trace Secuencial</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-05
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0485
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-01-05__0484__cerrar-diagnosticos-evidencia-mario-ly-loop-tetris-dx-joyp-deselect.html">Anterior (0484)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Step 0484 tenía 3 errores críticos de interpretación. Step 0485 corrige estos errores y cierra con evidencia dura:
                    <strong>Mario</strong> (count(LY==0x91) explícito en loop + correlación branch) y 
                    <strong>Tetris DX</strong> (JOYP trace secuencial + evidencia START bit bajando o nunca).
                </p>
                <p>
                    Se implementa instrumentación quirúrgica gated por variables de entorno para obtener conteos exactos
                    y trazas secuenciales que permitan cerrar definitivamente las preguntas sobre el comportamiento
                    de estos dos loops bloqueantes.
                </p>
            </section>

            <!-- 2. Corrección de Errores Step 0484 -->
            <section id="correccion-errores">
                <h2>Corrección de Errores del Step 0484</h2>
                
                <h3>1. Mario: Confusión de Valores y Salto Lógico Inválido</h3>
                <p>
                    <strong>Error:</strong> El loop dice "espera LY = 0x91", eso es 145 decimal (dentro de VBlank, porque LY va 0..153 y 144..153 es VBlank).
                    En el reporte se mezclaban 0x91 con valores como 0x5B (91 decimal). Eso NO es lo mismo.
                </p>
                <p>
                    <strong>Error peor:</strong> Usar <code>LY_DistributionTop5</code> para afirmar "no se lee 0x91" es incorrecto.
                    Que no esté en el top 5 solo significa "se lee menos que esos", no "nunca ocurre".
                </p>
                <p>
                    <strong>Corrección:</strong> Implementación de contador explícito <code>count(LY==0x91)</code> específicamente
                    cuando PC está en el rango del loop (0x128C..0x1290), y correlación con el branch.
                </p>

                <h3>2. Mario: Flags Mal Decodificados</h3>
                <p>
                    <strong>Error:</strong> En el reporte se interpretaba <code>F=0xC0</code> como "Z=0, N=1, H=1, C=0". Eso es incorrecto.
                </p>
                <p>
                    <strong>Correcto:</strong> <code>0xC0 = 1100 0000</code> → Z=1 (bit 7), N=1 (bit 6), H=0 (bit 5), C=0 (bit 4).
                    Si Z=1, entonces <code>JR NZ</code> no debería tomar. Así que o el "last_flags" no es el del branch real,
                    o se está capturando en un momento incorrecto, o el tracking está mezclando cosas.
                </p>
                <p>
                    <strong>Corrección:</strong> Tracking específico del branch en 0x1290 con captura de flags en el momento exacto
                    de la evaluación, y correlación con el valor de LY leído inmediatamente antes.
                </p>

                <h3>3. Tetris DX: Lectura JOYP y Selección Mal Entendida</h3>
                <p>
                    <strong>Error:</strong> Si escribes 0x30, "no seleccionas nada", y el nibble bajo debe leer 0xF (todo suelto).
                    Y además: un botón "pulsado" se ve como bit = 0, no 1.
                </p>
                <p>
                    <strong>Problema:</strong> Si el último read muestra select bits = 11 (deseleccionado) y low nibble = 0xF,
                    eso no prueba que el loop no sea de input; prueba que tu snapshot está viendo el read equivocado
                    (o el timing equivocado).
                </p>
                <p>
                    <strong>Corrección:</strong> Trazado secuencial de writes/reads de JOYP alrededor del hotspot y alrededor
                    del autopress, con ring-buffer de 256 eventos que capture la secuencia real de accesos.
                </p>
            </section>

            <!-- 3. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>LY (Line Y) Register (0xFF44)</h3>
                <p>
                    El registro LY indica la línea de scanline actual que la PPU está renderizando.
                    Va de 0 a 153 (154 valores totales). Los valores 144-153 corresponden al período VBlank
                    (cuando la PPU no está renderizando líneas visibles).
                </p>
                <p>
                    <strong>0x91 = 145 decimal</strong>, que está dentro del rango VBlank (144-153).
                    Si un loop espera específicamente LY==0x91, está esperando un momento específico dentro de VBlank.
                </p>
                <p>
                    Fuente: <a href="https://gbdev.io/pandocs/Video_Display.html#lcd-status-register-stat-ff41">Pan Docs - LCD Status Register</a>
                </p>

                <h3>JOYP (Joypad) Register (0xFF00)</h3>
                <p>
                    El registro JOYP (P1) tiene bits de selección (4-5) que determinan qué grupo de botones se lee:
                </p>
                <ul>
                    <li><strong>Bit 4 (P14):</strong> 0 = selecciona botones de dirección (D-Pad), 1 = no selecciona</li>
                    <li><strong>Bit 5 (P15):</strong> 0 = selecciona botones de acción (A, B, Select, Start), 1 = no selecciona</li>
                </ul>
                <p>
                    Cuando se escribe <code>0x30 = 0011 0000</code>, ambos bits están en 1, por lo que ningún grupo está seleccionado.
                    En este caso, el low nibble (bits 0-3) debe leer <code>0xF</code> (todos los bits en 1, todos sueltos).
                </p>
                <p>
                    Cuando un botón está <strong>pulsado</strong>, el bit correspondiente se lee como <strong>0</strong> (no 1).
                    Esto es importante: un botón pulsado = bit a 0.
                </p>
                <p>
                    Fuente: <a href="https://gbdev.io/pandocs/Joypad_Input.html">Pan Docs - Joypad Input</a>
                </p>
            </section>

            <!-- 4. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase 1: Mario Loop LY Watch</h3>
                <p>
                    Se implementa tracking específico para el loop de Mario (PC 0x128C..0x1290) que cuenta explícitamente
                    cuántas veces se lee LY==0x91 cuando el PC está en ese rango.
                </p>
                <ul>
                    <li><strong>MarioLoopLYWatch:</strong> Estructura que cuenta lecturas LY totales, lecturas con LY==0x91,
                        y guarda el último valor, timestamp y PC.</li>
                    <li><strong>Gated por VIBOY_DEBUG_MARIO_LOOP=1:</strong> Solo se activa cuando esta variable de entorno está configurada.</li>
                    <li><strong>Tracking en LDH A,(n):</strong> Cuando se lee 0xFF44 (LY) y el PC está en 0x128C..0x1290,
                        se actualiza el contador y se verifica si el valor es 0x91.</li>
                </ul>

                <h3>Fase 2: Branch 0x1290 Correlation</h3>
                <p>
                    Se implementa correlación específica del branch en 0x1290 (JR NZ) con el valor de LY leído
                    inmediatamente antes del branch.
                </p>
                <ul>
                    <li><strong>Branch0x1290Correlation:</strong> Estructura que cuenta evaluaciones, taken/not_taken,
                        y guarda LY y flags del momento del not-taken.</li>
                    <li><strong>Tracking en JR NZ:</strong> Cuando se ejecuta JR NZ en PC=0x1290, se captura el estado
                        y se correlaciona con el último valor de LY leído en el loop.</li>
                    <li><strong>Mini Trace Ring-Buffer:</strong> Buffer de 64 eventos que captura cada evaluación del branch
                        con frame, PC, LY, flags, taken y timestamp.</li>
                </ul>

                <h3>Fase 3: Exec Coverage para Ventana Mario</h3>
                <p>
                    Se activa exec coverage para la ventana 0x1270..0x12B0 cuando <code>VIBOY_DEBUG_MARIO_LOOP=1</code>,
                    permitiendo verificar si el código después del "not taken" realmente ejecuta el writer en 0x1288.
                </p>

                <h3>Fase 4: JOYP Access Trace</h3>
                <p>
                    Se implementa un ring-buffer de 256 eventos que captura la secuencia real de writes/reads de JOYP,
                    permitiendo ver la secuencia completa en lugar de solo un snapshot aislado.
                </p>
                <ul>
                    <li><strong>JOYPTraceEvent:</strong> Estructura que captura type (READ/WRITE), PC, valores escritos/leídos,
                        bits de selección, low nibble leído y timestamp.</li>
                    <li><strong>Gated por VIBOY_DEBUG_JOYP_TRACE=1:</strong> Solo se activa cuando esta variable está configurada.</li>
                    <li><strong>Contadores por tipo de selección:</strong> Se cuentan reads con botones seleccionados,
                        dpad seleccionado, o ninguno seleccionado.</li>
                </ul>

                <h3>Decisiones de Diseño</h3>
                <ul>
                    <li><strong>Estructuras fuera de clases:</strong> <code>LoopTraceEvent</code> y <code>JOYPTraceEvent</code>
                        se definen fuera de las clases para compatibilidad con Cython (que necesita ver la definición completa).</li>
                    <li><strong>Gating por variables de entorno:</strong> Toda la instrumentación está gated para no afectar
                        el rendimiento cuando no se necesita.</li>
                    <li><strong>Ring-buffers de tamaño fijo:</strong> Se usan buffers de tamaño fijo (64 para Mario, 256 para JOYP)
                        para evitar crecimiento ilimitado de memoria.</li>
                </ul>
            </section>

            <!-- 5. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.hpp</code> - Estructuras MarioLoopLYWatch, Branch0x1290Correlation, LoopTraceEvent y getters</li>
                    <li><code>src/core/cpp/CPU.cpp</code> - Tracking en LDH A,(n) y JR NZ, exec coverage para ventana Mario</li>
                    <li><code>src/core/cpp/MMU.hpp</code> - Estructura JOYPTraceEvent (fuera de clase) y contadores por selección</li>
                    <li><code>src/core/cpp/MMU.cpp</code> - Tracking de JOYP trace en read() y write()</li>
                    <li><code>src/core/cython/cpu.pxd</code> - Declaraciones Cython para LoopTraceEvent y getters</li>
                    <li><code>src/core/cython/cpu.pyx</code> - Implementación Python de getters y conversión de LoopTraceEvent</li>
                    <li><code>src/core/cython/mmu.pxd</code> - Declaraciones Cython para JOYPTraceEvent y getters</li>
                    <li><code>src/core/cython/mmu.pyx</code> - Implementación Python de getters y conversión de JOYPTraceEvent</li>
                    <li><code>tools/rom_smoke_0442.py</code> - Captura de métricas Step 0485 en snapshots</li>
                    <li><code>tests/test_joyp_press_with_selection_0485.py</code> - Test: JOYP press con selección activa</li>
                    <li><code>tests/test_joyp_select_bits_consistency_0485.py</code> - Test: Consistencia de select bits (0x30 → 0xF)</li>
                </ul>
            </section>

            <!-- 6. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Se crearon tests clean-room mínimos para validar la instrumentación:
                </p>
                
                <h3>Test: JOYP Press con Selección</h3>
                <pre><code>def test_joyp_press_start_with_buttons_selected():
    """Test: Seleccionar botones (P14=0), presionar START, leer y verificar bit 3 = 0"""
    mmu.write(0xFF00, 0x20)  # Seleccionar botones
    joypad.press_button(7)   # START = índice 7
    value = mmu.read(0xFF00)
    assert (value & 0x08) == 0  # Bit 3 debe ser 0 (pulsado)</code></pre>
                <p><strong>Resultado:</strong> ✅ PASSED - Verifica que el trace captura correctamente los eventos.</p>

                <h3>Test: Consistencia Select Bits</h3>
                <pre><code>def test_joyp_0x30_reads_0xF():
    """Test: Si se escribe 0x30, el low nibble debe leer 0xF"""
    mmu.write(0xFF00, 0x30)  # Ningún grupo seleccionado
    value = mmu.read(0xFF00)
    assert (value & 0x0F) == 0x0F  # Low nibble debe ser 0xF</code></pre>
                <p><strong>Resultado:</strong> ✅ PASSED - Verifica que 0x30 lee correctamente 0xF.</p>

                <h3>Compilación</h3>
                <p>
                    <strong>Comando:</strong> <code>python3 setup.py build_ext --inplace</code>
                </p>
                <p>
                    <strong>Resultado:</strong> ✅ Compilación exitosa sin errores. Todas las estructuras y getters
                    expuestos correctamente a Python a través de Cython.
                </p>
            </section>

            <!-- 7. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Video_Display.html#lcd-status-register-stat-ff41">LCD Status Register (STAT) - LY Register</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Joypad_Input.html">Joypad Input - P1 Register</a></li>
                    <li>Step 0484: Análisis de errores y correcciones necesarias</li>
                </ul>
            </section>

            <!-- 8. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>LY 0x91 = 145 decimal:</strong> Está dentro de VBlank (144-153), no es 91 decimal (0x5B).</li>
                        <li><strong>Flags decodificación:</strong> 0xC0 = Z=1, N=1, H=0, C=0. Si Z=1, JR NZ no toma.</li>
                        <li><strong>JOYP semántica:</strong> 0x30 = ningún grupo seleccionado → low nibble lee 0xF. Botón pulsado = bit a 0.</li>
                        <li><strong>Evidencia dura vs top5:</strong> Un valor que no está en top5 no significa "nunca ocurre",
                            solo significa "ocurre menos que esos 5". Necesitamos conteos explícitos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Mario:</strong> ¿Cuántas veces realmente se lee LY==0x91 en el loop? ¿Por qué no progresa si se lee?</li>
                        <li><strong>Tetris DX:</strong> ¿Hay algún read de JOYP con selección activa donde START se lee como 0 durante autopress?</li>
                        <li><strong>Branch correlation:</strong> ¿El "not taken" realmente abre camino hacia 0x1288, o hay otro bloqueo?</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis Mario:</strong> Si LY==0x91 nunca se lee en el loop, entonces el problema es timing de PPU
                        (LY nunca alcanza 0x91 cuando el loop lo lee). Si se lee pero el branch no progresa, entonces el problema
                        es la condición del branch (flags o comparación).
                    </p>
                    <p>
                        <strong>Hipótesis Tetris DX:</strong> Si nunca hay un read con selección activa donde START se lee como 0,
                        entonces el problema es que el juego no está buscando START realmente, o la inyección de autopress no está
                        funcionando correctamente.
                    </p>
                </div>
            </section>

            <!-- 9. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar rom_smoke con mario.gbc y VIBOY_DEBUG_MARIO_LOOP=1 para obtener conteos exactos</li>
                    <li>[ ] Ejecutar rom_smoke con tetris_dx.gbc y VIBOY_DEBUG_JOYP_TRACE=1 para obtener trace secuencial</li>
                    <li>[ ] Analizar reporte y generar conclusión definitiva sobre ambos loops</li>
                    <li>[ ] Step 0486: Aplicar fix mínimo basado en evidencia dura obtenida</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

