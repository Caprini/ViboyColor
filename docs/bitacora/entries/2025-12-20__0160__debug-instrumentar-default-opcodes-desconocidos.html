<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Instrumentar default para Capturar Opcodes Desconocidos - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Instrumentar default para Capturar Opcodes Desconocidos</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0160
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0159__cpu-implementar-dec-hl-bucle-infinito.html">Anterior (0159)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se instrument贸 el caso <code>default</code> del switch de opcodes en la CPU de C++ para detectar y reportar expl铆citamente qu茅 opcode no implementado est谩 causando el deadlock l贸gico. El diagn贸stico previo confirm贸 que <code>LY</code> est谩 atascado en 0 porque la CPU devuelve 0 ciclos repetidamente, indicando que est谩 ejecutando un opcode desconocido en un bucle infinito. La soluci贸n implementada a帽ade un <code>printf</code> y <code>exit(1)</code> en el caso <code>default</code> para que el emulador termine inmediatamente y muestre el opcode y PC exactos donde ocurre el problema.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En un emulador de Game Boy, cuando la CPU encuentra un opcode que no est谩 implementado, debe manejarlo de alguna forma. En nuestro caso, el caso <code>default</code> del switch retornaba 0 ciclos, lo que causaba un deadlock l贸gico:
                </p>
                <ul>
                    <li>La CPU ejecuta un opcode desconocido y devuelve 0 ciclos.</li>
                    <li>El motor de timing en Python acumula 0 ciclos, por lo que nunca alcanza el umbral de <code>CYCLES_PER_SCANLINE</code>.</li>
                    <li>Como resultado, <code>LY</code> (l铆nea de escaneo) nunca avanza, qued谩ndose atascado en 0.</li>
                    <li>El bucle principal sigue corriendo (por eso vemos el Heartbeat), pero el tiempo de emulaci贸n no avanza.</li>
                </ul>
                <p>
                    Esta t茅cnica de instrumentaci贸n es conocida como "fail-fast" o "fail-loud": en lugar de fallar silenciosamente, el programa termina inmediatamente con un mensaje claro que identifica exactamente qu茅 opcode falta. Esto es especialmente 煤til durante el desarrollo, cuando a煤n no se han implementado todos los 256 opcodes base (m谩s los 256 del prefijo CB).
                </p>
                <p>
                    <strong>Referencia:</strong> T茅cnica de depuraci贸n est谩ndar en emulaci贸n - "Opcode Trap" o "Unimplemented Instruction Handler".
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se modific贸 el archivo <code>src/core/cpp/CPU.cpp</code> para a帽adir instrumentaci贸n de depuraci贸n en el caso <code>default</code> del switch de opcodes.
                </p>
                
                <h3>Modificaciones Realizadas</h3>
                <ul>
                    <li><strong>Inclusi贸n de headers:</strong> Se a帽adi贸 <code>#include &lt;cstdlib&gt;</code> para usar <code>exit()</code>.</li>
                    <li><strong>Instrumentaci贸n del default:</strong> Se reemplaz贸 el retorno silencioso de 0 ciclos por un <code>printf</code> que muestra el opcode y PC, seguido de <code>exit(1)</code> para terminar la ejecuci贸n inmediatamente.</li>
                </ul>

                <h3>C贸digo Implementado</h3>
                <p>
                    El caso <code>default</code> ahora tiene esta estructura:
                </p>
                <pre><code>default:
    // Opcode no implementado - INSTRUMENTACIN DE DEPURACIN
    // Esta es la "bala de plata" para detectar opcodes faltantes
    // Imprimimos el opcode y PC, luego terminamos la ejecuci贸n inmediatamente
    printf("[CPU FATAL] Opcode no implementado: 0x%02X en PC: 0x%04X\n", opcode, current_pc);
    // Detenemos la emulaci贸n bruscamente para que el mensaje sea lo 煤ltimo que veamos
    exit(1);
    return 0; // No se ejecutar谩, pero es buena pr谩ctica</code></pre>

                <h3>Decisiones de Dise帽o</h3>
                <p>
                    Se eligi贸 <code>exit(1)</code> en lugar de lanzar una excepci贸n o usar logging porque:
                </p>
                <ul>
                    <li><strong>Inmediatez:</strong> Termina el programa de forma inmediata, evitando que se inunde la consola con mensajes repetidos.</li>
                    <li><strong>Claridad:</strong> El mensaje de error es lo 煤ltimo que se ve, facilitando su identificaci贸n.</li>
                    <li><strong>Simplicidad:</strong> No requiere manejo de excepciones en el c贸digo Python, simplificando el flujo de depuraci贸n.</li>
                    <li><strong>Debugging:</strong> Es una t茅cnica est谩ndar en desarrollo de emuladores para identificar r谩pidamente opcodes faltantes.</li>
                </ul>
                <p>
                    <strong>Nota:</strong> Esta instrumentaci贸n es temporal y se remover谩 o se convertir谩 en un modo de debug opcional una vez que todos los opcodes est茅n implementados.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - A帽adido <code>#include &lt;cstdlib&gt;</code> y modificado el caso <code>default</code> del switch de opcodes.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    Esta modificaci贸n no requiere tests unitarios tradicionales, ya que es una herramienta de depuraci贸n. La validaci贸n se realizar谩 ejecutando el emulador:
                </p>
                <ul>
                    <li><strong>Comando de recompilaci贸n:</strong> <code>.\rebuild_cpp.ps1</code></li>
                    <li><strong>Comando de ejecuci贸n:</strong> <code>python main.py roms/tetris.gb</code></li>
                    <li><strong>Resultado esperado:</strong> El emulador deber铆a terminar inmediatamente con un mensaje como:
                        <pre><code>[CPU FATAL] Opcode no implementado: 0xXX en PC: 0xYYYY</code></pre>
                    </li>
                </ul>
                <p>
                    Este mensaje identificar谩 exactamente qu茅 opcode falta implementar, permitiendo continuar con la depuraci贸n de forma dirigida.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>T茅cnica de depuraci贸n est谩ndar en emulaci贸n: "Opcode Trap" o "Unimplemented Instruction Handler"</li>
                    <li>Principio de "Fail-Fast" en desarrollo de software</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Deadlock l贸gico:</strong> Cuando la CPU devuelve 0 ciclos repetidamente, el tiempo de emulaci贸n no avanza, causando que <code>LY</code> se quede atascado.</li>
                        <li><strong>Instrumentaci贸n de depuraci贸n:</strong> A帽adir c贸digo espec铆fico para detectar y reportar problemas durante el desarrollo es una pr谩ctica est谩ndar.</li>
                        <li><strong>Fail-fast:</strong> Terminar inmediatamente con un mensaje claro es m谩s 煤til que fallar silenciosamente o generar logs masivos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Opcode faltante:</strong> Una vez ejecutado el emulador con esta instrumentaci贸n, sabremos exactamente qu茅 opcode no est谩 implementado y est谩 causando el deadlock.</li>
                        <li><strong>Contexto de ejecuci贸n:</strong> El PC donde ocurre el problema nos dar谩 contexto sobre en qu茅 parte del c贸digo de la ROM se est谩 ejecutando este opcode.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis principal:</strong> La CPU est谩 ejecutando un opcode no implementado en un bucle infinito, causando que devuelva 0 ciclos repetidamente. Esta instrumentaci贸n confirmar谩 o refutar谩 esta hip贸tesis de forma definitiva.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m贸dulo C++ con <code>.\rebuild_cpp.ps1</code></li>
                    <li>[ ] Ejecutar el emulador con <code>python main.py roms/tetris.gb</code></li>
                    <li>[ ] Identificar el opcode faltante del mensaje de error</li>
                    <li>[ ] Implementar el opcode faltante en la CPU de C++</li>
                    <li>[ ] Verificar que el emulador avanza m谩s all谩 del punto de bloqueo</li>
                    <li>[ ] Actualizar el estado de esta entrada a VERIFIED una vez confirmado</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

