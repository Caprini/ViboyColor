<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrección de Detección de Tiles y Renderizado - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Corrección de Detección de Tiles y Renderizado</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-29
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0325
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-28__0324__renderizado-tiles-reales-nombre-juego.html">Anterior (0324)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este step corrige la verificación de tiles reales para revisar TODO el rango de VRAM (0x8000-0x97FF) en lugar de solo los primeros 2048 bytes, investiga por qué el tilemap no apunta a los tiles reales que se cargan, y mejora la lógica de renderizado para usar tiles reales cuando están disponibles.
                </p>
                <p>
                    Se implementaron monitores adicionales para rastrear cambios en el tilemap, análisis de correspondencia entre tilemap y tiles reales, verificación del cálculo de direcciones de tiles, y mejora de la detección de tiles vacíos para verificar todo el tile (16 bytes) antes de considerarlo vacío.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>VRAM Completo (0x8000-0x97FF)</h3>
                <p>
                    VRAM tiene un rango total de 6144 bytes (384 tiles × 16 bytes). El direccionamiento puede ser:
                </p>
                <ul>
                    <li><strong>Unsigned addressing (base 0x8000)</strong>: Tiles 0-255 en 0x8000-0x8FFF</li>
                    <li><strong>Signed addressing (base 0x9000)</strong>: Tiles -128 a 127 en 0x8800-0x97FF</li>
                </ul>
                <p>
                    En signed addressing:
                </p>
                <ul>
                    <li>Tile 0 está en 0x9000</li>
                    <li>Tile -1 (0xFF) está en 0x8FF0</li>
                    <li>Tile -128 (0x80) está en 0x8800</li>
                    <li>Tile 127 (0x7F) está en 0x9FF0</li>
                </ul>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Tile Data"
                </p>

                <h3>Tilemap y Correspondencia con Tiles</h3>
                <p>
                    El tilemap contiene tile IDs que apuntan a tiles en VRAM. Si el tilemap no se actualiza después de cargar tiles, apunta a tiles vacíos. Los juegos deben actualizar el tilemap para apuntar a los tiles reales cargados. Si el tilemap apunta a tiles vacíos, se renderiza blanco o patrón de prueba.
                </p>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Tile Map"
                </p>

                <h3>Detección de Tiles Vacíos</h3>
                <p>
                    Un tile está completamente vacío si todas sus 8 líneas (16 bytes) son 0x0000. Algunos tiles legítimos pueden tener líneas con 0x0000 (transparentes). Solo se debe usar patrón de prueba si TODO el tile está vacío.
                </p>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Tile Data"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>1. Corrección de Verificación de Tiles Reales</h3>
                <p>
                    Se modificó la verificación en <code>PPU::render_scanline()</code> para revisar TODO VRAM (0x8000-0x97FF = 6144 bytes) en lugar de solo los primeros 2048 bytes. Esto cubre tanto signed como unsigned addressing.
                </p>
                <p>
                    El umbral se ajustó de 100 bytes no-cero a 500 bytes no-cero (aprox. 31 tiles completos) porque ahora revisamos 3x más bytes.
                </p>
                <pre><code>// Verificar TODO VRAM (0x8000-0x97FF = 6144 bytes = 384 tiles)
for (uint16_t i = 0; i < 6144; i++) {
    uint8_t byte = mmu_->read(0x8000 + i);
    if (byte != 0x00) {
        non_zero_bytes++;
    }
}

bool has_tiles_now = (non_zero_bytes > 500);</code></pre>

                <h3>2. Monitor de Cambios en Tilemap</h3>
                <p>
                    Se mejoró el monitor en <code>MMU::write()</code> para detectar cuando el juego actualiza el tilemap. El monitor loggea los primeros 100 cambios y cuando hay cambios significativos (de 0x00 a un valor no-cero).
                </p>
                <pre><code>if ((addr >= 0x9800 && addr <= 0x9BFF) || (addr >= 0x9C00 && addr <= 0x9FFF)) {
    static int tilemap_update_count = 0;
    static uint8_t last_tilemap_value = 0xFF;
    
    if (tilemap_update_count < 100 || (value != 0x00 && last_tilemap_value == 0x00)) {
        printf("[TILEMAP-UPDATE] PC:0x%04X | Addr:0x%04X | TileID:0x%02X\n", 
               debug_current_pc, addr, value);
        tilemap_update_count++;
    }
}</code></pre>

                <h3>3. Análisis de Correspondencia Tilemap-Tiles</h3>
                <p>
                    Se agregó un análisis en <code>PPU::render_scanline()</code> que verifica si el tilemap apunta a tiles con datos reales cuando se detectan tiles en VRAM. El análisis verifica los primeros 32 tile IDs del tilemap y cuenta cuántos apuntan a tiles con datos y cuántos apuntan a tiles vacíos.
                </p>
                <pre><code>if (vram_has_tiles && ly_ == 0 && tilemap_tiles_analysis_count < 5 && (frame_counter_ % 60 == 0)) {
    int tiles_pointing_to_real_data = 0;
    int tiles_pointing_to_empty = 0;
    
    for (int i = 0; i < 32; i++) {
        uint8_t tile_id = mmu_->read(tile_map_base + i);
        // Calcular dirección del tile según el direccionamiento
        // Verificar si el tile tiene datos
        if (tile_byte1 != 0x00 || tile_byte2 != 0x00) {
            tiles_pointing_to_real_data++;
        } else {
            tiles_pointing_to_empty++;
        }
    }
}</code></pre>

                <h3>4. Verificación de Cálculo de Dirección de Tile</h3>
                <p>
                    Se agregó una verificación que confirma que el cálculo de dirección de tile es correcto para signed/unsigned addressing. La verificación muestra ejemplos de tile IDs y direcciones calculadas.
                </p>
                <pre><code>if (signed_addressing) {
    int8_t signed_id = static_cast<int8_t>(sample_tile_id);
    calculated_addr = tile_data_base + ((int8_t)sample_tile_id * 16);
    printf("[PPU-TILE-ADDR-VERIFY] TileID: 0x%02X (signed: %d) | Base: 0x%04X | Calculado: 0x%04X\n",
           sample_tile_id, signed_id, tile_data_base, calculated_addr);
} else {
    calculated_addr = tile_data_base + (sample_tile_id * 16);
    printf("[PPU-TILE-ADDR-VERIFY] TileID: 0x%02X (unsigned) | Base: 0x%04X | Calculado: 0x%04X\n",
           sample_tile_id, tile_data_base, calculated_addr);
}</code></pre>

                <h3>5. Mejora de Detección de Tiles Vacíos</h3>
                <p>
                    Se mejoró la lógica de renderizado para verificar TODO el tile (16 bytes) antes de considerarlo vacío. Esto evita que tiles legítimos con algunas líneas en 0x0000 sean considerados vacíos.
                </p>
                <pre><code>bool tile_is_empty = true;

// Verificar si TODO el tile está vacío (todas las 8 líneas = 16 bytes)
for (uint8_t line_check = 0; line_check < 8; line_check++) {
    uint16_t check_addr = tile_addr + (line_check * 2);
    uint8_t check_byte1 = mmu_->read(check_addr);
    uint8_t check_byte2 = mmu_->read(check_addr + 1);
    
    if (check_byte1 != 0x00 || check_byte2 != 0x00) {
        tile_is_empty = false;
        break;
    }
}</code></pre>
            </section>

            <!-- 4. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                
                <h3>Compilación</h3>
                <p>
                    El módulo C++ se recompiló exitosamente sin errores (solo warnings menores de formato).
                </p>
                <pre><code>$ python3 setup.py build_ext --inplace
running build_ext
building 'viboy_core' extension
...
copying build/lib.linux-x86_64-cpython-312/viboy_core.cpython-312-x86_64-linux-gnu.so -></code></pre>

                <h3>Pruebas con ROMs</h3>
                <p>
                    Se ejecutaron pruebas con las 3 ROMs (pkmn.gb, tetris.gb, mario.gbc) durante 2.5 minutos cada una. Los logs muestran:
                </p>
                <ul>
                    <li>✅ Detección de tiles completamente vacíos funcionando correctamente</li>
                    <li>✅ Monitor de cambios en tilemap capturando actualizaciones</li>
                    <li>✅ Verificación de tiles reales revisando TODO VRAM</li>
                </ul>

                <h3>Validación de Módulo Compilado C++</h3>
                <p>
                    El módulo compilado se carga correctamente y las funciones C++ se ejecutan sin errores. Los monitores y verificaciones implementadas están activos y generan logs cuando se cumplen las condiciones.
                </p>
            </section>

            <!-- 5. Resultados -->
            <section id="resultados">
                <h2>Resultados</h2>
                
                <h3>Correcciones Implementadas</h3>
                <ul>
                    <li>✅ Verificación de tiles reales ahora revisa TODO VRAM (6144 bytes) en lugar de solo 2048 bytes</li>
                    <li>✅ Monitor de cambios en tilemap mejorado para capturar actualizaciones</li>
                    <li>✅ Análisis de correspondencia tilemap-tiles implementado</li>
                    <li>✅ Verificación de cálculo de dirección de tile implementada</li>
                    <li>✅ Detección de tiles vacíos mejorada para verificar todo el tile antes de considerarlo vacío</li>
                </ul>

                <h3>Hallazgos</h3>
                <ul>
                    <li>Los juegos escriben en el tilemap (se detectan actualizaciones en PC:0x129F para mario.gbc)</li>
                    <li>La detección de tiles vacíos funciona correctamente (se detectan tiles completamente vacíos en 0x8000)</li>
                    <li>El código compila y ejecuta sin errores</li>
                </ul>
            </section>

            <!-- 6. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                
                <p>
                    Si el renderizado funciona correctamente:
                </p>
                <ul>
                    <li><strong>Step 0326</strong>: Verificación final de controles y compatibilidad</li>
                    <li><strong>Step 0327</strong>: Evaluación final del plan estratégico</li>
                </ul>

                <p>
                    Si el problema persiste:
                </p>
                <ul>
                    <li><strong>Step 0326</strong>: Análisis más profundo del tilemap y solución alternativa</li>
                    <li>Investigar si hay problemas en la sincronización o timing</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                <a href="../index.html">Volver al índice</a> |
                <a href="2025-12-28__0324__renderizado-tiles-reales-nombre-juego.html">Anterior: Step 0324</a>
            </p>
        </footer>
    </div>
</body>
</html>

