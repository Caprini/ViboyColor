<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0417: Fix CPU Unit Tests (Ejecutar desde WRAM) - Viboy Color</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica (Pan Docs) y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <a href="../index.html" class="back-link">← Volver a Bitácora</a>
            <h1>Step 0417: Fix CPU Unit Tests (Ejecutar desde WRAM)</h1>
            <div class="entry-meta">
                <strong>Fecha:</strong> 2026-01-02 | 
                <strong>Step ID:</strong> 0417 | 
                <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
            </div>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Resumen Ejecutivo -->
            <section class="section">
                <h2>Resumen Ejecutivo</h2>
                <p>
                    Refactorización completa del harness de tests unitarios de CPU para ejecutar programas de prueba desde 
                    <strong>WRAM (0xC000)</strong> en lugar de intentar escribir en <strong>ROM (0x0000-0x7FFF)</strong>. 
                    El problema original era que <code>PyMMU.write(0x0000)</code> no escribe memoria (ROM es read-only), 
                    causando que la CPU leyera <code>0x00</code> (NOP) y los tests no validaran las instrucciones reales.
                </p>
                
                <div class="highlight-box">
                    <strong>Resultado:</strong> ✅ <strong>6/6 tests pasando</strong> (100% success rate)
                    <br>
                    <strong>Impacto:</strong> Los tests ahora ejecutan las instrucciones reales en lugar de NOPs, 
                    validando correctamente el comportamiento de la CPU.
                </div>
            </section>

            <!-- Concepto de Hardware -->
            <section class="section">
                <h2>Concepto de Hardware: Mapa de Memoria Game Boy</h2>
                <p>
                    El Game Boy tiene un mapa de memoria bien definido donde cada región tiene características específicas 
                    de lectura/escritura:
                </p>
                
                <table class="memory-map-table">
                    <thead>
                        <tr>
                            <th>Rango</th>
                            <th>Nombre</th>
                            <th>Lectura</th>
                            <th>Escritura</th>
                            <th>Uso</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="highlight-row">
                            <td><code>0x0000-0x7FFF</code></td>
                            <td>ROM</td>
                            <td>✅</td>
                            <td>❌</td>
                            <td>Código del juego (Read Only Memory)</td>
                        </tr>
                        <tr>
                            <td><code>0x8000-0x9FFF</code></td>
                            <td>VRAM</td>
                            <td>✅</td>
                            <td>✅*</td>
                            <td>Tiles y mapas de fondo (*salvo Mode 3)</td>
                        </tr>
                        <tr>
                            <td><code>0xA000-0xBFFF</code></td>
                            <td>External RAM</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>RAM del cartucho (si existe)</td>
                        </tr>
                        <tr class="highlight-row success">
                            <td><code>0xC000-0xDFFF</code></td>
                            <td>WRAM</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>Work RAM (RAM de trabajo interna)</td>
                        </tr>
                        <tr>
                            <td><code>0xE000-0xFDFF</code></td>
                            <td>Echo RAM</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>Espejo de WRAM (prohibido usar)</td>
                        </tr>
                        <tr>
                            <td><code>0xFE00-0xFE9F</code></td>
                            <td>OAM</td>
                            <td>✅</td>
                            <td>✅*</td>
                            <td>Sprite Attribute Table (*salvo Mode 2/3)</td>
                        </tr>
                        <tr>
                            <td><code>0xFF00-0xFF7F</code></td>
                            <td>I/O Registers</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>Controles, video, audio, timer</td>
                        </tr>
                        <tr>
                            <td><code>0xFF80-0xFFFE</code></td>
                            <td>HRAM</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>High RAM (RAM rápida)</td>
                        </tr>
                        <tr>
                            <td><code>0xFFFF</code></td>
                            <td>IE Register</td>
                            <td>✅</td>
                            <td>✅</td>
                            <td>Interrupt Enable</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="info-box">
                    <strong>Por qué WRAM para tests:</strong>
                    <ul>
                        <li><strong>ROM (0x0000-0x7FFF)</strong> es read-only. Las escrituras a ROM controlan el MBC 
                            (Memory Bank Controller), no escriben datos.</li>
                        <li><strong>WRAM (0xC000-0xDFFF)</strong> es RAM totalmente escribible y legible, ideal para 
                            cargar programas de prueba.</li>
                        <li>Los juegos reales usan WRAM para código temporal, stacks de llamadas, y buffers de datos.</li>
                        <li>Ejecutar tests desde WRAM es más realista que modificar la MMU para permitir escrituras a ROM.</li>
                    </ul>
                </div>
                
                <p>
                    <strong>Referencia:</strong> Pan Docs - Memory Map 
                    (<a href="https://gbdev.io/pandocs/Memory_Map.html" target="_blank">https://gbdev.io/pandocs/Memory_Map.html</a>)
                </p>
            </section>

            <!-- Implementación -->
            <section class="section">
                <h2>Implementación</h2>
                
                <h3>1. Helper de Carga de Programas</h3>
                <p>
                    Se creó el archivo <code>tests/helpers_cpu.py</code> con un helper que:
                </p>
                <ul>
                    <li>Escribe un programa (lista de bytes) en WRAM</li>
                    <li>Configura el PC para ejecutar desde esa dirección</li>
                    <li>Verifica que la escritura fue exitosa (read-back check)</li>
                </ul>
                
                <pre><code class="language-python"># tests/helpers_cpu.py

# Constante: dirección base para ejecutar programas de test
TEST_EXEC_BASE = 0xC000  # WRAM

def load_program(mmu, regs, program_bytes: List[int], start_addr: int = TEST_EXEC_BASE) -> None:
    """
    Carga un programa de test en memoria y configura el PC.
    
    Args:
        mmu: Instancia de PyMMU donde escribir el programa
        regs: Instancia de PyRegisters donde configurar el PC
        program_bytes: Lista de bytes (opcodes e inmediatos) del programa
        start_addr: Dirección de inicio (por defecto TEST_EXEC_BASE = 0xC000)
    """
    # Escribir cada byte del programa
    for i, byte_val in enumerate(program_bytes):
        addr = start_addr + i
        mmu.write(addr, byte_val)
    
    # Configurar PC al inicio del programa
    regs.pc = start_addr
    
    # Verificación: leer de vuelta para confirmar escritura
    for i, byte_val in enumerate(program_bytes):
        addr = start_addr + i
        read_back = mmu.read(addr)
        if read_back != byte_val:
            raise AssertionError(
                f"load_program: Verificación falló en 0x{addr:04X}: "
                f"esperado 0x{byte_val:02X}, leído 0x{read_back:02X}"
            )</code></pre>
                
                <h3>2. Refactorización de Tests</h3>
                <p>
                    Todos los tests en <code>tests/test_core_cpu.py</code> se refactorizaron para usar el nuevo helper:
                </p>
                
                <pre><code class="language-python"># ANTES (escribía en ROM, no funcionaba)
mmu.write(0x0000, 0x3E)  # LD A, d8
mmu.write(0x0001, 0x42)
regs.pc = 0x0000

# DESPUÉS (ejecuta desde WRAM, funciona)
load_program(mmu, regs, [0x3E, 0x42])  # LD A, 0x42
# PC se configura automáticamente a TEST_EXEC_BASE (0xC000)</code></pre>
                
                <h3>3. Corrección de Opcode de Test</h3>
                <p>
                    El test <code>test_unknown_opcode_returns_zero</code> usaba <code>0xFF</code> (RST 38h), que 
                    <strong>sí está implementado</strong>. Se cambió a <code>0xD3</code>, un opcode ilegal en Game Boy 
                    que no está definido en el instruction set.
                </p>
                
                <pre><code class="language-python"># test_unknown_opcode_returns_zero (corregido)
load_program(mmu, regs, [0xD3])  # 0xD3 es opcode ilegal
cycles = cpu.step()
assert cycles == 0, "Opcode desconocido debe retornar 0"</code></pre>
            </section>

            <!-- Tests y Verificación -->
            <section class="section">
                <h2>Tests y Verificación</h2>
                
                <div class="highlight-box success">
                    <h3>✅ Todos los Tests Pasando</h3>
                    <p><strong>Comando:</strong></p>
                    <pre><code>pytest -v tests/test_core_cpu.py</code></pre>
                    
                    <p><strong>Resultado:</strong></p>
                    <pre><code>tests/test_core_cpu.py::TestCoreCPU::test_cpu_initialization PASSED                [ 16%]
tests/test_core_cpu.py::TestCoreCPU::test_nop_instruction PASSED                    [ 33%]
tests/test_core_cpu.py::TestCoreCPU::test_ld_a_d8_instruction PASSED                [ 50%]
tests/test_core_cpu.py::TestCoreCPU::test_ld_a_d8_multiple_executions PASSED        [ 66%]
tests/test_core_cpu.py::TestCoreCPU::test_unknown_opcode_returns_zero PASSED        [ 83%]
tests/test_core_cpu.py::TestCoreCPU::test_cpu_with_shared_mmu_and_registers PASSED  [100%]

============================== 6 passed in 0.36s</code></pre>
                </div>
                
                <h3>Validación del Test Clave</h3>
                <p><strong>Comando:</strong></p>
                <pre><code>pytest -v tests/test_core_cpu.py::TestCoreCPU::test_ld_a_d8_instruction --maxfail=1 -x</code></pre>
                
                <p><strong>Resultado:</strong></p>
                <pre><code>tests/test_core_cpu.py::TestCoreCPU::test_ld_a_d8_instruction PASSED     [100%]

============================== 1 passed in 0.47s</code></pre>
                
                <h3>Código del Test Validado</h3>
                <pre><code class="language-python">def test_ld_a_d8_instruction(self):
    """Test: La instrucción LD A, d8 (0x3E) funciona correctamente."""
    mmu = PyMMU()
    regs = PyRegisters()
    cpu = PyCPU(mmu, regs)
    
    # Cargar programa de test en WRAM
    # 0x3E = LD A, d8
    # 0x42 = valor inmediato (d8)
    load_program(mmu, regs, [0x3E, 0x42])
    regs.a = 0x00  # Inicializar A a 0
    
    # Ejecutar un ciclo
    cycles = cpu.step()
    
    # Verificar resultados
    assert cycles == 2, "LD A, d8 debe consumir 2 M-Cycles"
    assert regs.a == 0x42, "Registro A debe contener 0x42"
    assert regs.pc == TEST_EXEC_BASE + 2, "PC debe incrementarse 2 bytes"
    assert cpu.get_cycles() == 2, "Contador de ciclos debe ser 2"</code></pre>
                
                <h4>✅ Validación de Módulo Compilado C++</h4>
                <p>
                    Los tests validan el módulo C++/Cython compilado (<code>viboy_core.so</code>), no código Python puro.
                </p>
            </section>

            <!-- Archivos Afectados -->
            <section class="section">
                <h2>Archivos Afectados</h2>
                <ul class="file-list">
                    <li><strong>Creados:</strong>
                        <ul>
                            <li><code>tests/helpers_cpu.py</code> - Helper de carga de programas para tests</li>
                        </ul>
                    </li>
                    <li><strong>Modificados:</strong>
                        <ul>
                            <li><code>tests/test_core_cpu.py</code> - 6 tests refactorizados para ejecutar desde WRAM</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- Conclusiones -->
            <section class="section">
                <h2>Conclusiones</h2>
                <ul>
                    <li>✅ <strong>Tests robustos:</strong> Ahora ejecutan las instrucciones reales en lugar de NOPs</li>
                    <li>✅ <strong>Realismo:</strong> Ejecutar desde WRAM es más cercano a cómo funcionan los juegos reales</li>
                    <li>✅ <strong>Mantenibilidad:</strong> Helper reutilizable para futuros tests de CPU</li>
                    <li>✅ <strong>Integridad:</strong> No se modificó la MMU para permitir escrituras a ROM (contaminaría emulación real)</li>
                    <li>✅ <strong>Descubrimiento:</strong> El test de opcode desconocido reveló que 0xFF (RST 38h) está implementado</li>
                </ul>
                
                <div class="info-box">
                    <strong>Próximos Pasos:</strong>
                    <ul>
                        <li>Usar este patrón para nuevos tests de instrucciones CPU</li>
                        <li>Expandir la cobertura de tests a más opcodes</li>
                        <li>Considerar tests de edge cases (flags, overflows, etc.)</li>
                    </ul>
                </div>
            </section>

            <!-- Entorno Técnico -->
            <section class="section">
                <h2>Entorno Técnico</h2>
                <ul>
                    <li><strong>Compilador:</strong> GCC 13.2.0 (C++17)</li>
                    <li><strong>Cython:</strong> 3.0.11</li>
                    <li><strong>Python:</strong> 3.12.3</li>
                    <li><strong>pytest:</strong> 9.0.2</li>
                    <li><strong>OS:</strong> Ubuntu 24.04 LTS (Linux 6.14.0-37-generic)</li>
                    <li><strong>Build:</strong> <code>python3 setup.py build_ext --inplace</code></li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <a href="../index.html" class="back-link">← Volver a Bitácora</a>
            <p>Viboy Color - Proyecto educativo Open Source</p>
        </footer>
    </div>
    
    <style>
        .memory-map-table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--spacing-md) 0;
            font-family: 'Courier New', monospace;
        }
        
        .memory-map-table th,
        .memory-map-table td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }
        
        .memory-map-table th {
            background-color: var(--color-bg-alt);
            font-weight: bold;
        }
        
        .memory-map-table .highlight-row {
            background-color: rgba(255, 165, 0, 0.1);
        }
        
        .memory-map-table .highlight-row.success {
            background-color: rgba(0, 255, 0, 0.1);
        }
    </style>
</body>
</html>
