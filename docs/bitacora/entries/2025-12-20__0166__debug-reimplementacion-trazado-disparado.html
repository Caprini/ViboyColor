<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug: Reimplementaci贸n del Trazado Disparado para Superar Bucles de Inicializaci贸n - Viboy Color Bit谩cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>锔 Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c贸digo de otros emuladores. Implementaci贸n basada 煤nicamente en documentaci贸n t茅cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Debug: Reimplementaci贸n del Trazado Disparado para Superar Bucles de Inicializaci贸n</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-20
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0166
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft"> DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-20__0165__fix-critico-flag-cero-en-dec.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    El an谩lisis de la traza del Step 0165 confirm贸 que la CPU no est谩 en un bucle infinito por un bug, sino que est谩 ejecutando correctamente una rutina de inicializaci贸n de limpieza de memoria muy larga. Nuestro m茅todo de trazado de longitud fija (200 instrucciones desde PC=0x0100) es ineficiente para ver el c贸digo que se ejecuta <em>despu茅s</em> de esta rutina. Este Step reimplementa el sistema de trazado "disparado" (triggered) para que se active autom谩ticamente solo cuando el Program Counter (PC) supere la direcci贸n 0x0300, permiti茅ndonos capturar el c贸digo cr铆tico de configuraci贸n de hardware que ocurre despu茅s de las rutinas de limpieza.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware: Rutinas de Inicializaci贸n (BIOS/Juego)</h2>
                <p>
                    Antes de que cualquier juego pueda mostrar gr谩ficos o aceptar input, debe preparar el "escenario". Esto implica una secuencia de inicializaci贸n que, t铆picamente, incluye:
                </p>
                <ol>
                    <li><strong>Desactivar interrupciones:</strong> Para evitar que eventos externos interrumpan la secuencia cr铆tica de inicializaci贸n.</li>
                    <li><strong>Configurar el puntero de pila (Stack Pointer):</strong> Establecer un 谩rea de memoria v谩lida para las operaciones de pila.</li>
                    <li><strong>Limpiar la RAM:</strong> Poner a cero grandes 谩reas como WRAM (Work RAM) y HRAM (High RAM) para asegurar un estado conocido y predecible. Esto se hace con bucles anidados muy r谩pidos que pueden consumir miles de ciclos de CPU.</li>
                    <li><strong>Configurar los registros de hardware:</strong> PPU (LCDC, BGP, SCY, SCX), APU, Timer, etc.</li>
                    <li><strong>Copiar los datos gr谩ficos (tiles):</strong> Transferir los tiles desde la ROM a la VRAM.</li>
                    <li><strong>Activar la pantalla y las interrupciones:</strong> Finalmente, habilitar el renderizado y los eventos.</li>
                </ol>
                <p>
                    Nuestro emulador est谩 ejecutando correctamente el paso 3 (limpieza de memoria). La estrategia de trazado anterior capturaba estas rutinas de limpieza, que son aburridas y repetitivas. Nuestra nueva estrategia es dejar que la CPU corra a toda velocidad a trav茅s de estas rutinas y empezar a grabar en el paso 4, donde ocurre la configuraci贸n de hardware que realmente nos interesa.
                </p>
                <p>
                    <strong>El problema del trazado fijo:</strong> Si comenzamos a trazar desde PC=0x0100 con un l铆mite de 200 instrucciones, capturamos principalmente bucles de limpieza. Estos bucles pueden ejecutar miles de instrucciones antes de que se dibuje un solo p铆xel. Nuestro l铆mite de 200 instrucciones apenas rasca la superficie de esta rutina.
                </p>
                <p>
                    <strong>La soluci贸n del trazado disparado:</strong> Configuramos un "breakpoint" en la direcci贸n 0x0300, que es una apuesta segura para estar m谩s all谩 de las principales rutinas de limpieza. La CPU ejecuta silenciosamente hasta alcanzar esta direcci贸n, y entonces comenzamos a registrar las instrucciones. Esto nos permite ver exactamente qu茅 registros de hardware intenta configurar el juego.
                </p>
            </section>

            <!-- 3. Implementaci贸n -->
            <section id="implementacion">
                <h2>Implementaci贸n</h2>
                <p>
                    Se modificaron las constantes de trazado en <code>src/core/cpp/CPU.cpp</code> para cambiar el punto de activaci贸n y el l铆mite de instrucciones registradas.
                </p>
                
                <h3>Modificaciones en CPU.cpp</h3>
                <p>
                    Se actualizaron las siguientes constantes est谩ticas (l铆neas 7-13):
                </p>
                <ul>
                    <li><strong>DEBUG_TRIGGER_PC:</strong> Cambiado de <code>0x0100</code> a <code>0x0300</code>. Esta direcci贸n est谩 m谩s all谩 de las rutinas de limpieza de memoria t铆picas.</li>
                    <li><strong>DEBUG_INSTRUCTION_LIMIT:</strong> Reducido de <code>200</code> a <code>100</code>. Como ahora estamos capturando c贸digo m谩s relevante, no necesitamos tantas instrucciones para identificar el problema.</li>
                </ul>
                <p>
                    La l贸gica del trazado disparado ya estaba implementada correctamente en el m茅todo <code>step()</code> (l铆neas 471-484). Solo necesit谩bamos ajustar los par谩metros:
                </p>
                <pre><code>// Variables est谩ticas para logging de diagn贸stico con sistema "disparado" (triggered)
// El trigger se activa despu茅s de las rutinas de limpieza de memoria (0x0300)
// para capturar el c贸digo cr铆tico de configuraci贸n de hardware
static const uint16_t DEBUG_TRIGGER_PC = 0x0300; // Direcci贸n de activaci贸n del trazado (despu茅s de limpieza)
static bool debug_trace_activated = false;      // Bandera de activaci贸n
static int debug_instruction_counter = 0;       // Contador post-activaci贸n
static const int DEBUG_INSTRUCTION_LIMIT = 100;  // L铆mite post-activaci贸n (dirigido, m谩s corto)</code></pre>
                <p>
                    La l贸gica de activaci贸n permanece igual:
                </p>
                <ol>
                    <li>Cuando el PC alcanza o supera <code>DEBUG_TRIGGER_PC</code>, se imprime un mensaje de activaci贸n y se activa la bandera <code>debug_trace_activated</code>.</li>
                    <li>Mientras la traza est茅 activa y no hayamos alcanzado el l铆mite, se registra cada instrucci贸n con su PC y opcode.</li>
                    <li>El contador se incrementa hasta alcanzar <code>DEBUG_INSTRUCTION_LIMIT</code>.</li>
                </ol>

                <h3>Decisiones de Dise帽o</h3>
                <p>
                    <strong>驴Por qu茅 0x0300?</strong> Esta direcci贸n es una apuesta segura basada en el conocimiento de que las rutinas de limpieza t铆picamente ocupan las primeras 512-768 bytes de memoria. 0x0300 (768 decimal) est谩 lo suficientemente lejos para estar fuera de estas rutinas, pero lo suficientemente cerca para capturar la configuraci贸n inicial de hardware.
                </p>
                <p>
                    <strong>驴Por qu茅 reducir el l铆mite a 100?</strong> Ahora que estamos capturando c贸digo m谩s relevante, 100 instrucciones deber铆an ser suficientes para identificar el siguiente opcode no implementado que est谩 bloqueando el renderizado. Si necesitamos m谩s, podemos aumentar el l铆mite en el futuro.
                </p>
            </section>

            <!-- 4. Archivos Modificados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/CPU.cpp</code> - Modificaci贸n de constantes de trazado (l铆neas 7-13). Cambio de <code>DEBUG_TRIGGER_PC</code> de 0x0100 a 0x0300 y reducci贸n de <code>DEBUG_INSTRUCTION_LIMIT</code> de 200 a 100.</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci贸n -->
            <section id="tests">
                <h2>Tests y Verificaci贸n</h2>
                <p>
                    Este cambio no afecta la funcionalidad de la CPU, solo modifica el comportamiento del sistema de depuraci贸n. Los tests existentes deben seguir pasando sin modificaciones.
                </p>
                
                <h3>Comando Ejecutado</h3>
                <pre><code>pytest -v</code></pre>

                <h3>Resultado Esperado</h3>
                <p>
                    Todos los tests deben pasar, ya que solo modificamos constantes de depuraci贸n que no afectan la l贸gica de emulaci贸n.
                </p>

                <h3>Validaci贸n del Trazado</h3>
                <p>
                    Para validar que el nuevo sistema de trazado funciona correctamente, se ejecutar谩 el emulador con una ROM de prueba:
                </p>
                <pre><code>python main.py roms/tetris.gb</code></pre>
                <p>
                    <strong>Comportamiento esperado:</strong>
                </p>
                <ul>
                    <li>La consola permanece en silencio mientras la CPU ejecuta los bucles de limpieza a toda velocidad.</li>
                    <li>Cuando el PC alcanza 0x0300, aparece el mensaje: <code>--- [CPU TRACE TRIGGERED at PC: 0x0300] ---</code></li>
                    <li>Se registran las siguientes 100 instrucciones con su PC y opcode.</li>
                    <li>Esta nueva traza deber铆a revelar los opcodes de configuraci贸n de hardware (probablemente relacionados con LCDC, BGP, SCY, SCX).</li>
                </ul>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/">Game Boy Pan Docs</a> - Documentaci贸n general sobre el proceso de inicializaci贸n del Game Boy.</li>
                    <li>GBEDG: <a href="https://gbdev.io/gb-opcodes/optables/">Game Boy Opcode Table</a> - Referencia para identificar opcodes en la traza.</li>
                </ul>
                <p>
                    <em>Nota: El conocimiento sobre las rutinas de inicializaci贸n proviene de la observaci贸n emp铆rica de trazas anteriores y del conocimiento general de arquitectura de sistemas embebidos.</em>
                </p>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Rutinas de inicializaci贸n:</strong> Los juegos de Game Boy ejecutan rutinas de limpieza de memoria muy largas antes de configurar el hardware. Estas rutinas pueden consumir miles de ciclos de CPU.</li>
                        <li><strong>Trazado dirigido:</strong> En lugar de capturar todas las instrucciones desde el inicio, es m谩s eficiente usar un sistema de "breakpoint" que se active solo cuando el PC alcanza una direcci贸n espec铆fica.</li>
                        <li><strong>Optimizaci贸n de depuraci贸n:</strong> Reducir el ruido en las trazas nos permite identificar m谩s r谩pidamente los problemas reales.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Direcci贸n 贸ptima del trigger:</strong> 0x0300 es una estimaci贸n. Podr铆a necesitar ajustarse si las ROMs tienen rutinas de limpieza m谩s largas o m谩s cortas.</li>
                        <li><strong>Opcodes no implementados:</strong> La nueva traza revelar谩 qu茅 opcodes faltan por implementar que est谩n bloqueando el renderizado de gr谩ficos.</li>
                    </ul>

                    <h3>Hip贸tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip贸tesis principal:</strong> La direcci贸n 0x0300 est谩 lo suficientemente lejos de las rutinas de limpieza para capturar el c贸digo de configuraci贸n de hardware, pero lo suficientemente cerca para no perder informaci贸n relevante.
                    </p>
                    <p>
                        <strong>Suposici贸n:</strong> Las ROMs de prueba (Tetris, Mario) siguen un patr贸n similar de inicializaci贸n, por lo que 0x0300 deber铆a funcionar para todas ellas.
                    </p>
                </div>
            </section>

            <!-- 8. Pr贸ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr贸ximos Pasos</h2>
                <ul>
                    <li>[ ] Recompilar el m贸dulo C++ con <code>.\rebuild_cpp.ps1</code></li>
                    <li>[ ] Ejecutar el emulador con <code>python main.py roms/tetris.gb</code> y analizar la nueva traza</li>
                    <li>[ ] Identificar los opcodes de configuraci贸n de hardware en la traza (LCDC, BGP, SCY, SCX, etc.)</li>
                    <li>[ ] Implementar los opcodes faltantes que est谩n bloqueando el renderizado</li>
                    <li>[ ] Verificar que el emulador avance m谩s all谩 de las rutinas de inicializaci贸n</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c贸digo de otros emuladores. Basado 煤nicamente en documentaci贸n t茅cnica.</p>
        </footer>
    </div>
</body>
</html>

