<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modos PPU y Registro STAT - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Modos PPU y Registro STAT</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0047
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0046__forzar-modo-dmg-heartbeat-visual.html">Anterior</a></li>
                    <li><a href="2025-12-18__0048__diagnostico-visual-lcd-apagado.html">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Se implementó la <strong>máquina de estados de modos PPU</strong> (Mode 0, 1, 2, 3) que controla el ciclo de vida
                    de cada línea de escaneo. La PPU ahora actualiza dinámicamente su modo según el timing de la línea, permitiendo
                    que los juegos detecten cuándo es seguro acceder a la VRAM. Se integró el <strong>registro STAT (0xFF41)</strong>
                    en la MMU para que los juegos puedan leer el modo PPU actual y configurar interrupciones basadas en modos.
                    Esta implementación es crítica porque muchos juegos esperan que STAT cambie dinámicamente antes de continuar
                    con la inicialización o el renderizado.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Los 4 Modos de la PPU</strong>: Cada línea de escaneo de 456 T-Cycles se divide en estados que indican
                    qué está haciendo la PPU en cada momento:
                </p>
                <ul>
                    <li><strong>Mode 2 (OAM Search)</strong>: Primeros ~80 ciclos. La PPU busca sprites en OAM (Object Attribute Memory)
                        que intersectan con la línea actual. Durante este modo, la CPU está <strong>bloqueada de acceder a OAM</strong>
                        (0xFE00-0xFE9F) para evitar conflictos de acceso.</li>
                    <li><strong>Mode 3 (Pixel Transfer)</strong>: Siguientes ~172 ciclos (80-251). La PPU dibuja los píxeles de la línea
                        leyendo tiles de VRAM y aplicando paletas. Durante este modo, la CPU está <strong>bloqueada de acceder a VRAM</strong>
                        (0x8000-0x9FFF) y OAM para evitar corrupción de datos durante el renderizado.</li>
                    <li><strong>Mode 0 (H-Blank)</strong>: Resto de la línea (~204 ciclos, 252-455). Descanso horizontal después de dibujar
                        la línea. Durante este modo, la CPU <strong>puede acceder libremente a VRAM y OAM</strong> para actualizar tiles,
                        tilemaps, sprites, etc.</li>
                    <li><strong>Mode 1 (V-Blank)</strong>: Líneas 144-153 completas (10 líneas). Descanso vertical después de dibujar todas
                        las líneas visibles. Durante este modo, la CPU <strong>puede acceder libremente a VRAM y OAM</strong>. Es el momento
                        ideal para actualizar gráficos, ya que no hay renderizado activo.</li>
                </ul>
                <p>
                    <strong>Registro STAT (0xFF41)</strong>: Los juegos leen constantemente este registro para saber en qué modo está la PPU:
                </p>
                <ul>
                    <li><strong>Bits 0-1</strong>: Modo PPU actual (00=H-Blank, 01=V-Blank, 10=OAM Search, 11=Pixel Transfer). <strong>De solo lectura</strong>.</li>
                    <li><strong>Bit 2</strong>: LYC=LY Coincidence Flag (LY == LYC). Indica si la línea actual coincide con LYC.</li>
                    <li><strong>Bit 3</strong>: Mode 0 (H-Blank) Interrupt Enable. Si está activo, genera interrupción cuando entra en H-Blank.</li>
                    <li><strong>Bit 4</strong>: Mode 1 (V-Blank) Interrupt Enable. Si está activo, genera interrupción cuando entra en V-Blank.</li>
                    <li><strong>Bit 5</strong>: Mode 2 (OAM Search) Interrupt Enable. Si está activo, genera interrupción cuando entra en OAM Search.</li>
                    <li><strong>Bit 6</strong>: LYC=LY Coincidence Interrupt Enable. Si está activo, genera interrupción cuando LY == LYC.</li>
                    <li><strong>Bit 7</strong>: No usado (siempre 0).</li>
                </ul>
                <p>
                    <strong>Problema identificado</strong>: Si el registro STAT no se actualiza dinámicamente, los juegos que hacen polling
                    de STAT esperan eternamente a que la PPU entre en un modo seguro (H-Blank o V-Blank) antes de continuar. Esto causa
                    que el juego se quede congelado con el LCD apagado (LCDC=0x00), esperando una señal que nunca llega.
                </p>
                <p>
                    <strong>Fuente</strong>: Pan Docs - LCD Status Register (STAT), PPU Modes, LCD Timing
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>1. Máquina de Estados de Modos PPU</h3>
                <p>
                    Se añadió el atributo <code>mode</code> a la clase <code>PPU</code> y se implementó el método <code>_update_mode()</code>
                    que calcula el modo actual según el punto en la línea (line_cycles) y LY:
                </p>
                <pre><code>def _update_mode(self) -> None:
    """Actualiza el modo PPU actual según el punto en la línea."""
    # Si estamos en V-Blank (líneas 144-153), siempre Mode 1
    if self.ly >= VBLANK_START:
        self.mode = PPU_MODE_1_VBLANK
        return
    
    # Para líneas visibles (0-143), el modo depende de los ciclos dentro de la línea
    line_cycles = self.clock
    
    if line_cycles < MODE_2_CYCLES:  # 0-79
        self.mode = PPU_MODE_2_OAM_SEARCH
    elif line_cycles < (MODE_2_CYCLES + MODE_3_CYCLES):  # 80-251
        self.mode = PPU_MODE_3_PIXEL_TRANSFER
    else:  # 252-455
        self.mode = PPU_MODE_0_HBLANK</code></pre>
                <p>
                    El método <code>step()</code> ahora llama a <code>_update_mode()</code> antes y después de procesar líneas completas
                    para asegurar que el modo siempre refleje el estado actual de la PPU.
                </p>

                <h3>2. Registro STAT en MMU</h3>
                <p>
                    Se añadió interceptación de lectura/escritura del registro STAT (0xFF41) en la MMU:
                </p>
                <ul>
                    <li><strong>Lectura</strong>: Llama a <code>ppu.get_stat()</code> que combina el modo actual (bits 0-1) con los bits
                        configurables (2-6) guardados en memoria.</li>
                    <li><strong>Escritura</strong>: Guarda solo los bits configurables (2-6) en memoria, ignorando los bits 0-1 que son de
                        solo lectura.</li>
                </ul>
                <p>
                    El método <code>get_stat()</code> en la PPU lee directamente de <code>mmu._memory[0xFF41]</code> para evitar recursión
                    infinita (ya que la MMU llama a <code>ppu.get_stat()</code> cuando se lee 0xFF41).
                </p>

                <h3>3. Constantes de Modos y Timing</h3>
                <p>
                    Se añadieron constantes para los modos PPU y los ciclos de cada modo:
                </p>
                <pre><code>PPU_MODE_0_HBLANK = 0      # H-Blank
PPU_MODE_1_VBLANK = 1      # V-Blank
PPU_MODE_2_OAM_SEARCH = 2  # OAM Search
PPU_MODE_3_PIXEL_TRANSFER = 3  # Pixel Transfer

MODE_2_CYCLES = 80   # OAM Search: primeros 80 ciclos
MODE_3_CYCLES = 172  # Pixel Transfer: siguientes 172 ciclos (80-251)
MODE_0_CYCLES = 204  # H-Blank: resto (252-455)</code></pre>

                <h3>Componentes creados/modificados</h3>
                <ul>
                    <li><strong>src/gpu/ppu.py</strong> (modificado):
                        <ul>
                            <li>Añadido atributo <code>mode</code> para almacenar el modo PPU actual</li>
                            <li>Método <code>_update_mode()</code>: Calcula el modo según line_cycles y LY</li>
                            <li>Método <code>step()</code>: Actualizado para llamar a <code>_update_mode()</code> antes y después de procesar líneas</li>
                            <li>Método <code>get_mode()</code>: Devuelve el modo PPU actual</li>
                            <li>Método <code>get_stat()</code>: Devuelve el valor del registro STAT combinando modo y bits configurables</li>
                            <li>Añadidas constantes de modos y timing</li>
                        </ul>
                    </li>
                    <li><strong>src/memory/mmu.py</strong> (modificado):
                        <ul>
                            <li>Interceptación de lectura de STAT (0xFF41): Llama a <code>ppu.get_stat()</code></li>
                            <li>Interceptación de escritura de STAT (0xFF41): Guarda solo bits configurables (2-6), ignora bits 0-1</li>
                        </ul>
                    </li>
                    <li><strong>tests/test_ppu_modes.py</strong> (nuevo):
                        <ul>
                            <li>7 tests completos que validan transiciones de modo, V-Blank, lectura/escritura de STAT</li>
                        </ul>
                    </li>
                </ul>

                <h3>Decisiones de diseño</h3>
                <p>
                    <strong>Acceso directo a _memory en get_stat()</strong>: Para evitar recursión infinita, <code>get_stat()</code> accede
                    directamente a <code>mmu._memory[0xFF41]</code> en lugar de usar <code>mmu.read_byte(0xFF41)</code>. Esto es un detalle
                    de implementación necesario, pero está documentado explícitamente en el código.
                </p>
                <p>
                    <strong>Actualización de modo antes y después de procesar líneas</strong>: El modo se actualiza tanto antes de procesar
                    líneas completas (para reflejar el estado durante la línea) como después (para reflejar el estado residual si quedan
                    ciclos). Esto asegura que el modo siempre sea correcto, incluso cuando se procesan múltiples líneas en una sola llamada
                    a <code>step()</code>.
                </p>
                <p>
                    <strong>Bits 0-1 de STAT son de solo lectura</strong>: Aunque el software puede intentar escribir en los bits 0-1,
                    estos siempre reflejan el modo PPU actual y no pueden ser modificados. La MMU ignora estos bits al escribir, guardando
                    solo los bits configurables (2-6).
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/ppu.py</code> (modificado):
                        <ul>
                            <li>Añadido atributo <code>mode</code> y constantes de modos/timing</li>
                            <li>Método <code>_update_mode()</code>: Calcula el modo PPU actual</li>
                            <li>Método <code>step()</code>: Actualizado para mantener el modo sincronizado</li>
                            <li>Métodos <code>get_mode()</code> y <code>get_stat()</code>: Nuevos métodos públicos</li>
                        </ul>
                    </li>
                    <li><code>src/memory/mmu.py</code> (modificado):
                        <ul>
                            <li>Interceptación de lectura/escritura de STAT (0xFF41)</li>
                        </ul>
                    </li>
                    <li><code>tests/test_ppu_modes.py</code> (nuevo):
                        <ul>
                            <li>7 tests completos para validar modos PPU y registro STAT</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                
                <h3>Tests Unitarios (pytest)</h3>
                <p>
                    <strong>Comando ejecutado</strong>: <code>pytest -q tests/test_ppu_modes.py</code>
                </p>
                <p>
                    <strong>Entorno</strong>: Windows 10, Python 3.13.5
                </p>
                <p>
                    <strong>Resultado</strong>: <strong>7 passed</strong> en 0.25s
                </p>
                <p>
                    <strong>Qué valida</strong>:
                </p>
                <ul>
                    <li><strong>Transiciones de modo durante línea visible</strong>: Verifica que los modos cambian correctamente de 2 → 3 → 0
                        según los ciclos dentro de la línea (0-79: Mode 2, 80-251: Mode 3, 252-455: Mode 0).</li>
                    <li><strong>Modo V-Blank</strong>: Verifica que las líneas 144-153 están siempre en Mode 1, independientemente de los ciclos.</li>
                    <li><strong>Reinicio de modo en nueva línea</strong>: Verifica que al inicio de cada nueva línea visible, el modo se reinicia a Mode 2.</li>
                    <li><strong>Lectura de STAT</strong>: Verifica que el registro STAT devuelve el modo correcto en bits 0-1.</li>
                    <li><strong>Escritura en STAT</strong>: Verifica que escribir en STAT preserva los bits configurables (2-6) pero ignora bits 0-1.</li>
                    <li><strong>Múltiples líneas</strong>: Verifica que el ciclo de modos se repite correctamente en múltiples líneas visibles.</li>
                </ul>
                <p>
                    <strong>Código del test (fragmento esencial)</strong>:
                </p>
                <pre><code>def test_mode_transitions_visible_line(self) -> None:
    """Test: Los modos cambian correctamente durante una línea visible."""
    mmu = MMU(None)
    ppu = PPU(mmu)
    mmu.set_ppu(ppu)
    
    # Al inicio de la línea, debe ser Mode 2 (OAM Search)
    assert ppu.get_mode() == PPU_MODE_2_OAM_SEARCH
    
    # Avanzar 80 ciclos -> debe cambiar a Mode 3
    ppu.step(80)
    assert ppu.get_mode() == PPU_MODE_3_PIXEL_TRANSFER
    
    # Avanzar 172 ciclos más -> debe cambiar a Mode 0
    ppu.step(172)
    assert ppu.get_mode() == PPU_MODE_0_HBLANK</code></pre>
                <p>
                    <strong>Por qué este test demuestra algo del hardware</strong>: El hardware de la Game Boy divide cada línea de 456 ciclos
                    en 3 modos distintos (OAM Search, Pixel Transfer, H-Blank) con timing específico. Este test verifica que la emulación
                    respeta estos tiempos exactos, lo cual es crítico porque los juegos hacen polling de STAT para saber cuándo pueden acceder
                    a VRAM de forma segura. Si el timing es incorrecto, los juegos pueden intentar escribir en VRAM durante Pixel Transfer,
                    causando corrupción de datos o comportamiento impredecible.
                </p>

                <h3>Validación con ROM Real (Pendiente)</h3>
                <p>
                    <strong>Próximo paso</strong>: Ejecutar una ROM real (Tetris DX, Pokémon Red, etc.) para verificar que el juego detecta
                    correctamente los cambios de modo en STAT y puede continuar con la inicialización. Se espera que el juego encienda el
                    LCD (LCDC=0x80 o 0x91) después de detectar que la PPU está en un modo seguro.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li><strong>Pan Docs</strong>: LCD Status Register (STAT) - Descripción completa del registro STAT, bits 0-6, interrupciones basadas en modos</li>
                    <li><strong>Pan Docs</strong>: PPU Modes - Descripción de los 4 modos PPU (Mode 0, 1, 2, 3), timing de cada modo dentro de una línea</li>
                    <li><strong>Pan Docs</strong>: LCD Timing - Timing de scanlines (456 T-Cycles por línea), líneas visibles (0-143), V-Blank (144-153)</li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Máquina de Estados PPU</strong>: La PPU no es un componente estático que solo cuenta líneas. Es una máquina
                            de estados que cambia dinámicamente entre 4 modos según el timing de la línea. Los juegos dependen críticamente
                            de estos cambios de modo para saber cuándo pueden acceder a VRAM de forma segura.</li>
                        <li><strong>Registro STAT como interfaz de comunicación</strong>: STAT no es solo un registro de estado, es una interfaz
                            de comunicación entre la CPU y la PPU. Los juegos leen STAT constantemente para sincronizarse con el renderizado
                            y evitar escribir en VRAM durante Pixel Transfer (que causaría corrupción de datos).</li>
                        <li><strong>Bloqueo de acceso a VRAM</strong>: Durante Mode 3 (Pixel Transfer), la CPU está bloqueada de acceder a VRAM
                            porque la PPU está leyendo activamente tiles y datos de paleta. Si la CPU intenta escribir durante este modo, puede
                            causar artefactos visuales o comportamiento impredecible. El hardware real bloquea físicamente el acceso, pero en un
                            emulador debemos simular esto actualizando STAT correctamente para que los juegos sepan cuándo no deben escribir.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>LYC=LY Coincidence Flag (bit 2 de STAT)</strong>: Aún no está implementado. Este bit se activa cuando LY == LYC
                            (LY Compare, registro 0xFF45). Los juegos pueden usar esto para generar interrupciones en líneas específicas (efectos
                            de scroll, splits de pantalla, etc.).</li>
                        <li><strong>Interrupciones basadas en modos STAT</strong>: Los bits 3-6 de STAT permiten habilitar interrupciones cuando la PPU
                            entra en un modo específico. Aún no está implementado el sistema de interrupciones STAT, solo el registro es legible/escritable.</li>
                        <li><strong>Bloqueo real de acceso a VRAM</strong>: Actualmente solo actualizamos STAT, pero no bloqueamos físicamente el acceso
                            a VRAM durante Mode 3. En hardware real, escribir en VRAM durante Pixel Transfer puede causar artefactos. En un emulador
                            preciso, deberíamos detectar estos accesos y manejarlos apropiadamente (ignorar, retrasar, o generar artefactos visuales).</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Timing de modos</strong>: Los tiempos exactos de cada modo (80, 172, 204 ciclos) están basados en Pan Docs, pero no
                        he verificado con hardware real o test ROMs si estos tiempos son exactos o si hay variaciones. En hardware real, el timing
                        puede variar ligeramente según el contenido renderizado (número de sprites, complejidad del tilemap, etc.), pero para un
                        emulador básico, usar tiempos fijos es una aproximación razonable.
                    </p>
                    <p>
                        <strong>Actualización de modo durante step()</strong>: Actualizo el modo antes y después de procesar líneas completas para
                        asegurar que siempre refleje el estado actual. Esto puede no ser exactamente cómo funciona el hardware real (que actualiza
                        el modo continuamente), pero es una aproximación suficiente para que los juegos detecten los cambios de modo correctamente.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Validar con ROM real (Tetris DX, Pokémon Red) que el juego detecta correctamente los cambios de modo y enciende el LCD</li>
                    <li>[ ] Implementar LYC=LY Coincidence Flag (bit 2 de STAT) para permitir interrupciones en líneas específicas</li>
                    <li>[ ] Implementar interrupciones basadas en modos STAT (bits 3-6) para que los juegos puedan usar interrupciones H-Blank, OAM Search, etc.</li>
                    <li>[ ] Considerar bloqueo real de acceso a VRAM durante Mode 3 (Pixel Transfer) para mayor precisión</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

