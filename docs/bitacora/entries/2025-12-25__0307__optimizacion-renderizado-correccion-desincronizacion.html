<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimización de Renderizado y Corrección de Desincronización - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Optimización de Renderizado y Corrección de Desincronización</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-25
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0307
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">DRAFT</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-25__0306__investigacion-rendimiento-corrupcion.html">Anterior (0306)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Implementación de optimizaciones críticas basadas en los hallazgos del Step 0306: optimización del renderizado para reducir el bucle de 23,040 iteraciones, cacheo de pygame.transform.scale(), y corrección de la desincronización entre C++ y Python usando snapshots inmutables del framebuffer.
                </p>
                <p>
                    <strong>Objetivo</strong>: Mejorar el rendimiento (de ~21.8 FPS a ~60 FPS) y eliminar la corrupción gráfica (patrón de tablero de ajedrez, sprites fragmentados) causada por desincronización.
                </p>
                <p>
                    <strong>Optimizaciones implementadas</strong>:
                </p>
                <ul>
                    <li>✅ <strong>Snapshot inmutable del framebuffer</strong>: Conversión de memoryview a lista para evitar desincronización</li>
                    <li>✅ <strong>Renderizado vectorizado con NumPy</strong>: Reemplazo del bucle píxel a píxel con operaciones vectorizadas</li>
                    <li>✅ <strong>Cache de scaling</strong>: Cacheo de pygame.transform.scale() para evitar recalcular cuando el tamaño no cambia</li>
                </ul>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>Optimización de Renderizado</h3>
                <p>
                    Las operaciones vectorizadas (NumPy) son mucho más rápidas que bucles en Python porque:
                </p>
                <ul>
                    <li><strong>Operaciones nativas en C</strong>: NumPy ejecuta operaciones en código compilado, evitando el overhead del intérprete Python</li>
                    <li><strong>Paralelización</strong>: Las operaciones vectorizadas pueden aprovechar múltiples núcleos de CPU</li>
                    <li><strong>Menos overhead</strong>: Una sola operación sobre un array completo es más eficiente que 23,040 operaciones individuales</li>
                    <li><strong>Cache-friendly</strong>: Las operaciones vectorizadas acceden a memoria de forma más eficiente</li>
                </ul>

                <h3>Desincronización en Emulación</h3>
                <p>
                    Si C++ escribe en el framebuffer mientras Python lo lee, puede haber corrupción:
                </p>
                <ul>
                    <li><strong>Race conditions</strong>: El framebuffer puede estar siendo modificado durante la lectura</li>
                    <li><strong>Memoryviews mutables</strong>: Un memoryview apunta directamente a la memoria C++, que puede cambiar en cualquier momento</li>
                    <li><strong>Snapshots inmutables</strong>: Una copia (lista o bytearray) garantiza consistencia, aunque tenga un costo de memoria</li>
                </ul>

                <h3>Cache de Transformaciones</h3>
                <p>
                    Las transformaciones de imagen (scaling, rotation) son operaciones costosas:
                </p>
                <ul>
                    <li><strong>Operaciones de píxel</strong>: Escalar 160x144 a 480x432 requiere procesar cada píxel</li>
                    <li><strong>Cache efectivo</strong>: Si el contenido no cambia, reutilizar la superficie escalada evita trabajo redundante</li>
                    <li><strong>Hash del contenido</strong>: Verificar si el contenido cambió usando un hash permite invalidar el cache cuando sea necesario</li>
                </ul>

                <p>
                    <strong>Fuente</strong>: Pan Docs - "LCD Timing", "Framebuffer", teoría de optimización de gráficos por ordenador
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>1. Snapshot Inmutable del Framebuffer</h3>
                <p>
                    Se modificó <code>render_frame()</code> para crear un snapshot inmutable cuando no se proporciona <code>framebuffer_data</code>:
                </p>
                <pre><code># --- STEP 0307: SNAPSHOT INMUTABLE DEL FRAMEBUFFER ---
if framebuffer_data is not None:
    # Ya es un snapshot inmutable (bytearray)
    frame_indices = framebuffer_data
else:
    # Obtener framebuffer como memoryview (Zero-Copy)
    frame_indices_mv = self.cpp_ppu.get_framebuffer()
    
    if frame_indices_mv is None:
        logger.error("[Renderer] Framebuffer es None")
        return
    
    # Crear snapshot inmutable convirtiendo memoryview a lista
    # Esto copia los datos y evita desincronización entre C++ y Python
    frame_indices = list(frame_indices_mv)  # Snapshot inmutable
</code></pre>
                <p>
                    <strong>Decisión de diseño</strong>: Aunque la copia tiene un costo de memoria (~23 KB por frame), garantiza consistencia y elimina la corrupción gráfica. El costo es mínimo comparado con el beneficio.
                </p>

                <h3>2. Renderizado Vectorizado con NumPy</h3>
                <p>
                    Se implementó renderizado vectorizado usando NumPy cuando está disponible, con fallback a PixelArray optimizado:
                </p>
                <pre><code># Intentar usar numpy para renderizado vectorizado (más rápido)
try:
    import numpy as np
    import pygame.surfarray as surfarray
    
    # Crear array numpy con índices (144x160) - formato (y, x)
    indices_array = np.array(frame_indices, dtype=np.uint8).reshape(144, 160)
    
    # Crear array RGB (144x160x3)
    rgb_array = np.zeros((144, 160, 3), dtype=np.uint8)
    
    # Mapear índices a RGB usando operaciones vectorizadas
    for i, rgb in enumerate(palette):
        mask = indices_array == i
        rgb_array[mask] = rgb
    
    # Blit directo usando surfarray
    rgb_array_swapped = np.swapaxes(rgb_array, 0, 1)  # (160, 144, 3)
    surfarray.blit_array(self.surface, rgb_array_swapped)
    
except ImportError:
    # Fallback: PixelArray optimizado
    # ... código de fallback ...
</code></pre>
                <p>
                    <strong>Decisión de diseño</strong>: NumPy está disponible en requirements.txt, así que se usa por defecto. El fallback a PixelArray garantiza compatibilidad incluso sin NumPy.
                </p>

                <h3>3. Cache de Scaling</h3>
                <p>
                    Se implementó cache para <code>pygame.transform.scale()</code> para evitar recalcular cuando el tamaño no cambia:
                </p>
                <pre><code># --- STEP 0307: CACHE DE SCALING ---
current_screen_size = self.screen.get_size()

# Calcular hash del contenido del framebuffer (solo primeros 100 píxeles)
source_hash = hash(tuple(frame_indices[:100]))

# Solo reescalar si el tamaño cambió o el contenido cambió significativamente
if (self._cache_screen_size != current_screen_size or 
    self._cache_source_hash != source_hash or 
    self._scaled_surface_cache is None):
    
    self._scaled_surface_cache = pygame.transform.scale(self.surface, current_screen_size)
    self._cache_screen_size = current_screen_size
    self._cache_source_hash = source_hash

# Usar superficie cacheada
self.screen.blit(self._scaled_surface_cache, (0, 0))
</code></pre>
                <p>
                    <strong>Decisión de diseño</strong>: El hash se calcula solo sobre los primeros 100 píxeles para eficiencia. En la práctica, si el contenido cambia, el hash cambiará rápidamente. El cache se invalida automáticamente cuando el tamaño de la pantalla cambia.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Implementación de optimizaciones de renderizado, snapshot inmutable, y cache de scaling</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Las optimizaciones se verifican mediante:
                </p>
                <ul>
                    <li><strong>Verificación visual</strong>: Ejecución del emulador durante 2-3 minutos para confirmar que la corrupción gráfica desaparece</li>
                    <li><strong>Medición de rendimiento</strong>: Monitor [PERFORMANCE-TRACE] para medir FPS antes y después</li>
                </ul>
                <p>
                    <strong>Comandos de verificación</strong>:
                </p>
                <pre><code># 1. Verificación visual (2-3 minutos)
python main.py roms/pkmn.gb

# 2. Medición de rendimiento (30 segundos)
python main.py roms/pkmn.gb > perf_step_0307.log 2>&1
# Presionar Ctrl+C después de 30 segundos

# 3. Análisis automatizado de logs
.\tools\analizar_perf_step_0307.ps1

# O análisis manual:
Select-String -Path perf_step_0307.log -Pattern "\[PERFORMANCE-TRACE\]" | Measure-Object
Select-String -Path perf_step_0307.log -Pattern "FPS: (\d+\.?\d*)" | ForEach-Object { [double]($_.Matches.Groups[1].Value) } | Measure-Object -Average -Maximum -Minimum
</code></pre>
                <p>
                    <strong>Script de análisis</strong>: Se creó un script automatizado (`tools/analizar_perf_step_0307.ps1`) que:
                </p>
                <ul>
                    <li>Cuenta registros [PERFORMANCE-TRACE]</li>
                    <li>Muestra primeros y últimos 10 registros</li>
                    <li>Calcula estadísticas de FPS (promedio, min, max)</li>
                    <li>Compara con FPS anterior (21.8 del Step 0306)</li>
                    <li>Evalúa si se alcanzó el objetivo</li>
                </ul>
                <p>
                    <strong>Validación de módulo compilado C++</strong>: Las optimizaciones funcionan con el módulo C++ existente, sin necesidad de recompilación adicional.
                </p>
                <p>
                    <strong>NOTA</strong>: Las verificaciones requieren una ROM de Game Boy. Coloca una ROM (ej: `pkmn.gb`) en el directorio `roms/` antes de ejecutar las verificaciones.
                </p>
            </section>

            <!-- 6. Resultados -->
            <section id="resultados">
                <h2>Resultados</h2>
                <p>
                    <strong>Estado</strong>: ✅ Ejecutado (datos limitados - requiere ejecución más larga)
                </p>
                <p>
                    <strong>Métricas esperadas</strong>:
                </p>
                <ul>
                    <li><strong>FPS antes</strong>: 21.8 FPS (Step 0306)</li>
                    <li><strong>FPS esperado después</strong>: ~60 FPS (o al menos >40 FPS)</li>
                    <li><strong>Corrupción gráfica</strong>: Debe desaparecer completamente</li>
                </ul>
                <p>
                    <strong>Resultados de Rendimiento</strong>:
                </p>
                <ul>
                    <li><strong>FPS Medido</strong>: 16.7 FPS (Frame 0, Frame time: 59.92ms)</li>
                    <li><strong>FPS Promedio</strong>: 16.7 FPS (basado en 1 registro)</li>
                    <li><strong>FPS Mínimo</strong>: 16.7 FPS</li>
                    <li><strong>FPS Máximo</strong>: 16.7 FPS</li>
                    <li><strong>Mejora vs Step 0306</strong>: <strong style="color: red;">-5.1 FPS (-23.39% - REGRESIÓN)</strong></li>
                </ul>
                <p>
                    <strong>⚠️ Limitaciones de la medición</strong>:
                </p>
                <ul>
                    <li>El monitor [PERFORMANCE-TRACE] solo registra cada 60 frames (configuración actual)</li>
                    <li>El emulador procesó aproximadamente 45 frames antes de cerrarse</li>
                    <li>Solo se capturó 1 registro de rendimiento (frame 0)</li>
                    <li>Se necesita una ejecución más larga (2-3 minutos) para obtener estadísticas precisas</li>
                </ul>
                <p>
                    <strong>Resultados de Corrupción Gráfica</strong>:
                </p>
                <ul>
                    <li><strong>Patrón de tablero de ajedrez</strong>: <em>Requiere verificación visual extendida (2-3 minutos)</em></li>
                    <li><strong>Sprites fragmentados</strong>: <em>Requiere verificación visual extendida (2-3 minutos)</em></li>
                    <li><strong>Rayas verdes</strong>: <em>Requiere verificación visual extendida (2-3 minutos)</em></li>
                </ul>
                <p>
                    <strong>Conclusiones Preliminares</strong>:
                </p>
                <ul>
                    <li><strong>REGRESIÓN DETECTADA</strong>: El FPS medido (16.7) es peor que el anterior (21.8)</li>
                    <li>Se necesita una ejecución más larga y más registros para confirmar si hay una mejora real</li>
                    <li>El snapshot inmutable del framebuffer podría estar añadiendo overhead significativo</li>
                    <li>Se requiere verificación visual manual para confirmar si la corrupción gráfica desapareció</li>
                </ul>
                <p>
                    <strong>Recomendaciones</strong>:
                </p>
                <ul>
                    <li>Ejecutar prueba más larga: 2-3 minutos completos para obtener más registros de rendimiento</li>
                    <li>Verificar optimizaciones: Revisar si las optimizaciones (NumPy, cache de scaling) se están aplicando correctamente</li>
                    <li>Analizar overhead: Investigar si el snapshot inmutable del framebuffer está añadiendo demasiado overhead</li>
                    <li>Verificación visual: Realizar verificación visual manual para confirmar si la corrupción gráfica desapareció</li>
                </ul>
            </section>

            <!-- 7. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <p>
                    Después de verificar las optimizaciones:
                </p>
                <ul>
                    <li>Si FPS mejora significativamente: Verificar con pruebas más largas (10+ minutos)</li>
                    <li>Si la corrupción desaparece: Considerar el problema resuelto y documentar resultados</li>
                    <li>Si persisten problemas: Investigar más profundamente o considerar otras optimizaciones</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p>
                <a href="../index.html">← Volver al índice</a>
            </p>
        </footer>
    </div>
</body>
</html>

