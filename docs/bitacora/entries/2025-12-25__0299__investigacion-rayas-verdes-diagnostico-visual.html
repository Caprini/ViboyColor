<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investigación de Rayas Verdes y Diagnóstico Visual - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Investigación de Rayas Verdes y Diagnóstico Visual</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-25
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0299
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-25__0298__ejecucion-interaccion-decision-enfoque.html">Anterior (0298)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Implementación de 4 monitores de diagnóstico visual para investigar por qué el emulador muestra rayas verticales verdes
                    en lugar de gráficos. Los monitores capturan el contenido real del framebuffer, los tile IDs del tilemap, los datos de tiles
                    leídos de VRAM, y la aplicación de la paleta durante el renderizado de la línea central (LY=72).
                </p>
                <p>
                    <strong>Objetivo</strong>: Identificar la causa raíz del patrón de rayas verdes mediante análisis de los datos reales
                    que se están procesando durante el renderizado.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                
                <h3>Patrones Visuales en Game Boy</h3>
                <p>
                    Las rayas verticales en el Game Boy suelen aparecer cuando:
                </p>
                <ul>
                    <li><strong>Tilemap con valores repetidos</strong>: El tilemap contiene el mismo tile ID repetido en columnas, generando un patrón vertical</li>
                    <li><strong>Tiles vacíos con paleta visible</strong>: Los tiles están vacíos (0x00) pero la paleta genera colores visibles (verde)</li>
                    <li><strong>Cálculo incorrecto de direcciones</strong>: El cálculo de direcciones de tiles es incorrecto, generando lecturas repetitivas del mismo tile</li>
                    <li><strong>Scroll generando patrón</strong>: El scroll (SCX/SCY) está generando un patrón repetitivo en las direcciones calculadas</li>
                </ul>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Tile Data", "Background", "Palette"
                </p>

                <h3>Framebuffer y Paleta</h3>
                <p>
                    El framebuffer contiene <strong>índices de color (0-3)</strong>, no colores RGB directamente.
                    La paleta BGP (Background Palette) mapea estos índices a colores finales:
                </p>
                <ul>
                    <li>Índice 0 → Color 0 (Blanco por defecto)</li>
                    <li>Índice 1 → Color 1 (Gris claro por defecto)</li>
                    <li>Índice 2 → Color 2 (Gris oscuro por defecto)</li>
                    <li>Índice 3 → Color 3 (Negro por defecto)</li>
                </ul>
                <p>
                    El renderer de Python aplica una paleta debug que mapea estos índices a RGB. Si el framebuffer contiene
                    índices repetitivos, se verán rayas del color correspondiente.
                </p>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Background Palette (BGP)", "LCD Display"
                </p>

                <h3>Renderizado de Tiles</h3>
                <p>
                    Cada tile tiene 8x8 píxeles. Cada píxel se codifica con 2 bits (4 colores posibles: 0, 1, 2, 3).
                    Dos bytes consecutivos en VRAM representan una línea de 8 píxeles:
                </p>
                <ul>
                    <li>Byte 1: Bit bajo de cada píxel (LSB)</li>
                    <li>Byte 2: Bit alto de cada píxel (MSB)</li>
                </ul>
                <p>
                    Si un tile está vacío (0x00 en ambos bytes), todos los píxeles serán color_index 0, que con la paleta
                    estándar se mapea a blanco. Sin embargo, si la paleta está configurada de manera diferente, podría
                    generar colores verdes.
                </p>
                <p>
                    <strong>Fuente</strong>: Pan Docs - "Tile Data", "Tile Format"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Monitores de Diagnóstico Visual</h3>
                <p>
                    Se implementaron 4 monitores de diagnóstico visual en <code>src/core/cpp/PPU.cpp</code> dentro de la función
                    <code>render_scanline()</code>. Todos los monitores se activan durante el renderizado de la línea central (LY=72)
                    y capturan datos de los primeros 32 píxeles/tiles para no saturar los logs.
                </p>

                <h4>1. Monitor de Framebuffer Real ([FRAMEBUFFER-DUMP])</h4>
                <p>
                    Captura el contenido real del framebuffer después de renderizar la línea central. Muestra los índices de color
                    (0-3) que se escribieron en el framebuffer para los primeros 32 píxeles.
                </p>
                <pre><code>// Al final del renderizado de la línea 72
static int framebuffer_dump_count = 0;
if (ly_ == 72 && framebuffer_dump_count < 3) {
    printf("[FRAMEBUFFER-DUMP] Frame %d, LY:72 | First 32 pixels (indices 0-31):\n", 
           framebuffer_dump_count + 1);
    for(int x_dump = 0; x_dump < 32; x_dump++) {
        printf("%02X ", framebuffer_[line_start_index + x_dump]);
        if ((x_dump + 1) % 16 == 0) printf("\n");
    }
    printf("\n");
    framebuffer_dump_count++;
}</code></pre>

                <h4>2. Monitor de Tilemap Real ([TILEMAP-DUMP-VISUAL])</h4>
                <p>
                    Captura los tile IDs reales que se están leyendo del tilemap durante el renderizado de la línea central.
                    Muestra los primeros 32 tile IDs leídos del tilemap.
                </p>
                <pre><code>// Antes del loop de renderizado, cuando ly_ == 72
static int tilemap_dump_count = 0;
if (ly_ == 72 && tilemap_dump_count < 3) {
    printf("[TILEMAP-DUMP-VISUAL] Frame %d, LY:72 | First 32 tile IDs:\n", 
           tilemap_dump_count + 1);
    for(int x_dump = 0; x_dump < 32; x_dump++) {
        uint8_t map_x_dump = (x_dump + scx) & 0xFF;
        uint8_t map_y_dump = (ly_ + scy) & 0xFF;
        uint16_t tile_map_addr_dump = tile_map_base + (map_y_dump / 8) * 32 + (map_x_dump / 8);
        uint8_t tile_id_dump = mmu_->read(tile_map_addr_dump);
        printf("%02X ", tile_id_dump);
        if ((x_dump + 1) % 16 == 0) printf("\n");
    }
    printf("\n");
    tilemap_dump_count++;
}</code></pre>

                <h4>3. Monitor de Datos de Tiles Reales ([TILEDATA-DUMP-VISUAL])</h4>
                <p>
                    Captura los datos reales de los tiles que se están leyendo de VRAM durante el renderizado. Muestra los bytes
                    de los primeros 4 tiles (cada 8 píxeles) leídos de VRAM.
                </p>
                <pre><code>// Dentro del loop de renderizado, cuando se lee de VRAM
static int tiledata_dump_count = 0;
if (ly_ == 72 && x < 32 && tiledata_dump_count < 3) {
    if (x % 8 == 0) {  // Cada 8 píxeles (un tile completo)
        uint8_t tile_index = x / 8;
        if (tile_index < 4) {
            printf("[TILEDATA-DUMP-VISUAL] Frame %d | Tile %d (ID:%02X) | Addr:%04X | Line:%d | Bytes: %02X %02X\n",
                   tiledata_dump_count + 1, tile_index, tile_id, tile_line_addr, line_in_tile, byte1, byte2);
        }
    }
}
if (ly_ == 72 && x == 31) tiledata_dump_count++;</code></pre>

                <h4>4. Monitor de Paleta Aplicada ([PALETTE-DUMP-VISUAL])</h4>
                <p>
                    Captura la aplicación de la paleta BGP para ver qué colores finales se generan. Muestra el mapeo
                    color_index → final_color para los primeros 32 píxeles.
                </p>
                <pre><code>// Dentro del loop de renderizado, después de aplicar la paleta
static int palette_dump_count = 0;
if (ly_ == 72 && x < 32 && palette_dump_count < 3) {
    if (x == 0) {
        printf("[PALETTE-DUMP-VISUAL] Frame %d, LY:72 | BGP:0x%02X | First 32 pixels (ColorIndex -> FinalColor):\n",
               palette_dump_count + 1, bgp);
    }
    printf("(%d->%d) ", color_index, final_color);
    if ((x + 1) % 16 == 0) printf("\n");
}
if (ly_ == 72 && x == 31) palette_dump_count++;</code></pre>

                <h3>Decisiones de Diseño</h3>
                <ul>
                    <li><strong>Línea central (LY=72)</strong>: Se eligió la línea central porque es representativa del contenido visible y evita bordes que podrían tener comportamientos especiales</li>
                    <li><strong>Primeros 32 píxeles/tiles</strong>: Se limita a 32 para no saturar los logs, pero es suficiente para identificar patrones repetitivos</li>
                    <li><strong>Límite de 3 frames</strong>: Cada monitor solo se activa en los primeros 3 frames para evitar saturación de logs</li>
                    <li><strong>Formato hexadecimal</strong>: Los datos se muestran en hexadecimal para facilitar la identificación de patrones</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/core/cpp/PPU.cpp</code> - Añadidos 4 monitores de diagnóstico visual en <code>render_scanline()</code></li>
                    <li><code>ANALISIS_RAYAS_VERDES_STEP_0299.md</code> - Documento de análisis (nuevo, template para completar después de ejecución)</li>
                    <li><code>docs/bitacora/entries/2025-12-25__0299__investigacion-rayas-verdes-diagnostico-visual.html</code> - Entrada HTML de bitácora</li>
                    <li><code>docs/bitacora/index.html</code> - Actualizado con entrada 0299</li>
                    <li><code>INFORME_FASE_2.md</code> - Actualizado con Step 0299</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    Los monitores se validarán ejecutando el emulador y analizando los logs generados:
                </p>
                <ul>
                    <li><strong>Compilación</strong>: Los monitores se compilaron sin errores con C++17</li>
                    <li><strong>Ejecución</strong>: Pendiente de ejecutar el emulador para capturar logs</li>
                    <li><strong>Análisis</strong>: Pendiente de analizar los logs para identificar patrones</li>
                </ul>
                <p>
                    <strong>Comando para ejecutar y capturar logs</strong>:
                </p>
                <pre><code>python main.py --rom roms/pokemon_red.gb > logs/diagnostico_rayas_0299.log 2>&1</code></pre>
                <p>
                    <strong>Análisis de logs</strong>: Se analizarán los logs usando el documento <code>ANALISIS_RAYAS_VERDES_STEP_0299.md</code>
                    para identificar la causa raíz del patrón de rayas verdes.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Data.html">Tile Data</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Background.html">Background</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Palette.html">Palette</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/LCD_Display.html">LCD Display</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Patrones visuales</strong>: Las rayas verticales pueden originarse en diferentes puntos del pipeline de renderizado (tilemap, tiles, paleta)</li>
                        <li><strong>Framebuffer</strong>: Contiene índices de color, no colores RGB directamente. La paleta mapea estos índices a colores finales</li>
                        <li><strong>Diagnóstico visual</strong>: Capturar datos en múltiples puntos del pipeline permite identificar dónde se origina un patrón visual</li>
                        <li><strong>Límites de logs</strong>: Es crítico limitar la cantidad de logs para no saturar el contexto y mantener el rendimiento</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Patrón real</strong>: Qué índice de color genera el verde oscuro y cuál el verde claro</li>
                        <li><strong>Origen del patrón</strong>: Si viene del tilemap, los tiles, o la paleta</li>
                        <li><strong>Causa raíz</strong>: Por qué se genera el patrón repetitivo</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        Se han formulado 4 hipótesis sobre el origen de las rayas verdes:
                    </p>
                    <ol>
                        <li><strong>Hipótesis A</strong>: Tilemap con valores repetidos</li>
                        <li><strong>Hipótesis B</strong>: Tiles vacíos con paleta verde</li>
                        <li><strong>Hipótesis C</strong>: Cálculo incorrecto de direcciones</li>
                        <li><strong>Hipótesis D</strong>: Scroll generando patrón</li>
                    </ol>
                    <p>
                        Los monitores implementados permitirán confirmar o rechazar estas hipótesis después de ejecutar el emulador
                        y analizar los logs.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y capturar logs de los 4 monitores</li>
                    <li>[ ] Analizar los logs para identificar patrones en framebuffer, tilemap, tiles y paleta</li>
                    <li>[ ] Confirmar o rechazar las 4 hipótesis sobre el origen de las rayas verdes</li>
                    <li>[ ] Identificar la causa raíz del patrón</li>
                    <li>[ ] Implementar corrección basada en los hallazgos (si aplica)</li>
                    <li>[ ] Completar el documento <code>ANALISIS_RAYAS_VERDES_STEP_0299.md</code> con los resultados</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

