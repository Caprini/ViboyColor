<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 0258: VRAM Vital Signs - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Step 0258: VRAM Vital Signs (VRAM Sum)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-23
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0258
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-23__0257__hardware-palette-bypass.html">Anterior (0257)</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Este Step añade un diagnóstico de integridad de VRAM en el monitor GPS de `src/viboy.py`. Calculamos la suma de bytes de la VRAM (muestreo cada 16 bytes) para determinar si contiene gráficos o está completamente vacía. Si la VRAM está llena de ceros, la PPU renderizará píxeles de índice 0 (verdes/blancos), funcionando "correctamente" sobre datos vacíos.
                </p>
                <p>
                    Con la paleta forzada en C++ (Step 0257) y Python (Step 0256), si la pantalla sigue verde incluso con juegos que tienen el LCD encendido (como Pokémon Red, `LCDC:E3`), la única explicación lógica que queda es que <strong>la VRAM está llena de ceros</strong>. Si la VRAM es todo 0, la PPU dibuja el "Color 0" perfectamente, que es... verde.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    La VRAM (Video RAM) en la Game Boy ocupa el rango `0x8000-0x9FFF` (8KB) y contiene:
                </p>
                <ul>
                    <li><strong>Tile Data (0x8000-0x97FF):</strong> Datos de los tiles (gráficos) que se usan para renderizar el fondo y los sprites. Cada tile ocupa 16 bytes (2 bytes por línea de 8 píxeles).</li>
                    <li><strong>Tile Map (0x9800-0x9FFF):</strong> Mapas de tiles que indican qué tile se dibuja en cada posición del fondo. Cada byte del mapa apunta a un tile en el Tile Data.</li>
                </ul>
                <p>
                    <strong>Problema Crítico:</strong> Si la VRAM está completamente vacía (todo ceros), la PPU renderizará píxeles de índice 0 (que corresponde al color más claro de la paleta). Con la paleta de debug de Python (Step 0256), el índice 0 se mapea a verde/blanco, lo que explica por qué vemos una pantalla completamente verde incluso cuando el LCD está encendido.
                </p>
                <p>
                    <strong>Diagnóstico de VRAM:</strong> Al calcular la suma de bytes de la VRAM (usando un muestreo cada 16 bytes para no matar el rendimiento), podemos determinar:
                </p>
                <ul>
                    <li><strong>Sum = 0:</strong> La VRAM está vacía. El juego no ha copiado gráficos. Esto indica un problema de CPU/DMA (el juego no está ejecutando el código que copia los tiles desde la ROM a la VRAM).</li>
                    <li><strong>Sum > 0:</strong> Hay datos en la VRAM. Si la pantalla sigue verde, el problema está en la PPU (no está leyendo correctamente los tiles desde VRAM) o en el mapeo de tiles (Tile Map apunta a tiles vacíos).</li>
                </ul>
                <p>
                    <strong>Fuente:</strong> Pan Docs - VRAM, Tile Data, Tile Maps
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                <p>
                    Se modificó el monitor GPS en `src/viboy.py` para añadir un cálculo de suma de VRAM después de los logs de `[VIDEO]` y `[SPRITE]`:
                </p>
                
                <h3>Modificación en `src/viboy.py` (Monitor GPS)</h3>
                <p>
                    Se añadió código para calcular la suma de bytes de la VRAM usando un muestreo cada 16 bytes:
                </p>
                <pre><code># --- Step 0258: VRAM CHECKSUM ---
# Leer muestras masivas para ver si hay vida
# Nota: Esto es lento, pero solo ocurre 1 vez por segundo

vram_sum = 0
# Muestreo rápido: leer cada 16 bytes para no matar el rendimiento
for addr in range(0x8000, 0xA000, 16):
    vram_sum += self._mmu.read(addr)

logger.info(f"[MEMORY] VRAM_SUM: {vram_sum} (Si es 0, no hay gráficos)")
# -------------------------------------------------</code></pre>

                <p>
                    Este código se añadió tanto en el bloque de C++ como en el bloque de Python (fallback) del monitor GPS, justo después de los logs de `[VIDEO]` y `[SPRITE]`.
                </p>

                <h3>Decisiones de Diseño</h3>
                <ul>
                    <li><strong>Muestreo cada 16 bytes:</strong> Se eligió leer cada 16 bytes en lugar de todos los bytes para no matar el rendimiento. El muestreo es suficiente para detectar si la VRAM está completamente vacía (suma = 0) o contiene datos (suma > 0).</li>
                    <li><strong>Frecuencia de ejecución:</strong> El diagnóstico se ejecuta solo una vez por segundo (cada 60 frames), igual que el resto del monitor GPS, para no impactar el rendimiento.</li>
                    <li><strong>Log claro:</strong> Se usa un mensaje de log claro que indica explícitamente que si la suma es 0, no hay gráficos en la VRAM.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/viboy.py</code> - Modificado el monitor GPS (Step 0240) para añadir cálculo de suma de VRAM (Step 0258).</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Validación de Diagnóstico:</strong>
                </p>
                <ol>
                    <li><strong>Ejecución:</strong> Ejecutar <code>python main.py roms/pkmn.gb</code> (o cualquier ROM con LCD encendido).</li>
                    <li><strong>Observación del Log:</strong> Buscar en el log el mensaje <code>[MEMORY] VRAM_SUM: X</code> cada segundo.</li>
                    <li><strong>Interpretación:</strong>
                        <ul>
                            <li><strong>Si X = 0:</strong> La VRAM está vacía. El juego no ha copiado gráficos. Esto indica un problema de CPU/DMA (el juego no está ejecutando el código que copia los tiles desde la ROM a la VRAM).</li>
                            <li><strong>Si X > 0:</strong> Hay datos en la VRAM. Si la pantalla sigue verde, el problema está en la PPU (no está leyendo correctamente los tiles desde VRAM) o en el mapeo de tiles (Tile Map apunta a tiles vacíos).</li>
                        </ul>
                    </li>
                </ol>
                <p>
                    <strong>Comando de Prueba:</strong>
                </p>
                <pre><code>python main.py roms/pkmn.gb</code></pre>
                <p>
                    <strong>Resultado Esperado:</strong> El log debe mostrar <code>[MEMORY] VRAM_SUM: X</code> cada segundo, donde X es un número que indica si hay datos en la VRAM.
                </p>
                <p>
                    <strong>Validación de Módulo Python:</strong> El código se ejecuta en Python puro, sin necesidad de recompilar módulos C++. El diagnóstico se integra directamente en el monitor GPS existente.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Video_Display.html">Video Display</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Data.html">Tile Data</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/Tile_Maps.html">Tile Maps</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Diagnóstico por Capas:</strong> Al añadir diagnósticos en diferentes capas (paleta en Step 0256/0257, VRAM en Step 0258), podemos aislar el problema: si la VRAM está vacía, el problema está en la CPU/DMA; si la VRAM contiene datos pero la pantalla sigue verde, el problema está en la PPU o en el mapeo de tiles.</li>
                        <li><strong>VRAM Vacía:</strong> Si la VRAM está completamente vacía (todo ceros), la PPU renderizará píxeles de índice 0 (que corresponde al color más claro de la paleta). Con la paleta de debug de Python, el índice 0 se mapea a verde/blanco, lo que explica por qué vemos una pantalla completamente verde.</li>
                        <li><strong>Muestreo de Memoria:</strong> Para diagnosticar grandes rangos de memoria sin matar el rendimiento, podemos usar muestreo (leer cada N bytes) en lugar de leer todos los bytes. Esto es suficiente para detectar si la memoria está completamente vacía o contiene datos.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Estado Real de VRAM:</strong> Ejecutar el diagnóstico con Pokémon Red (o cualquier ROM con LCD encendido) y verificar el valor de `VRAM_SUM`. Si es 0, confirmamos que la VRAM está vacía y el problema está en la CPU/DMA.</li>
                        <li><strong>Timing de Carga:</strong> Si la VRAM está vacía, debemos investigar por qué el juego no está copiando los tiles desde la ROM a la VRAM. Esto puede ser un problema de timing (el juego espera que algo ocurra antes de copiar) o un problema de DMA (el juego intenta usar DMA pero no está funcionando).</li>
                        <li><strong>Lectura de Tiles:</strong> Si la VRAM contiene datos pero la pantalla sigue verde, debemos investigar por qué la PPU no está leyendo correctamente los tiles desde VRAM o por qué el Tile Map apunta a tiles vacíos.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis Principal:</strong> Con la paleta forzada en C++ (Step 0257) y Python (Step 0256), si la pantalla sigue verde incluso con juegos que tienen el LCD encendido (como Pokémon Red, `LCDC:E3`), la única explicación lógica que queda es que la VRAM está llena de ceros. Si la VRAM es todo 0, la PPU dibuja el "Color 0" perfectamente, que es... verde.
                    </p>
                    <p>
                        <strong>Suposición:</strong> Asumimos que el diagnóstico de VRAM (suma de bytes) es suficiente para detectar si la VRAM está completamente vacía o contiene datos. Si la suma es 0, la VRAM está vacía; si la suma es > 0, hay datos en la VRAM.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar <code>python main.py roms/pkmn.gb</code> (¡Usa Pokémon o Mario, que sabemos que encienden el LCD!).</li>
                    <li>[ ] Observar el log y buscar <code>[MEMORY] VRAM_SUM: X</code> cada segundo.</li>
                    <li>[ ] <strong>Si X = 0:</strong>
                        <ul>
                            <li>Confirmar que la VRAM está vacía. El juego no ha copiado gráficos.</li>
                            <li>Investigar por qué el juego no está ejecutando el código que copia los tiles desde la ROM a la VRAM (problema de CPU/DMA).</li>
                            <li>Verificar que el juego está ejecutando correctamente (PC avanza, no está en un bucle infinito).</li>
                            <li>Verificar que DMA está funcionando (si el juego intenta usar DMA para copiar tiles).</li>
                        </ul>
                    </li>
                    <li>[ ] <strong>Si X > 0:</strong>
                        <ul>
                            <li>Confirmar que hay datos en la VRAM.</li>
                            <li>Si la pantalla sigue verde, investigar por qué la PPU no está leyendo correctamente los tiles desde VRAM.</li>
                            <li>Verificar que el Tile Map apunta a tiles válidos (no a tiles vacíos).</li>
                            <li>Verificar que la PPU está decodificando correctamente los tiles desde VRAM.</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

