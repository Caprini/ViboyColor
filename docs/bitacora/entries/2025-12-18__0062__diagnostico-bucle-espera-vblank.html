<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagn√≥stico: Bucle de Espera de V-Blank y Escrituras en VRAM - Viboy Color Bit√°cora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>‚ö†Ô∏è Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia c√≥digo de otros emuladores. Implementaci√≥n basada √∫nicamente en documentaci√≥n t√©cnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Diagn√≥stico: Bucle de Espera de V-Blank y Escrituras en VRAM</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2025-12-18
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0062
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-draft">Draft</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2025-12-18__0061__desbloqueo-vram-diagnostico-escrituras.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Tras confirmar que el juego no est√° escribiendo en VRAM (VRAM writes=0), se a√±adi√≥ un sistema
                    de diagn√≥stico peri√≥dico que muestra el estado completo del emulador cada 5 segundos. El diagn√≥stico
                    revel√≥ que el juego est√° en un bucle peque√±o (PC oscila entre 0x006B, 0x006D, 0x006F) ejecutando
                    muy pocas instrucciones (~60 por segundo), lo que impide que la PPU avance lo suficiente para
                    llegar a V-Blank (LY=144). El juego est√° esperando V-Blank antes de copiar gr√°ficos a VRAM,
                    pero nunca llega porque la PPU avanza demasiado lento.
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    En la Game Boy, la PPU (Pixel Processing Unit) avanza sincronizada con la CPU. Cada instrucci√≥n
                    de la CPU consume ciclos de reloj (M-Cycles), que se convierten a T-Cycles (ciclos de reloj del
                    sistema) para avanzar la PPU. La PPU necesita 456 T-Cycles para completar una l√≠nea de escaneo,
                    y 144 l√≠neas visibles + 10 l√≠neas de V-Blank = 154 l√≠neas por frame completo.
                </p>
                <p>
                    <strong>Dependencia cr√≠tica:</strong> Si la CPU ejecuta muy pocas instrucciones, la PPU avanza muy
                    lento. Si la PPU no llega a V-Blank (LY=144), el juego que est√° esperando V-Blank nunca sale del
                    bucle de espera. Esto crea un c√≠rculo vicioso: el juego espera V-Blank, pero V-Blank no ocurre
                    porque el juego ejecuta muy pocas instrucciones.
                </p>
                <p>
                    <strong>Polling de STAT:</strong> Muchos juegos hacen polling del registro STAT (0xFF41) esperando
                    que la PPU entre en modo V-Blank (bit 0-1 = 01) antes de copiar gr√°ficos a VRAM. Si la PPU nunca
                    llega a V-Blank, el juego queda atrapado en el bucle de espera.
                </p>
                <p>
                    Fuente: Pan Docs - LCD Timing, V-Blank, STAT Register, System Clock
                </p>
            </section>

            <!-- 3. Implementaci√≥n -->
            <section id="implementacion">
                <h2>Implementaci√≥n</h2>
                <p>
                    Se a√±adi√≥ un sistema de diagn√≥stico peri√≥dico en el bucle principal de ejecuci√≥n que muestra
                    informaci√≥n completa del estado del emulador cada 5 segundos, independientemente de si hay frames
                    listos o no. Esto permite diagnosticar problemas de timing y sincronizaci√≥n.
                </p>
                
                <h3>Componentes modificados</h3>
                <ul>
                    <li><strong>Viboy (src/viboy.py)</strong>:
                        <ul>
                            <li>A√±adido contador de instrucciones ejecutadas</li>
                            <li>A√±adido diagn√≥stico peri√≥dico cada 5 segundos que muestra:
                                <ul>
                                    <li>N√∫mero de instrucciones ejecutadas</li>
                                    <li>N√∫mero de escrituras en VRAM detectadas</li>
                                    <li>PC (Program Counter) actual</li>
                                    <li>Estado de HALT de la CPU</li>
                                    <li>LCDC (LCD Control Register)</li>
                                    <li>STAT (LCD Status Register)</li>
                                    <li>LY (L√≠nea actual de la PPU)</li>
                                    <li>IF (Interrupt Flag Register)</li>
                                    <li>IE (Interrupt Enable Register)</li>
                                </ul>
                            </li>
                            <li>Modificado el heartbeat para incluir el contador de escrituras en VRAM</li>
                        </ul>
                    </li>
                    <li><strong>MMU (src/memory/mmu.py)</strong>:
                        <ul>
                            <li>A√±adido m√©todo <code>get_vram_write_count()</code> para obtener el contador de escrituras en VRAM</li>
                            <li>A√±adido mensaje informativo al inicializar indicando que el diagn√≥stico VRAM est√° activo</li>
                        </ul>
                    </li>
                    <li><strong>PPU (src/gpu/ppu.py)</strong>:
                        <ul>
                            <li>Activado logging temporal cuando se genera V-Blank (LY=144) para diagn√≥stico</li>
                        </ul>
                    </li>
                    <li><strong>main.py</strong>:
                        <ul>
                            <li>Configurado encoding UTF-8 para Windows para permitir mostrar emojis en consola</li>
                            <li>Cambiado nivel de logging a INFO temporalmente para diagn√≥stico</li>
                        </ul>
                    </li>
                </ul>

                <h3>Decisiones de dise√±o</h3>
                <ul>
                    <li><strong>Diagn√≥stico peri√≥dico independiente de frames:</strong> El diagn√≥stico se ejecuta cada
                        5 segundos basado en tiempo real, no en frames. Esto permite diagnosticar problemas incluso
                        cuando no hay frames listos o cuando el juego est√° congelado.</li>
                    <li><strong>Informaci√≥n completa del estado:</strong> El diagn√≥stico muestra todos los registros
                        cr√≠ticos (PC, LCDC, STAT, LY, IF, IE) para entender completamente qu√© est√° haciendo el
                        emulador en cada momento.</li>
                    <li><strong>Logging de V-Blank:</strong> Se activ√≥ temporalmente el logging cuando la PPU genera
                        V-Blank para verificar si la PPU est√° avanzando correctamente.</li>
                </ul>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/viboy.py</code> - A√±adido diagn√≥stico peri√≥dico cada 5 segundos con informaci√≥n completa del estado del emulador</li>
                    <li><code>src/memory/mmu.py</code> - A√±adido m√©todo <code>get_vram_write_count()</code> y mensaje informativo de diagn√≥stico activo</li>
                    <li><code>src/gpu/ppu.py</code> - Activado logging temporal cuando se genera V-Blank</li>
                    <li><code>main.py</code> - Configurado encoding UTF-8 para Windows y nivel de logging a INFO</li>
                    <li><code>docs/bitacora/entries/2025-12-18__0062__diagnostico-bucle-espera-vblank.html</code> (nuevo)</li>
                    <li><code>docs/bitacora/index.html</code> (modificado, a√±adida entrada 0062)</li>
                    <li><code>docs/bitacora/entries/2025-12-18__0061__desbloqueo-vram-diagnostico-escrituras.html</code> (modificado, actualizado enlace "Siguiente")</li>
                    <li><code>INFORME_COMPLETO.md</code> (modificado, a√±adida entrada 0062)</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificaci√≥n -->
            <section id="tests">
                <h2>Tests y Verificaci√≥n</h2>
                <p>
                    <strong>Estado:</strong> <span class="tag tag-draft">En diagn√≥stico</span>
                </p>
                <p>
                    <strong>Comando ejecutado:</strong>
                </p>
                <pre><code>python main.py pkmn.gb</code></pre>
                <p>
                    <strong>Entorno:</strong> Windows 10, Python 3.13.5
                </p>
                <p>
                    <strong>ROM de prueba:</strong> Pok√©mon Red (ROM aportada por el usuario, no distribuida)
                </p>
                <p>
                    <strong>Resultado observado:</strong>
                </p>
                <ul>
                    <li><strong>Diagn√≥stico peri√≥dico muestra:</strong>
                        <pre><code>INFO: üìä Diagn√≥stico: 304 instrucciones, VRAM writes=0, PC=0x006F, 
     HALTED=False, LCDC=0x80, STAT=0x00, LY=6, IF=0x00, IE=0x00
INFO: üìä Diagn√≥stico: 605 instrucciones, VRAM writes=0, PC=0x006B, 
     HALTED=False, LCDC=0x80, STAT=0x00, LY=13, IF=0x00, IE=0x00
INFO: üìä Diagn√≥stico: 906 instrucciones, VRAM writes=0, PC=0x006D, 
     HALTED=False, LCDC=0x80, STAT=0x00, LY=20, IF=0x00, IE=0x00
INFO: üìä Diagn√≥stico: 1,208 instrucciones, VRAM writes=0, PC=0x006B, 
     HALTED=False, LCDC=0x80, STAT=0x00, LY=27, IF=0x00, IE=0x00</code></pre>
                    </li>
                </ul>
                <p>
                    <strong>Interpretaci√≥n del resultado:</strong>
                </p>
                <ul>
                    <li><strong>El juego S√ç est√° ejecutando c√≥digo:</strong> El PC cambia entre 0x006B, 0x006D, 0x006F,
                        lo que indica que est√° en un bucle peque√±o pero activo.</li>
                    <li><strong>El juego ejecuta muy pocas instrucciones:</strong> Solo ~60 instrucciones por segundo
                        (304 instrucciones en 5 segundos). Una Game Boy real ejecuta millones de instrucciones por
                        segundo, as√≠ que esto es extremadamente lento.</li>
                    <li><strong>La PPU avanza muy lento:</strong> LY solo llega a 6, 13, 20, 27... en 5 segundos. Para
                        llegar a V-Blank (LY=144) necesitar√≠a mucho m√°s tiempo.</li>
                    <li><strong>El juego NO est√° escribiendo en VRAM:</strong> VRAM writes=0 en todos los diagn√≥sticos.</li>
                    <li><strong>El juego est√° esperando V-Blank:</strong> El PC oscila en un rango muy bajo (0x006B-0x006F),
                        lo que sugiere un bucle de espera. Probablemente est√° haciendo polling de STAT esperando que
                        la PPU entre en modo V-Blank.</li>
                    <li><strong>No hay interrupciones habilitadas:</strong> IE=0x00 (no hay interrupciones habilitadas) e
                        IF=0x00 (no hay interrupciones pendientes).</li>
                    <li><strong>LCDC=0x80:</strong> El LCD est√° encendido (bit 7=1), pero el BG Display est√° apagado
                        (bit 0=0).</li>
                    <li><strong>STAT=0x00:</strong> La PPU est√° en modo 0 (H-Blank), no en V-Blank.</li>
                </ul>
                <p>
                    <strong>Qu√© valida:</strong> Este diagn√≥stico confirma que:
                    <ul>
                        <li>‚úÖ El juego est√° ejecutando c√≥digo (no est√° congelado completamente)</li>
                        <li>‚úÖ El juego NO est√° escribiendo en VRAM (VRAM writes=0)</li>
                        <li>‚ö†Ô∏è El juego ejecuta muy pocas instrucciones (~60 por segundo, extremadamente lento)</li>
                        <li>‚ö†Ô∏è La PPU avanza muy lento (LY solo llega a 27 en 5 segundos, necesita llegar a 144 para V-Blank)</li>
                        <li>‚ö†Ô∏è El juego est√° en un bucle esperando V-Blank que nunca ocurre porque la PPU avanza demasiado lento</li>
                    </ul>
                </p>
                <p>
                    <strong>Pr√≥ximo paso:</strong> Investigar por qu√© el juego ejecuta tan pocas instrucciones. Posibles
                    causas:
                    <ul>
                        <li>El juego est√° en un bucle muy lento (muchas instrucciones por iteraci√≥n)</li>
                        <li>Hay un problema con el timing que hace que el emulador vaya muy lento</li>
                        <li>El juego est√° esperando alg√∫n evento que nunca ocurre</li>
                        <li>Hay un problema con la sincronizaci√≥n de la PPU que hace que avance muy lento</li>
                    </ul>
                    Tambi√©n se debe verificar si la PPU llega a V-Blank despu√©s de esperar m√°s tiempo (20-30 segundos)
                    para confirmar si el problema es solo de velocidad o si hay un problema m√°s fundamental.
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#lcd-timing">LCD Timing</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#lcd-status-register-stat-ff41">LCD Status Register (STAT)</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#v-blank">V-Blank</a></li>
                    <li>Pan Docs: <a href="https://gbdev.io/pandocs/#system-clock">System Clock</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Dependencia cr√≠tica entre CPU y PPU:</strong> La PPU avanza sincronizada con la CPU.
                            Si la CPU ejecuta muy pocas instrucciones, la PPU avanza muy lento. Si la PPU no llega a
                            V-Blank, el juego que est√° esperando V-Blank nunca sale del bucle de espera. Esto crea un
                            c√≠rculo vicioso.</li>
                        <li><strong>Polling de STAT:</strong> Muchos juegos hacen polling del registro STAT esperando
                            que la PPU entre en modo V-Blank antes de copiar gr√°ficos a VRAM. Si la PPU nunca llega a
                            V-Blank, el juego queda atrapado en el bucle de espera.</li>
                        <li><strong>Diagn√≥stico sistem√°tico:</strong> A√±adir informaci√≥n completa del estado del emulador
                            (PC, LCDC, STAT, LY, IF, IE) permite diagnosticar problemas de timing y sincronizaci√≥n de
                            forma sistem√°tica. Sin esta informaci√≥n, es imposible entender por qu√© el juego no avanza.</li>
                        <li><strong>Velocidad de ejecuci√≥n:</strong> Una Game Boy real ejecuta millones de instrucciones
                            por segundo. Si el emulador ejecuta solo ~60 instrucciones por segundo, hay un problema grave
                            de timing o sincronizaci√≥n.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>¬øPor qu√© el juego ejecuta tan pocas instrucciones?</strong> Necesito investigar si
                            el problema es:
                            <ul>
                                <li>Un bucle muy lento en el c√≥digo del juego</li>
                                <li>Un problema con el timing del emulador</li>
                                <li>Un problema con la sincronizaci√≥n de la PPU</li>
                                <li>El juego est√° esperando alg√∫n evento que nunca ocurre</li>
                            </ul>
                        </li>
                        <li><strong>¬øLa PPU llega a V-Blank si esperamos m√°s tiempo?</strong> Si despu√©s de 20-30 segundos
                            la PPU llega a LY=144 y se genera V-Blank, entonces el problema es solo de velocidad. Si nunca
                            llega, hay un problema m√°s fundamental con la sincronizaci√≥n.</li>
                        <li><strong>¬øEl juego sale del bucle cuando ocurre V-Blank?</strong> Si la PPU llega a V-Blank
                            y el juego sale del bucle, entonces el problema est√° resuelto. Si no sale, hay otro problema
                            (quiz√°s el juego est√° esperando algo m√°s adem√°s de V-Blank).</li>
                    </ul>

                    <h3>Hip√≥tesis y Suposiciones</h3>
                    <p>
                        <strong>Hip√≥tesis principal:</strong> El juego est√° en un bucle esperando V-Blank, pero la PPU
                        avanza demasiado lento porque el juego ejecuta muy pocas instrucciones. Esto crea un c√≠rculo
                        vicioso: el juego espera V-Blank, pero V-Blank no ocurre porque el juego ejecuta muy pocas
                        instrucciones.
                    </p>
                    <p>
                        <strong>Suposici√≥n:</strong> Asumo que el problema es de velocidad/timing, no un bug fundamental
                        en la implementaci√≥n. Si el juego ejecutara a velocidad normal, la PPU avanzar√≠a normalmente y
                        llegar√≠a a V-Blank, permitiendo que el juego salga del bucle y copie gr√°ficos a VRAM.
                    </p>
                </div>
            </section>

            <!-- 8. Pr√≥ximos Pasos -->
            <section id="proximos-pasos">
                <h2>Pr√≥ximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar el emulador y esperar 20-30 segundos para verificar si la PPU llega a V-Blank
                        (LY=144) y si se genera la interrupci√≥n V-Blank (mensaje "üéØ PPU: V-Blank iniciado").</li>
                    <li>[ ] Si la PPU llega a V-Blank pero el juego no sale del bucle, investigar qu√© m√°s est√° esperando
                        el juego (quiz√°s est√° esperando que se habilite IE o que se procese la interrupci√≥n).</li>
                    <li>[ ] Si la PPU nunca llega a V-Blank, investigar por qu√© el juego ejecuta tan pocas instrucciones:
                        <ul>
                            <li>Verificar si hay un problema con el timing del emulador</li>
                            <li>Verificar si hay un problema con la sincronizaci√≥n de la PPU</li>
                            <li>Verificar si el juego est√° en un bucle muy lento</li>
                            <li>Verificar si el juego est√° esperando alg√∫n evento que nunca ocurre</li>
                        </ul>
                    </li>
                    <li>[ ] Una vez resuelto el problema de velocidad/timing, verificar si el juego empieza a escribir
                        en VRAM despu√©s de salir del bucle de espera.</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia c√≥digo de otros emuladores. Basado √∫nicamente en documentaci√≥n t√©cnica.</p>
        </footer>
    </div>
</body>
</html>

