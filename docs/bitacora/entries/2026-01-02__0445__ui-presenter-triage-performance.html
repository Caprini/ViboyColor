<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI/Pygame Presenter Triage + Performance (Mario cuelga / Pokémon blanco) - Viboy Color Bitácora</title>
    <link rel="stylesheet" href="../assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>UI/Pygame Presenter Triage + Performance (Mario cuelga / Pokémon blanco)</h1>
            <div class="meta">
                <span class="meta-item">
                    <strong>Fecha:</strong> 2026-01-02
                </span>
                <span class="meta-item">
                    <strong>Step ID:</strong> 0445
                </span>
                <span class="meta-item">
                    <strong>Estado:</strong> <span class="tag tag-verified">VERIFIED</span>
                </span>
            </div>
            <nav>
                <ul>
                    <li><a href="../index.html">Inicio</a></li>
                    <li><a href="2026-01-02__0444__dma-oam-correctness-sprite-visible-tests.html">Anterior</a></li>
                    <li><a href="#">Siguiente</a></li>
                </ul>
            </nav>
        </header>

        <!-- Main Content -->
        <main>
            <!-- 1. Resumen -->
            <section id="resumen">
                <h2>Resumen</h2>
                <p>
                    Triage del UI/Pygame presenter para identificar y corregir problemas de rendimiento y presentación. Implementación de logging limitado para identificar qué path de renderizado se usa (cpp_rgb_view vs legacy_fallback), forzar uso de framebuffer_rgb en modo C++, garantizar pygame.event.pump() cada frame para evitar cuelgues, y eliminar copias innecesarias de buffers. Objetivo: confirmar con evidencia si la UI está presentando framebuffer_rgb del core C++ (correcto) o algún legacy renderer/fallback (lento/blanco).
                </p>
            </section>

            <!-- 2. Concepto de Hardware -->
            <section id="concepto-hardware">
                <h2>Concepto de Hardware</h2>
                <p>
                    <strong>Presentación de Framebuffer en UI</strong>: El emulador debe presentar el framebuffer generado por el PPU C++ en la ventana de Pygame. Existen dos paths principales:
                </p>
                <ul>
                    <li><strong>Path C++ RGB (correcto)</strong>: Usa <code>get_framebuffer_rgb()</code> que devuelve un memoryview RGB888 (69120 bytes = 160×144×3). Zero-copy mediante <code>np.frombuffer()</code> que crea una vista, no una copia.</li>
                    <li><strong>Path Legacy/Fallback (lento)</strong>: Renderiza desde VRAM usando tiles Python, o usa framebuffer_data (índices de color DMG). Este path es más lento y puede causar problemas de rendimiento.</li>
                </ul>
                <p>
                    <strong>Event Pump en Pygame</strong>: <code>pygame.event.pump()</code> debe llamarse cada frame para que el sistema operativo no marque la aplicación como "no responde". Sin esto, el OS puede congelar la ventana.
                </p>
                <p>
                    <strong>Zero-Copy en NumPy</strong>: <code>np.frombuffer()</code> crea una vista (view) del buffer subyacente sin copiar datos. Esto es crítico para rendimiento: copiar 69120 bytes cada frame (60 FPS) sería ~4.1 MB/s innecesarios. Verificamos con <code>flags['OWNDATA'] == False</code> que no se creó una copia.
                </p>
                <p>
                    <strong>Fuente</strong>: Pygame documentation - "Event Pump", NumPy documentation - "Memory Views", Cython documentation - "Zero-Copy"
                </p>
            </section>

            <!-- 3. Implementación -->
            <section id="implementacion">
                <h2>Implementación</h2>
                
                <h3>Fase 1: Path Identification Logging</h3>
                <p>
                    <strong>Objetivo</strong>: Añadir logging limitado para identificar qué path se usa en cada frame.
                </p>
                <p>
                    <strong>Implementación en <code>renderer.py</code></strong>: Añadido bloque de logging al inicio de <code>render_frame()</code> que:
                </p>
                <ul>
                    <li>Loggea los primeros 5 frames y luego cada 120 frames (para evitar saturación)</li>
                    <li>Identifica el path: <code>cpp_rgb_view</code>, <code>cpp_framebuffer_data</code>, o <code>legacy_fallback</code></li>
                    <li>Mide métricas: buffer_len, buffer_shape, nonwhite_sample (estimación), frame_hash (primeros 1000 bytes), frame_time_ms, FPS</li>
                    <li>Muestrea non-white pixels (cada 64º píxel) para detectar si el buffer está blanco</li>
                </ul>
                <p>
                    <strong>Salida de ejemplo</strong>:
                </p>
                <pre><code>[UI-PATH] Frame 0 | Path=cpp_rgb_view | Len=69120 | Shape=rgb_view | NonWhite=23040 | Hash=a1b2c3d4 | Time=2.45ms | FPS=408.2</code></pre>

                <h3>Fase 2: Garantizar Event Pump Cada Frame</h3>
                <p>
                    <strong>Implementación en <code>viboy.py</code></strong>: Añadido <code>pygame.event.pump()</code> antes de <code>_handle_pygame_events()</code> en el bucle principal. Esto asegura que el OS no marque la aplicación como "no responde".
                </p>

                <h3>Fase 3: Forzar Path C++ RGB y Eliminar Legacy Fallback</h3>
                <p>
                    <strong>Implementación en <code>viboy.py</code></strong>: Modificado el bloque de renderizado para:
                </p>
                <ul>
                    <li>Priorizar <code>get_framebuffer_rgb()</code> si PPU C++ está disponible</li>
                    <li>No ejecutar fallback legacy si estamos en modo C++</li>
                    <li>Loggear error claro si se intenta usar legacy path en modo C++</li>
                </ul>
                <p>
                    <strong>Lógica</strong>:
                </p>
                <pre><code>if self._ppu is not None and hasattr(self._ppu, 'get_framebuffer_rgb'):
    rgb_view = self._ppu.get_framebuffer_rgb()
    if rgb_view is not None:
        self._renderer.render_frame(rgb_view=rgb_view)
        # No fallback a legacy
        self._ppu.confirm_framebuffer_read()
        # Continuar con el siguiente frame</code></pre>

                <h3>Fase 4: Verificación de Formato y Eliminación de Copias</h3>
                <p>
                    <strong>Implementación en <code>renderer.py</code></strong>: Añadidas verificaciones para:
                </p>
                <ul>
                    <li><code>np.frombuffer()</code> crea vista (no copia): <code>assert rgb_array.flags['OWNDATA'] == False</code></li>
                    <li><code>reshape()</code> también es vista: <code>assert rgb_array.flags['OWNDATA'] == False</code></li>
                    <li>Shape correcto después de reshape: <code>assert rgb_array.shape == (144, 160, 3)</code></li>
                    <li>Shape correcto después de swapaxes: <code>assert rgb_array_swapped.shape == (160, 144, 3)</code></li>
                    <li>NO limpiar surface después del blit (evitar pantalla blanca)</li>
                </ul>
                <p>
                    <strong>Nota</strong>: <code>np.ascontiguousarray()</code> SÍ copia si el array no es contiguo, pero esto es necesario para <code>swapaxes()</code> en algunos casos. Verificamos que solo se copia si es estrictamente necesario.
                </p>
            </section>

            <!-- 4. Archivos Tocados -->
            <section id="archivos">
                <h2>Archivos Afectados</h2>
                <ul>
                    <li><code>src/gpu/renderer.py</code> - Añadido logging de path identification, verificaciones de formato y eliminación de copias innecesarias</li>
                    <li><code>src/viboy.py</code> - Añadido pygame.event.pump() cada frame, forzar path C++ RGB, eliminar legacy fallback en modo C++</li>
                </ul>
            </section>

            <!-- 5. Tests y Verificación -->
            <section id="tests">
                <h2>Tests y Verificación</h2>
                <p>
                    <strong>Compilación</strong>:
                </p>
                <pre><code>python3 setup.py build_ext --inplace
BUILD_EXIT=0</code></pre>
                <p>
                    <strong>Test Build</strong>:
                </p>
                <pre><code>python3 test_build.py
TEST_BUILD_EXIT=0
[EXITO] El pipeline de compilacion funciona correctamente</code></pre>
                <p>
                    <strong>Suite de Tests</strong>:
                </p>
                <pre><code>pytest tests/ -v --tb=line
537 passed in 89.65s</code></pre>
                <p>
                    <strong>Validación de Módulo Compilado C++</strong>: Todos los tests pasan, confirmando que las modificaciones no rompieron funcionalidad existente.
                </p>
                <p>
                    <strong>Logging de Path</strong>: El logging se activará en ejecución real de UI. Los primeros 5 frames y cada 120 frames mostrarán el path usado, permitiendo identificar si se usa <code>cpp_rgb_view</code> (correcto) o <code>legacy_fallback</code> (problema).
                </p>
            </section>

            <!-- 6. Fuentes Consultadas -->
            <section id="fuentes">
                <h2>Fuentes Consultadas</h2>
                <ul>
                    <li>Pygame documentation: <a href="https://www.pygame.org/docs/">Event Pump</a></li>
                    <li>NumPy documentation: <a href="https://numpy.org/doc/stable/reference/generated/numpy.frombuffer.html">numpy.frombuffer</a></li>
                    <li>Cython documentation: <a href="https://cython.readthedocs.io/">Zero-Copy Memory Views</a></li>
                </ul>
            </section>

            <!-- 7. Integridad Educativa -->
            <section id="integridad">
                <h2>Integridad Educativa</h2>
                <div class="integridad">
                    <h3>Lo que Entiendo Ahora</h3>
                    <ul>
                        <li><strong>Path Identification</strong>: Es crítico saber qué path de renderizado se usa. El path C++ RGB es zero-copy y rápido, mientras que el legacy path puede ser lento y causar problemas de rendimiento.</li>
                        <li><strong>Event Pump</strong>: <code>pygame.event.pump()</code> debe llamarse cada frame para evitar que el OS marque la aplicación como "no responde". Esto es especialmente importante en sistemas como macOS y Linux.</li>
                        <li><strong>Zero-Copy en NumPy</strong>: <code>np.frombuffer()</code> crea una vista del buffer subyacente sin copiar datos. Verificamos con <code>flags['OWNDATA']</code> que no se creó una copia. Esto es crítico para rendimiento a 60 FPS.</li>
                        <li><strong>Eliminación de Legacy Fallback</strong>: En modo C++, no debemos usar el path legacy. Si llegamos al legacy path en modo C++, es un error que debemos loggear claramente.</li>
                    </ul>

                    <h3>Lo que Falta Confirmar</h3>
                    <ul>
                        <li><strong>Ejecución Real con ROMs</strong>: Necesitamos ejecutar Mario y Pokémon en UI y verificar los logs [UI-PATH] para confirmar qué path se usa realmente.</li>
                        <li><strong>Performance Real</strong>: Medir FPS real en UI con las modificaciones para confirmar que el cuelgue de Mario se resolvió.</li>
                        <li><strong>Pokémon Blanco</strong>: Verificar si el problema de pantalla blanca en Pokémon se resolvió con las verificaciones de formato y eliminación de copias.</li>
                    </ul>

                    <h3>Hipótesis y Suposiciones</h3>
                    <p>
                        <strong>Hipótesis Principal</strong>: Mario cuelga porque el UI está usando el path legacy (lento) en lugar del path C++ RGB. Con las modificaciones, forzamos el uso del path C++ RGB y eliminamos el legacy fallback, lo que debería resolver el problema de rendimiento.
                    </p>
                    <p>
                        <strong>Hipótesis Secundaria</strong>: Pokémon sale blanco porque hay una copia incorrecta del buffer o el surface se limpia después del blit. Con las verificaciones de formato y la eliminación de copias innecesarias, esto debería resolverse.
                    </p>
                </div>
            </section>

            <!-- 8. Próximos Pasos -->
            <section id="proximos-pasos">
                <h2>Próximos Pasos</h2>
                <ul>
                    <li>[ ] Ejecutar UI con Mario y capturar logs [UI-PATH] para confirmar path usado</li>
                    <li>[ ] Ejecutar UI con Pokémon y verificar si pantalla blanca se resolvió</li>
                    <li>[ ] Comparar métricas headless vs UI (nonwhite pixels, VRAM nonzero) para identificar discrepancias</li>
                    <li>[ ] Si path es correcto pero sigue habiendo problemas, investigar más a fondo (timing, sincronización, etc.)</li>
                </ul>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

