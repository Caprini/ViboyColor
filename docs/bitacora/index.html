<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitácora - Viboy Color</title>
    <link rel="stylesheet" href="assets/style.css">
</head>
<body>
    <div class="container">
        <!-- Aviso Clean-Room -->
        <div class="clean-room-notice">
            <strong>⚠️ Clean-Room / Educativo</strong>
            <p>Este proyecto es educativo y Open Source. No se copia código de otros emuladores. Implementación basada únicamente en documentación técnica y tests permitidas.</p>
        </div>

        <!-- Header -->
        <header>
            <h1>Bitácora del Proyecto Viboy Color</h1>
            <p style="color: var(--color-text-secondary); margin-top: var(--spacing-sm);">
                Registro educativo del desarrollo de un emulador de Game Boy Color en Python.
                Implementación clean-room basada en documentación técnica.
            </p>
        </header>

        <!-- Main Content -->
        <main>
            <section id="entradas">
                <h2>Entradas de la Bitácora</h2>
                <p style="color: var(--color-text-secondary); margin-bottom: var(--spacing-lg);">
                    Las entradas están ordenadas por fecha, más recientes primero.
                </p>
                
                <ul class="entry-list">
                    <!-- Entrada 0029 - MBC1 y Bank Switching -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0029__mbc1-bank-switching.html" class="entry-link">
                                    MBC1 y Bank Switching
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0029 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se implementó el Memory Bank Controller 1 (MBC1) para permitir que cartuchos mayores a 32KB funcionen correctamente. El MBC1 resuelve el problema de que la CPU solo puede direccionar 64KB, pero los juegos pueden tener ROMs de 512KB o más. La solución es el Bank Switching: dividir la ROM en bancos de 16KB y cambiar dinámicamente qué banco está visible en el rango 0x4000-0x7FFF. El banco 0 (0x0000-0x3FFF) siempre apunta a los primeros 16KB y no cambia. El banco switchable se cambia escribiendo en el rango 0x2000-0x3FFF, que el MBC1 interpreta como comandos. Con esta implementación, Tetris DX (512KB) puede acceder a todos sus bancos de ROM, incluyendo música y gráficos que están en bancos superiores. Suite completa de tests TDD (6 tests) validando bank switching, quirk del banco 0, y enmascarado de bits. Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0028 - Renderizado del Background -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0028__renderizado-background.html" class="entry-link">
                                    Renderizado del Background (Fondo)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0028 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se implementó el renderizado del Background (fondo) de la Game Boy, el primer paso hacia la visualización completa de gráficos en el emulador. El método render_frame() lee el registro LCDC (LCD Control, 0xFF40) para determinar la configuración del hardware, selecciona las direcciones base del tilemap y de los datos de tiles, y renderiza los 20x18 tiles visibles en pantalla (160x144 píxeles). La implementación incluye soporte para modos signed/unsigned de direccionamiento de tiles y decodificación de la paleta BGP. Con la CPU completa y funcionando, ahora el emulador puede renderizar el logo de Tetris o la pantalla de copyright cuando ejecuta ROMs reales. Suite completa de tests TDD (6 tests) validando control de LCDC, modos signed/unsigned, y desactivación de LCD/BG. Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0027 - Completar INC/DEC de 8 bits -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0027__completar-inc-dec-8bits.html" class="entry-link">
                                    Completar INC/DEC de 8 bits (Todas las Variantes)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0027 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se completaron todas las variantes de INC/DEC de 8 bits que faltaban en la CPU. En el paso 9 se habían implementado INC/DEC para B, C y A, pero se dejaron fuera D, E, H, L y la versión en memoria (HL). El emulador crasheaba en el opcode 0x1D (DEC E) cuando ejecutaba Tetris DX, lo que confirmaba que faltaban estas instrucciones críticas para el manejo de contadores de bucles. Con esta implementación, la aritmética unaria de 8 bits está completa y el emulador puede avanzar más allá de la inicialización en juegos reales. Suite completa de tests TDD (10 tests) validando todas las variantes, incluyendo operaciones Read-Modify-Write en memoria. Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0026 - Integración Gráfica y Decodificador de Tiles -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0026__integracion-grafica-decodificador-tiles.html" class="entry-link">
                                    Integración Gráfica y Decodificador de Tiles
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0026 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            ¡Hito visual histórico! Se integró Pygame para visualizar gráficos y se implementó el decodificador de tiles en formato 2bpp (2 bits por píxel) de la Game Boy. Ahora el emulador puede "ver" y mostrar el contenido de la VRAM, decodificando los gráficos que la CPU escribe en memoria. La implementación incluye la función decode_tile_line() que convierte dos bytes en 8 píxeles con colores 0-3, y la clase Renderer que inicializa Pygame y proporciona un modo debug para visualizar todos los tiles de la VRAM en una rejilla. El sistema se integra con el bucle principal, renderizando cuando se detecta V-Blank. Suite completa de tests TDD (6 tests) validando la decodificación 2bpp. Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0025 - Despachador de Interrupciones -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0025__despachador-interrupciones.html" class="entry-link">
                                    Despachador de Interrupciones
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0025 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se implementó el Despachador de Interrupciones (Interrupt Service Routine - ISR) en la CPU, conectando finalmente
                            el sistema de timing (PPU) con la CPU. Ahora la CPU puede responder a interrupciones como V-Blank, Timer, LCD STAT,
                            Serial y Joypad. La implementación incluye el manejo correcto de prioridades (V-Blank tiene mayor prioridad que Timer, etc.),
                            despertar de HALT cuando hay interrupciones pendientes, y la secuencia completa de hardware: desactivar IME, limpiar flag
                            en IF, guardar PC en la pila, y saltar al vector. Esta es la funcionalidad que convierte el emulador de una "calculadora
                            lineal" en un sistema reactivo capaz de responder a eventos del hardware. Suite completa de tests TDD (6 tests) validando
                            todas las funcionalidades. Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0024 - PPU Timing Engine - El Motor del Tiempo -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0024__ppu-timing-engine.html" class="entry-link">
                                    PPU Timing Engine - El Motor del Tiempo
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0024 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            ¡Hito crítico: El sistema ahora tiene "latido" gráfico! Se implementó el motor de timing de la PPU (Pixel Processing Unit),
                            que permite que los juegos detecten el V-Blank y salgan de bucles infinitos de espera. La implementación incluye el registro
                            LY (Línea actual) que cambia automáticamente cada 456 T-Cycles, la activación de la interrupción V-Blank cuando LY llega a 144,
                            y el wrap-around de frame cuando LY supera 153. Sin esta funcionalidad, juegos como Tetris DX se quedaban esperando
                            eternamente porque LY siempre devolvía 0. Ahora el sistema tiene el "reloj" necesario para que los juegos puedan sincronizarse
                            y avanzar más allá de la inicialización. Suite completa de tests TDD (8 tests) validando todas las funcionalidades. Todos los
                            tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0023 - I/O Dinámico y Mapeo de Registros -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0023__io-dinamico-mapeo-registros.html" class="entry-link">
                                    I/O Dinámico y Mapeo de Registros
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0023 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            ¡ISA (Instruction Set Architecture) de la CPU completada al 100%! Se implementaron los dos últimos opcodes
                            faltantes: LD (C), A (0xE2) y LD A, (C) (0xF2). Estas instrucciones permiten acceso dinámico a registros de
                            hardware usando C como offset, útiles para bucles de inicialización. Además, se mejoró significativamente la
                            visibilidad del sistema añadiendo constantes para todos los registros de hardware (LCDC, STAT, BGP, etc.) y
                            mejorando el logging de la MMU para mostrar nombres de registros en lugar de direcciones hexadecimales. Con esto,
                            el emulador puede ejecutar código completo de juegos reales y los logs ahora muestran información legible como
                            "IO WRITE: LCDC = 0x91". Suite completa de tests TDD (6 tests) validando todas las funcionalidades. Todos los
                            tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0022 - DAA, RST y Flags - El Final de la CPU -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0022__daa-rst-flags-final-cpu.html" class="entry-link">
                                    DAA, RST y Flags - El Final de la CPU
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0022 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            ¡Hito histórico! Se completó al 100% el set de instrucciones de la CPU LR35902 implementando las últimas
                            instrucciones misceláneas: DAA (Decimal Adjust Accumulator), CPL (Complement), SCF (Set Carry Flag),
                            CCF (Complement Carry Flag) y los 8 vectores RST (Restart). Con esto, la CPU tiene implementados los
                            500+ opcodes de la Game Boy (incluyendo el prefijo CB). DAA es especialmente importante porque permite
                            trabajar con BCD para puntuaciones en pantalla. RST es vital porque las interrupciones hardware lo
                            usan para saltar a sus manejadores. Suite completa de tests TDD (12 tests) validando todas las operaciones.
                            Todos los tests pasan.
                        </p>
                    </li>
                    
                    <!-- Entrada 0021 - Completar Prefijo CB - BIT, RES y SET (0x40-0xFF) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0021__completar-prefijo-cb-bit-res-set.html" class="entry-link">
                                    Completar Prefijo CB - BIT, RES y SET (0x40-0xFF)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0021 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se completó al 100% la tabla CB del prefijo extendido implementando las tres cuartas partes restantes:
                            BIT (0x40-0x7F), RES (0x80-0xBF) y SET (0xC0-0xFF). Estas instrucciones son fundamentales para la
                            manipulación de bits, que es una operación extremadamente común en los juegos de Game Boy. Por ejemplo,
                            Tetris usa constantemente RES 7, (HL) para marcar que un bloque ha dejado de caer. La implementación
                            completa cubre 192 opcodes CB adicionales (64 por operación), completando así las 256 instrucciones
                            del prefijo CB. Suite completa de tests TDD (8 tests) validando todas las operaciones. Todos los tests pasan.
                        </p>
                    </li>
                    <!-- Entrada 0020 - Rotaciones, Shifts y SWAP - Prefijo CB (0x00-0x3F) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0020__rotaciones-shifts-swap-cb.html" class="entry-link">
                                    Rotaciones, Shifts y SWAP - Prefijo CB (0x00-0x3F)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0020 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se implementó el primer cuarto de la tabla CB (rango 0x00-0x3F) con todas las operaciones de rotación,
                            desplazamiento y SWAP. Estas instrucciones son "la salsa secreta" de la Game Boy: se usan para animaciones,
                            físicas, compresión de datos y generación de números aleatorios. La implementación incluye 8 operaciones
                            (RLC, RRC, RL, RR, SLA, SRA, SRL, SWAP) aplicables a 8 destinos (B, C, D, E, H, L, (HL), A), generando
                            64 opcodes CB en total. La diferencia crítica con las rotaciones rápidas (RLCA, etc.) es que las versiones
                            CB SÍ calculan el flag Z según el resultado, mientras que las rotaciones rápidas siempre ponen Z=0.
                            Suite completa de tests TDD (12 tests) validando todas las operaciones. Todos los tests pasan.
                        </p>
                    </li>
                    <!-- Entrada 0019 - Cargas Inmediatas Restantes (LD r, d8 y LD (HL), d8) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0019__cargas-inmediatas-restantes.html" class="entry-link">
                                    Cargas Inmediatas Restantes (LD r, d8 y LD (HL), d8)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0019 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se completó la familia de cargas inmediatas de 8 bits implementando los opcodes faltantes:
                            LD C, d8 (0x0E), LD D, d8 (0x16), LD E, d8 (0x1E), LD H, d8 (0x26), LD L, d8 (0x2E) y LD (HL), d8 (0x36).
                            Estas instrucciones son fundamentales para inicializar contadores de bucles, constantes y buffers de memoria.
                            El emulador se detenía en 0x0E (LD C, d8) cuando ejecutaba Tetris DX, lo que confirmaba que faltaban estas
                            cargas inmediatas. Con esta implementación, la CPU ahora puede cargar valores inmediatos en todos los registros
                            de 8 bits y escribir directamente en memoria indirecta, cubriendo el 90% de la lógica de propósito general
                            de un programa. Suite completa de tests TDD (6 tests) validando todas las cargas inmediatas. Todos los tests pasan.
                        </p>
                    </li>
                    <!-- Entrada 0018 - ALU con Operandos Inmediatos (d8) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0018__alu-inmediata.html" class="entry-link">
                                    ALU con Operandos Inmediatos (d8)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0018 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se completó el conjunto de operaciones ALU inmediatas (con operandos de 8 bits embebidos en el código),
                            implementando ADC A, d8 (0xCE), SBC A, d8 (0xDE), AND d8 (0xE6), XOR d8 (0xEE) y OR d8 (0xF6).
                            Estas instrucciones son críticas porque permiten operar con constantes directamente del código,
                            sin necesidad de cargar valores en registros primero. La implementación reutiliza los helpers
                            genéricos ya existentes (_adc, _sbc, _and, _xor, _or), siguiendo el principio DRY. Con esto,
                            la CPU ahora tiene capacidad computacional completa para operaciones de 8 bits, lo que permite
                            que juegos como Tetris DX avancen más allá de la inicialización. Suite completa de tests TDD
                            (5 tests) validando todas las operaciones inmediatas. Todos los tests pasan.
                        </p>
                    </li>
                    <!-- Entrada 0017 - Pila Completa y Rotaciones del Acumulador -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0017__pila-completa-rotaciones.html" class="entry-link">
                                    Pila Completa y Rotaciones del Acumulador
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0017 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Se completó el manejo del Stack (Pila) implementando PUSH/POP para todos los pares de registros
                            (AF, DE, HL), y se añadieron las rotaciones rápidas del acumulador (RLCA, RRCA, RLA, RRA).
                            La implementación de POP AF incluye la máscara crítica 0xF0 para los bits bajos del registro F,
                            simulando el comportamiento del hardware real. Las rotaciones rápidas tienen un comportamiento
                            especial con los flags: Z siempre es 0, incluso si el resultado es cero. Esta es una diferencia
                            clave con las rotaciones del prefijo CB. Todos los tests pasan (17 tests en total). Estas
                            instrucciones son fundamentales para que juegos como Tetris puedan generar números aleatorios
                            y restaurar el estado de flags después de interrupciones.
                        </p>
                    </li>
                    <!-- Entrada 0016 - Bloque ALU Completo -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0016__bloque-alu-completo.html" class="entry-link">
                                    Bloque ALU Completo (0x80-0xBF)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0016 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación del bloque completo de la ALU (Unidad Aritmética Lógica) del rango 0x80-0xBF,
                            cubriendo 64 opcodes que incluyen todas las operaciones aritméticas y lógicas principales:
                            ADD, ADC (Add with Carry), SUB, SBC (Subtract with Carry), AND, XOR, OR y CP (Compare).
                            Se implementaron helpers genéricos para cada operación y se documentó el comportamiento
                            especial del flag H en la operación AND (quirk del hardware: siempre se pone a 1).
                            Suite completa de tests TDD (8 tests) validando todas las funcionalidades, incluyendo
                            ADC/SBC con carry y el quirk del flag H. Todos los tests pasan. El emulador ahora puede
                            ejecutar el opcode 0xB3 (OR A, E) que Tetris DX pide en 0x1389, permitiendo que el juego
                            avance más allá de la inicialización.
                        </p>
                    </li>
                    <!-- Entrada 0015 - Transferencias de 8 bits y HALT -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-17__0015__transferencias-8bits-halt.html" class="entry-link">
                                    Transferencias de 8 bits (LD r, r') y HALT
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-17 | 
                            <strong>Step ID:</strong> 0015 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación del bloque completo de transferencias de 8 bits (LD r, r') del rango 0x40-0x7F,
                            cubriendo 63 opcodes nuevos que permiten mover datos entre registros y memoria. Se implementó
                            también la instrucción HALT (0x76) que pone la CPU en modo de bajo consumo. El bloque es
                            crítico porque permite que el emulador ejecute código real de juegos que necesita transferir
                            datos entre registros. Se usó inicialización lazy de handlers para evitar problemas de orden
                            de definición. Suite completa de tests TDD (8 tests) validando todas las funcionalidades.
                            Todos los tests pasan. El emulador ahora puede ejecutar transferencias de datos, un paso
                            fundamental para que los juegos puedan funcionar correctamente.
                        </p>
                    </li>
                    <!-- Entrada 0014 - Aritmética de 16 bits y Retornos Condicionales -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0014__aritmetica-16bits-retornos-condicionales.html" class="entry-link">
                                    Aritmética de 16 bits y Retornos Condicionales
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0014 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de aritmética de 16 bits (INC/DEC de registros pares y ADD HL, rr) y retornos condicionales
                            (RET NZ, RET Z, RET NC, RET C). Peculiaridad crítica: INC/DEC de 16 bits NO afectan a ningún flag (a diferencia
                            de los de 8 bits), esencial para bucles que decrementan contadores sin corromper flags. ADD HL, rr actualiza
                            flags H y C pero NO toca Z, otro comportamiento especial del hardware LR35902. Los retornos condicionales
                            consumen 5 M-Cycles cuando se toman y 2 M-Cycles cuando no. Suite completa de tests TDD (24 tests) validando
                            todas las funcionalidades. El emulador ahora puede ejecutar bucles complejos como los de inicialización de Tetris DX.
                        </p>
                    </li>
                    <!-- Entrada 0013 - Cargas de 16 bits (BC, DE) y Comparaciones (CP) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0013__cargas-16bits-comparaciones.html" class="entry-link">
                                    Cargas de 16 bits (BC, DE) y Comparaciones (CP)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0013 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de cargas inmediatas de 16 bits para los registros BC y DE, almacenamiento indirecto usando BC y DE como punteros, y la instrucción crítica de comparación CP (Compare). Se añadió el helper _cp() que realiza una "resta fantasma" (actualiza flags sin modificar A) y se implementaron los opcodes LD BC, d16 (0x01), LD DE, d16 (0x11), LD (BC), A (0x02), LD (DE), A (0x12), CP d8 (0xFE) y CP (HL) (0xBE). Estas instrucciones son esenciales para que el emulador pueda avanzar más allá de la inicialización, permitiendo cargar constantes en registros pares y tomar decisiones condicionales. Suite completa de tests TDD (9 tests) validando todas las funcionalidades. También se corrigió un bug en la MMU donde el área de ROM devolvía 0xFF cuando no había cartucho.
                        </p>
                    </li>
                    <!-- Entrada 0012 - Acceso a I/O (LDH) y Prefijo CB -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0012__io-access-prefijo-cb.html" class="entry-link">
                                    Acceso a I/O (LDH) y Prefijo CB
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0012 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de acceso a registros de hardware (I/O Ports) mediante instrucciones LDH y el sistema
                            de prefijo CB para instrucciones extendidas. Se implementaron los opcodes LDH (n), A (0xE0) y LDH A, (n)
                            (0xF0) para escribir y leer del área I/O (0xFF00-0xFFFF). Se añadió el manejo del prefijo CB (0xCB) con
                            una segunda tabla de despacho que permite acceder a 256 instrucciones adicionales. Se implementó la
                            instrucción BIT 7, H (CB 0x7C) con un helper genérico _bit() que actualiza flags correctamente. Estas
                            instrucciones son críticas para que Tetris DX pueda configurar el hardware y ejecutar bucles de limpieza
                            de memoria. Suite completa de tests TDD (7 tests) validando todas las funcionalidades.
                        </p>
                    </li>
                    <!-- Entrada 0011 - Memoria Indirecta e Incremento/Decremento -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0011__memoria-indirecta-inc-dec.html" class="entry-link">
                                    Memoria Indirecta e Incremento/Decremento
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0011 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de direccionamiento indirecto usando HL como puntero de memoria, operaciones LDI/LDD (incremento/decremento
                            automático del puntero) y operaciones unarias de incremento/decremento (INC/DEC) con manejo correcto de flags. Se
                            implementaron helpers críticos _inc_n y _dec_n que actualizan flags Z, N, H pero NO tocan el flag C (Carry), una
                            peculiaridad importante del hardware LR35902. Estos opcodes son esenciales para bucles de limpieza de memoria que
                            los juegos ejecutan al inicio (memset). Suite completa de tests TDD validando memoria indirecta y flags.
                        </p>
                    </li>
                    <!-- Entrada 0010 - Control de Interrupciones, XOR y Cargas de 16 bits -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0010__control-interrupciones-xor.html" class="entry-link">
                                    Control de Interrupciones, XOR y Cargas de 16 bits
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0010 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de instrucciones críticas de control de sistema y operaciones lógicas necesarias para que Tetris DX
                            continúe ejecutándose. Se añadió el atributo IME (Interrupt Master Enable) a la CPU para controlar las interrupciones.
                            Se implementaron los opcodes DI (0xF3) y EI (0xFB) para desactivar/activar interrupciones, XOR A (0xAF) como optimización
                            para poner el registro A a cero, y las instrucciones de carga inmediata de 16 bits LD SP, d16 (0x31) y LD HL, d16 (0x21).
                            Estas instrucciones son esenciales para la inicialización del sistema. Suite completa de tests TDD (13 tests).
                        </p>
                    </li>
                    <!-- Entrada 0009 - Placa Base y Bucle Principal -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0009__placa-base-bucle-principal.html" class="entry-link">
                                    Placa Base y Bucle Principal (Game Loop)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0009 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de la clase Viboy que actúa como la "placa base" del emulador, integrando todos los componentes
                            (CPU, MMU, Cartridge) en un sistema unificado. Creación del bucle principal (Game Loop) que ejecuta instrucciones
                            continuamente, simulando el funcionamiento de la Game Boy real a 4.194304 MHz. El sistema ahora puede ejecutar
                            código real de ROMs, aunque se detendrá cuando encuentre opcodes no implementados. Modo debug implementado para
                            mostrar trazas detalladas de cada instrucción ejecutada. Sin este bucle, la CPU no puede "vivir" y procesar código
                            de juegos. Suite completa de tests de integración (8 tests).
                        </p>
                    </li>
                    <!-- Entrada 0008 - Carga de ROM y Cartucho -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0008__carga-rom-cartucho.html" class="entry-link">
                                    Carga de ROM y Parsing del Header del Cartucho
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0008 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de la clase Cartridge que carga archivos ROM (`.gb` o `.gbc`) y parsea el Header del cartucho
                            para extraer información crítica (título, tipo de cartucho, tamaño de ROM/RAM). Integración del cartucho
                            en la MMU para mapear la ROM en el espacio de direcciones (0x0000 - 0x7FFF). Actualización de main.py
                            para aceptar argumentos de línea de comandos y cargar ROMs reales. Sin esta funcionalidad, el emulador
                            no puede ejecutar código de juegos reales. Suite completa de tests TDD (6 tests) validando carga,
                            parsing y casos edge.
                        </p>
                    </li>
                    <!-- Entrada 0007 - Stack (Pila) -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0007__stack-pila.html" class="entry-link">
                                    Implementación del Stack (Pila) y Subrutinas
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0007 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación completa del Stack (Pila) de la CPU, incluyendo helpers para PUSH/POP de bytes y palabras,
                            y opcodes críticos para subrutinas: PUSH BC (0xC5), POP BC (0xC1), CALL nn (0xCD) y RET (0xC9). La pila
                            es la memoria a corto plazo que permite a la CPU recordar "dónde estaba" cuando llama a funciones. Concepto
                            crítico: la pila crece hacia abajo (SP decrece en PUSH). Implementación con orden correcto de bytes
                            (Little-Endian) validada con suite completa de tests TDD (5 tests).
                        </p>
                    </li>
                    <!-- Entrada 0006 - Licencia MIT -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0006__licencia-mit.html" class="entry-link">
                                    Añadir Licencia MIT al Proyecto
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0006 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Añadida licencia MIT al proyecto para proteger el trabajo educativo y definir claramente cómo otros
                            pueden usar, modificar y distribuir el código. Creado archivo LICENSE con el texto oficial de la
                            licencia MIT (año 2025). Actualizado README.md con badge de licencia y sección mejorada. El proyecto
                            ahora es oficialmente Open Source bajo licencia MIT.
                        </p>
                    </li>
                    <!-- Entrada 0005 - Saltos y Control de Flujo -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0005__saltos-control-flujo.html" class="entry-link">
                                    Implementación de Saltos y Control de Flujo
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0005 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de instrucciones de salto (JP nn, JR e, JR NZ,e) que permiten romper la ejecución
                            lineal de la CPU, habilitando bucles y decisiones. Concepto crítico: conversión de enteros sin signo
                            a con signo (Two's Complement) para offsets relativos negativos. Implementación de timing condicional
                            (diferentes ciclos según si se toma o no el salto). Suite completa de tests TDD (11 tests) validando
                            saltos positivos, negativos y condicionales.
                        </p>
                    </li>
                    <!-- Entrada 0004 - ALU y Flags -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0004__alu-flags.html" class="entry-link">
                                    Implementación de la ALU y Gestión de Flags
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0004 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de la ALU (Unidad Aritmética Lógica) con gestión correcta de flags, especialmente
                            el Half-Carry (H) crítico para DAA. Refactorización de la CPU para usar tabla de despacho (dispatch table)
                            en lugar de if/elif. Implementación de opcodes ADD A, d8 (0xC6) y SUB d8 (0xD6). Suite completa de tests TDD
                            (5 tests) validando operaciones aritméticas y flags.
                        </p>
                    </li>
                    <!-- Entrada 0003 - Ciclo de Instrucción CPU -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0003__ciclo-instruccion-cpu.html" class="entry-link">
                                    Implementación del Ciclo de Instrucción de la CPU
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0003 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de la clase CPU que unifica Registros y MMU para crear el ciclo Fetch-Decode-Execute.
                            Primeros 3 opcodes implementados (NOP, LD A,d8, LD B,d8). La CPU ahora puede ejecutar instrucciones
                            secuencialmente, marcando el primer "latido" funcional del emulador. Suite completa de tests (6 tests pasando).
                        </p>
                    </li>
                    <!-- Entrada 0002 - MMU Básica -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0002__mmu-basica.html" class="entry-link">
                                    Implementación de la MMU Básica
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0002 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación de la clase MMU (Memory Management Unit) que gestiona el espacio de direcciones
                            de 16 bits de la Game Boy. Métodos para leer/escribir bytes y palabras con soporte correcto para
                            Little-Endian. Suite completa de tests unitarios (13 tests pasando).
                        </p>
                    </li>
                    <!-- Entrada 0001 - Registros CPU -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0001__registros-cpu.html" class="entry-link">
                                    Implementación de los Registros de la CPU (LR35902)
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0001 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Implementación completa de la clase Registers con todos los registros de 8 y 16 bits,
                            pares virtuales (AF, BC, DE, HL), peculiaridad hardware del registro F, y suite completa
                            de tests unitarios (15 tests pasando).
                        </p>
                    </li>
                    <!-- Entrada 0000 - Bootstrap -->
                    <li>
                        <div class="entry-header">
                            <h3 class="entry-title">
                                <a href="entries/2025-12-16__0000__bootstrap.html" class="entry-link">
                                    Bootstrap: Configuración de la Bitácora Web
                                </a>
                            </h3>
                        </div>
                        <div class="entry-meta-index">
                            <strong>Fecha:</strong> 2025-12-16 | 
                            <strong>Step ID:</strong> 0000 | 
                            <strong>Estado:</strong> <span class="tag tag-verified">Verified</span>
                        </div>
                        <p class="entry-summary">
                            Configuración inicial de la bitácora web estática con estructura HTML/CSS,
                            plantilla base, y primera entrada. Sistema de documentación educativa
                            para el proyecto Viboy Color.
                        </p>
                    </li>
                </ul>
            </section>

            <section id="informacion">
                <h2>Información del Proyecto</h2>
                <div class="card">
                    <h3>Sobre Viboy Color</h3>
                    <p>
                        <strong>Viboy Color</strong> es un emulador educativo de Game Boy Color
                        escrito en Python 3.10+. El objetivo principal es aprender sobre
                        emulación de hardware mediante una implementación clean-room, sin copiar
                        código de otros emuladores existentes.
                    </p>
                </div>

                <div class="card">
                    <h3>Principios del Proyecto</h3>
                    <ul>
                        <li><strong>Clean-Room:</strong> Implementación basada únicamente en documentación técnica y tests permitidas.</li>
                        <li><strong>Educativo:</strong> Priorizar comprensión y documentación del aprendizaje.</li>
                        <li><strong>Portabilidad:</strong> Compatible con Windows, Linux y macOS.</li>
                        <li><strong>Python Moderno:</strong> Uso de Python 3.10+ con tipado estricto y tests.</li>
                    </ul>
                </div>

                <div class="card">
                    <h3>Estructura de las Entradas</h3>
                    <p>Cada entrada de la bitácora incluye:</p>
                    <ul>
                        <li><strong>Resumen:</strong> Descripción breve del paso</li>
                        <li><strong>Concepto de Hardware:</strong> Explicación educativa del concepto implementado</li>
                        <li><strong>Implementación:</strong> Qué se hizo y por qué</li>
                        <li><strong>Archivos Afectados:</strong> Lista de archivos creados/modificados</li>
                        <li><strong>Tests y Verificación:</strong> Cómo se validó la implementación</li>
                        <li><strong>Fuentes Consultadas:</strong> Referencias técnicas utilizadas</li>
                        <li><strong>Integridad Educativa:</strong> Lo que se entiende, lo que falta confirmar, hipótesis</li>
                        <li><strong>Próximos Pasos:</strong> Checklist de tareas siguientes</li>
                    </ul>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer>
            <p><strong>Viboy Color</strong> - Emulador educativo de Game Boy Color</p>
            <p>Proyecto Open Source - Clean-Room Implementation</p>
            <p>No se copia código de otros emuladores. Basado únicamente en documentación técnica.</p>
        </footer>
    </div>
</body>
</html>

